<?xml version="1.0" encoding="UTF-8"?>
<yguard version="1.5">
<!--
  yGuard Bytecode Obfuscator, v2.6, a Product of yWorks GmbH - http://www.yworks.com

  Logfile created on Sat Jul 29 23:17:54 MDT 2017

  Jar file to be obfuscated:           yguard_temp_3421837091788638393.jar
  Target Jar file for obfuscated code: sonicbase-core-1.2.1.jar

-->
<!-- WARNING
Methods are called which may break in obfuscated version at runtime.
Please review your source code to ensure that the dangerous methods are not intended
to act on classes which have been obfuscated.
-->
<!--
     Your class com.sonicbase.server.MethodInvoker calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class com.sonicbase.server.DatabaseServer calls the java.lang.Class method java.lang.reflect.Field getDeclaredField(java.lang.String)
     Your class com.sonicbase.server.DatabaseServer calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
     Your class com.sonicbase.server.DatabaseServer calls the java.lang.Class method java.lang.reflect.Method getDeclaredMethod(java.lang.String, java.lang.Class[])
-->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInitializer not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInitializer not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInboundHandlerAdapter not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInboundHandlerAdapter not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.Job not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.Job not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInitializer not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInboundHandlerAdapter not found! -->
<!--
  Memory in use after class data structure built: 9673488 bytes
  Total memory available                        : 324534272 bytes
-->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.BeforeClass not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: No mapping found: org.codehaus.plexus.util.FileUtils -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: Unresolved external dependency: org.codehaus.plexus.util.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.Assert not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: No mapping found: org.codehaus.plexus.util.FileUtils -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: Unresolved external dependency: org.codehaus.plexus.util.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.Assert not found! -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: Unresolved external dependency: org.testng.Assert not found! -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: Unresolved external dependency: org.testng.Assert not found! -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: Unresolved external dependency: org.testng.Assert not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.BeforeClass not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.annotations.Test not found! -->
<!-- WARNING: No mapping found: org.codehaus.plexus.util.FileUtils -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: No mapping found: org.testng.Assert -->
<!-- WARNING: Unresolved external dependency: org.codehaus.plexus.util.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.testng.Assert not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpResponse not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.alter.Alter not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.ColDataType not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.truncate.Truncate not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.index.CreateIndex not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.delete.Delete not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.CreateTable not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.update.Update not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.insert.Insert not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Select not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.parser.CCJSqlParserManager -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.parser.CCJSqlParserManager -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Select not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.insert.Insert not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.update.Update not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.CreateTable not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.index.CreateIndex not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.delete.Delete not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.alter.Alter not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.truncate.Truncate not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.javanet.NetHttpTransport$Builder -->
<!-- WARNING: No mapping found: com.google.api.client.http.javanet.NetHttpTransport$Builder -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.javanet.NetHttpTransport not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.javanet.NetHttpTransport -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpRequestFactory not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.GenericUrl -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpRequestFactory -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.GenericUrl not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpRequest not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpRequest -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpRequest not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpRequest -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpHeaders not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpHeaders -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpRequest -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpHeaders not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpRequest not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpRequest -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpResponse not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpResponse not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpResponse -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.alter.Alter -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.alter.Alter -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Table -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.alter.Alter -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.ColDataType not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.alter.Alter -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.ColDataType not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.ColDataType -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.drop.Drop -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.drop.Drop -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Table -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.truncate.Truncate -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.index.CreateIndex -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.Index not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.Index -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.Index -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.index.CreateIndex -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.Index -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.delete.Delete -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.delete.Delete -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.CreateTable -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.CreateTable -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.ColumnDefinition -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.ColumnDefinition -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.ColDataType not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.ColDataType -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.ColumnDefinition -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.create.table.CreateTable -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.update.Update -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.update.Update -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Column not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.update.Update -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.update.Update -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.insert.Insert -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.insert.Insert -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.insert.Insert -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ItemsList not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.ExpressionList -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Column -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.StringValue -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.LongValue -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.DoubleValue -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Select -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.SelectBody not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.FromItem not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Join -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.FromItem not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Join -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Join -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Join -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Join -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Join -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Join -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Distinct not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.SelectExpressionItem -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Alias not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.Alias -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.SelectExpressionItem -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Column -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.Function -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.Function -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.Function -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.Function -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.PlainSelect -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.OrderByElement -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.OrderByElement -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.Between -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.Between -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.Between -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.Between -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.conditional.AndExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.conditional.AndExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.conditional.OrExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.conditional.OrExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.Parenthesis -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.BinaryExpression -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.BinaryExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.BinaryExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.InExpression -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.InExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.InExpression -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ItemsList not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.JdbcNamedParameter -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.MetricRegistry -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.MetricRegistry -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.parser.CCJSqlParserManager not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.Statement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Select not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.insert.Insert not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.update.Update not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.CreateTable not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.index.CreateIndex not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.delete.Delete not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.alter.Alter not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.drop.Drop not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.truncate.Truncate not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.javanet.NetHttpTransport$Builder not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.javanet.NetHttpTransport not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.GenericUrl not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpRequestFactory not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpRequest not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpHeaders not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpResponse not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.ColDataType not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.Index not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.create.table.ColumnDefinition not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Column not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.JdbcParameter not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.StringValue not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.LongValue not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.DoubleValue not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.PlainSelect not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.SelectBody not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Join not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.FromItem not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Distinct not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.SelectItem not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.SelectExpressionItem not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Alias not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Function not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.OrderByElement not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.Between not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.conditional.AndExpression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.conditional.OrExpression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Parenthesis not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.BinaryExpression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.EqualsTo not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.LikeExpression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.NotEqualsTo not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.MinorThan not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.MinorThanEquals not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.GreaterThan not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.GreaterThanEquals not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.InExpression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ItemsList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.SubSelect not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.JdbcNamedParameter not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.transfer.TransferManager not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.AmazonS3 not found! -->
<!-- WARNING: No mapping found: com.amazonaws.auth.BasicAWSCredentials -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.transfer.TransferManager -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.auth.AWSCredentials not found! -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.AmazonS3Client -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.auth.AWSCredentials not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.AmazonS3 not found! -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.ListObjectsV2Request -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.ListObjectsV2Request -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.ListObjectsV2Request not found! -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.ListObjectsV2Request -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.ListObjectsV2Request not found! -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.AmazonS3 -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.ListObjectsV2Request not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.ListObjectsV2Result not found! -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.ListObjectsV2Result -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.S3ObjectSummary -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.AmazonS3 -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.ListObjectsV2Result -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.ListObjectsV2Request -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.ListObjectsV2Result -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.PutObjectRequest -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.AmazonS3 -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.PutObjectRequest not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.PutObjectResult not found! -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.GetObjectRequest -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.AmazonS3 -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.GetObjectRequest not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.S3Object not found! -->
<!-- WARNING: No mapping found: com.amazonaws.services.s3.model.S3Object -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.S3ObjectInputStream not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.transfer.TransferManager not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.auth.BasicAWSCredentials not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.transfer.TransferManager not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.AmazonS3Client not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.AmazonS3 not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.ListObjectsV2Request not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.ListObjectsV2Result not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.S3ObjectSummary not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.PutObjectRequest not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.GetObjectRequest not found! -->
<!-- WARNING: Unresolved external dependency: com.amazonaws.services.s3.model.S3Object not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectMap$FastEntrySet not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectMap$FastEntrySet -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectIterator not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectMap$Entry -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.ints.Int2ObjectMap$Entry -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectMap$FastEntrySet not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.ints.Int2ObjectMap$Entry not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectSortedMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectSortedMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectSortedMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectSortedMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectSortedSet not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.ObjectSortedSet -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectSortedMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectSortedMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.ObjectSortedSet -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectSortedSet not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.ObjectSortedSet -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.ObjectSortedSet -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectCollection not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectCollection not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectAVLTreeMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectSortedMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectSortedSet not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: org.anarres.lzo.LzoOutputStream -->
<!-- WARNING: No mapping found: org.anarres.lzo.LzoDecompressor1x -->
<!-- WARNING: No mapping found: org.anarres.lzo.LzoInputStream -->
<!-- WARNING: Unresolved external dependency: org.anarres.lzo.LzoDecompressor not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.anarres.lzo.LzoOutputStream not found! -->
<!-- WARNING: Unresolved external dependency: org.anarres.lzo.LzoInputStream not found! -->
<!-- WARNING: Unresolved external dependency: org.anarres.lzo.LzoDecompressor1x not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap not found! -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap -->
<!-- WARNING: No mapping found: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap -->
<!-- WARNING: Unresolved external dependency: it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.Timer -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer$Context not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.Timer$Context -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.MetricRegistry -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer$Context not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Column -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Offset -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Limit -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Limit -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.statement.select.Limit -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.ExpressionList -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.LongValue -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Column not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.LongValue not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.Expression not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Column -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Table -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Column -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.expression.operators.relational.ExpressionList -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Limit not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.statement.select.Offset not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.Timer -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer$Context not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: com.codahale.metrics.Timer$Context -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Column not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer$Context not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Column not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Column -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Table -->
<!-- WARNING: No mapping found: net.sf.jsqlparser.schema.Column -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Column not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.schema.Table not found! -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInitializer not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.Channel not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelInitializer -->
<!-- WARNING: No mapping found: io.netty.channel.socket.SocketChannel -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelPipeline not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelPipeline -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandler not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelPipeline not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInitializer not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandler not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelPipeline not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBufAllocator not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelInboundHandlerAdapter -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.PooledByteBufAllocator not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBufAllocator not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBufAllocator -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4FastDecompressor not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4FastDecompressor -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelHandlerContext -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelHandlerContext -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInboundHandlerAdapter not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.PooledByteBufAllocator not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBufAllocator not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4FastDecompressor not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Compressor not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Compressor -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Compressor -->
<!-- WARNING: No mapping found: io.netty.channel.nio.NioEventLoopGroup -->
<!-- WARNING: No mapping found: io.netty.channel.nio.NioEventLoopGroup -->
<!-- WARNING: No mapping found: io.netty.bootstrap.ServerBootstrap -->
<!-- WARNING: No mapping found: io.netty.bootstrap.ServerBootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.ServerBootstrap not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.ServerBootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.AbstractBootstrap not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.ServerBootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandler not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.ServerBootstrap not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.ServerBootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.AbstractBootstrap not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.ServerBootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.ServerBootstrap not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.ServerBootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelFuture -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelFuture -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.Channel not found! -->
<!-- WARNING: No mapping found: io.netty.channel.Channel -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: No mapping found: io.netty.channel.EventLoopGroup -->
<!-- WARNING: Unresolved external dependency: io.netty.util.concurrent.Future not found! -->
<!-- WARNING: No mapping found: org.apache.commons.cli.Options -->
<!-- WARNING: No mapping found: org.apache.commons.cli.OptionBuilder -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.OptionBuilder not found! -->
<!-- WARNING: No mapping found: org.apache.commons.cli.OptionBuilder -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.OptionBuilder not found! -->
<!-- WARNING: No mapping found: org.apache.commons.cli.OptionBuilder -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.Option not found! -->
<!-- WARNING: No mapping found: org.apache.commons.cli.Options -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.Option not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.Options not found! -->
<!-- WARNING: No mapping found: org.apache.commons.cli.DefaultParser -->
<!-- WARNING: No mapping found: org.apache.commons.cli.CommandLineParser -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.Options not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.CommandLine not found! -->
<!-- WARNING: No mapping found: org.apache.commons.cli.CommandLine -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Compressor not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.nio.NioEventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.ServerBootstrap not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.nio.NioServerSocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.Channel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.Options not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.OptionBuilder not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.DefaultParser not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.CommandLineParser not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.cli.CommandLine not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.IOUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.IOUtils not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpResponse not found! -->
<!-- WARNING: No mapping found: com.google.api.client.http.HttpResponse -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: com.google.api.client.http.HttpResponse not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobExecutionContext not found! -->
<!-- WARNING: No mapping found: org.quartz.JobExecutionContext -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobDataMap not found! -->
<!-- WARNING: No mapping found: org.quartz.JobDataMap -->
<!-- WARNING: Unresolved external dependency: org.quartz.Job not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobExecutionException not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobExecutionContext not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobDataMap not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.quartz.JobDataMap -->
<!-- WARNING: No mapping found: org.quartz.JobDataMap -->
<!-- WARNING: No mapping found: org.quartz.JobBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.JobBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.JobBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobDataMap not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.JobBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobDetail not found! -->
<!-- WARNING: No mapping found: org.quartz.TriggerBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.TriggerBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.TriggerBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.TriggerBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.CronScheduleBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.CronScheduleBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.TriggerBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.ScheduleBuilder not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.TriggerBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.TriggerBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.TriggerBuilder not found! -->
<!-- WARNING: No mapping found: org.quartz.TriggerBuilder -->
<!-- WARNING: Unresolved external dependency: org.quartz.Trigger not found! -->
<!-- WARNING: No mapping found: org.quartz.impl.StdSchedulerFactory -->
<!-- WARNING: No mapping found: org.quartz.SchedulerFactory -->
<!-- WARNING: Unresolved external dependency: org.quartz.Scheduler not found! -->
<!-- WARNING: No mapping found: org.quartz.Scheduler -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobDetail not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.Trigger not found! -->
<!-- WARNING: No mapping found: org.quartz.Scheduler -->
<!-- WARNING: No mapping found: org.apache.commons.io.input.ReversedLinesFileReader -->
<!-- WARNING: No mapping found: org.apache.commons.io.input.ReversedLinesFileReader -->
<!-- WARNING: No mapping found: org.apache.commons.io.input.ReversedLinesFileReader -->
<!-- WARNING: No mapping found: com.sun.jersey.core.util.Base64 -->
<!-- WARNING: No mapping found: org.apache.commons.codec.binary.Hex -->
<!-- WARNING: No mapping found: org.apache.commons.codec.binary.Hex -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Compressor not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Compressor -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Compressor -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4FastDecompressor not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4FastDecompressor -->
<!-- WARNING: No mapping found: org.apache.commons.lang.exception.ExceptionUtils -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobDataMap not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.JobBuilder not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.TriggerBuilder not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.CronScheduleBuilder not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.impl.StdSchedulerFactory not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.SchedulerFactory not found! -->
<!-- WARNING: Unresolved external dependency: org.quartz.Scheduler not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.input.ReversedLinesFileReader not found! -->
<!-- WARNING: Unresolved external dependency: com.sun.jersey.core.util.Base64 not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.codec.binary.Hex not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Compressor not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4FastDecompressor not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang.exception.ExceptionUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.IOUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.IOUtils not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.Timer -->
<!-- WARNING: No mapping found: com.codahale.metrics.Timer -->
<!-- WARNING: No mapping found: com.codahale.metrics.Timer -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Snapshot not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.Snapshot -->
<!-- WARNING: No mapping found: com.codahale.metrics.Snapshot -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Snapshot not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.MetricRegistry -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: No mapping found: com.codahale.metrics.MetricRegistry -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.Timer not found! -->
<!-- WARNING: Unresolved external dependency: com.codahale.metrics.MetricRegistry not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelInboundHandlerAdapter -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: No mapping found: io.netty.channel.socket.SocketChannel -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelHandlerContext -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.Channel not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: No mapping found: io.netty.buffer.ByteBuf -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelHandlerContext -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInboundHandlerAdapter not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandlerContext not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.buffer.ByteBuf not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInitializer not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.Channel not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelInitializer -->
<!-- WARNING: No mapping found: io.netty.channel.socket.SocketChannel -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelPipeline not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelPipeline -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandler not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelPipeline not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelInitializer not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandler not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelPipeline not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.Bootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.Bootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.AbstractBootstrap not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.Bootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.AbstractBootstrap not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.Bootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.AbstractBootstrap not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.Bootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelHandler not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.AbstractBootstrap not found! -->
<!-- WARNING: No mapping found: io.netty.bootstrap.Bootstrap -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelFuture -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: No mapping found: io.netty.channel.ChannelFuture -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.Channel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.SocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.bootstrap.Bootstrap not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.socket.nio.NioSocketChannel not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelOption not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.ChannelFuture not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Compressor not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Compressor -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Compressor -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4Factory -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4FastDecompressor not found! -->
<!-- WARNING: No mapping found: net.jpountz.lz4.LZ4FastDecompressor -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.EventLoopGroup not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: io.netty.channel.nio.NioEventLoopGroup -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Factory not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4Compressor not found! -->
<!-- WARNING: Unresolved external dependency: net.jpountz.lz4.LZ4FastDecompressor not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: io.netty.channel.nio.NioEventLoopGroup not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.FileUtils -->
<!-- WARNING: Unresolved external dependency: net.sf.jsqlparser.expression.operators.relational.ExpressionList not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.FileUtils not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonArray not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: No mapping found: com.google.gson.JsonArray -->
<!-- WARNING: No mapping found: com.google.gson.JsonArray -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonElement not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonArray not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonArray not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonObject not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonObject not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonPrimitive not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: org.apache.log4j.Logger -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.log4j.Logger not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonArray not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonElement not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonPrimitive not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonObject not found! -->
<!-- WARNING: No mapping found: org.apache.commons.lang3.StringEscapeUtils -->
<!-- WARNING: No mapping found: com.google.gson.JsonParser -->
<!-- WARNING: No mapping found: com.google.gson.JsonParser -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonElement not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonObject not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonObject not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonObject -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonArray not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonArray not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: No mapping found: com.google.gson.JsonElement -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonPrimitive not found! -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: No mapping found: com.google.gson.JsonPrimitive -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.lang3.StringEscapeUtils not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonParser not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonElement not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonObject not found! -->
<!-- WARNING: Unresolved external dependency: com.google.gson.JsonPrimitive not found! -->
<!-- WARNING: No mapping found: org.apache.commons.io.IOUtils -->
<!-- WARNING: Unresolved external dependency: org.apache.commons.io.IOUtils not found! -->
<expose>
  <class name="com.sonicbase.research.socket.NettyServer"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="void main(java.lang.String[])"/>
  <class name="ReconfigureResults"/>
  <method class="ReconfigureResults" name="boolean isHandedOffToMaster()"/>
  <method class="ReconfigureResults" name="int getShardCount()"/>
  <class name="com.sonicbase.server.MethodInvoker"/>
  <field class="com.sonicbase.server.MethodInvoker" name="echo2Count"/>
  <field class="com.sonicbase.server.MethodInvoker" name="echoCount"/>
  <field class="com.sonicbase.server.MethodInvoker" name="blockCount"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject pushMaxSequenceNum(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject isBackupComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getRecoverProgress(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getFile(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject prepareToComeAlive(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject dropColumn(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getOSStats(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject deleteMovedRecords(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject deleteRecord(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject markReplicaDead(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject echo2(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject insertIndexEntryByKeyWithRecord(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject areAllLongRunningCommandsComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getLogFile(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject populateIndex(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject countRecords(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject rollback(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject prepareForRestore(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject truncateTable(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject healthCheckPriority(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject indexLookupExpression(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject isServerReloadFinished(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject createIndexSlave(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject promoteToMaster(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject moveIndexEntries(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject stopRepartitioning(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject indexLookup(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject logError(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="byte[] handleCommand(java.lang.String, byte[], boolean, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject dropTable(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject sendLogsToPeer(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject createIndex(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject setMaxSequenceNum(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject createDatabase(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject doRestoreFileSystem(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject batchIndexLookup(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getKeyAtOffset(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject forceDeletes(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject closeResultSet(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject insertIndexEntryByKey(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject evaluateCounter(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject doBackupFileSystem(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="byte[] startBackup(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject serverSelect(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject beginRebalance(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="int getTestWriteCallCount()"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject promoteEntireReplicaToMaster(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getLastBackupDir(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject doBackupAWS(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject finishServerReloadForSource(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject updateSchema(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getIndexCounts(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject prepareForBackup(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject healthCheck(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject abortTransaction(java.lang.String, byte[], boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="byte[] noOp(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject updateServersConfig(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject echo(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject electNewMaster(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject serverSelectDelete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="byte[] sendQueueFile(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject isEntireBackupComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject startRestore(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject deletePeerLogs(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject notifyRepartitioningComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject promoteToMasterAndPushSchema(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject reloadServer(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject isShardRepartitioningComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject createTable(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject dropIndexSlave(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject prepareSourceForServerReload(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="void setRepartitioner(com.sonicbase.index.Repartitioner)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject isRepartitioningComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject testWrite(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject expirePreparedStatement(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject doPopulateIndex(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject isEntireRestoreComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getDatabaseFile(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getConfig(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject deleteIndexEntryByKey(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject updateRecord(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject block(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject rebalanceOrderedIndex(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject batchInsertIndexEntryByKey(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject addColumn(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject createTableSlave(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject isRestoreComplete(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject dropIndex(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject allocateRecordIds(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject commit(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject setMaxRecordId(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject reconfigureCluster(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getDbNames(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject doRebalanceOrderedIndex(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getSchema(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject doRestoreAWS(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject reserveNextIdFromReplica(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject getPartitionSize(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject markReplicaAlive(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="byte[] handleCommand(java.lang.String, byte[], long, long, boolean, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject finishRestore(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject finishBackup(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="void shutdown()"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject deleteIndexEntry(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject pushMaxRecordId(ComObject, boolean)"/>
  <method class="com.sonicbase.server.MethodInvoker" name="ComObject batchInsertIndexEntryByKeyWithRecord(ComObject, boolean)"/>
  <class name="FieldSchema"/>
  <method class="FieldSchema" name="void deserialize(java.io.DataInputStream, int)"/>
  <method class="FieldSchema" name="DataType$Type getType()"/>
  <method class="FieldSchema" name="void setName(java.lang.String)"/>
  <method class="FieldSchema" name="void setAutoIncrement(boolean)"/>
  <method class="FieldSchema" name="void serialize(java.io.DataOutputStream)"/>
  <method class="FieldSchema" name="void setMapToOffset(int)"/>
  <method class="FieldSchema" name="void setType(DataType$Type)"/>
  <method class="FieldSchema" name="java.lang.String getName()"/>
  <method class="FieldSchema" name="boolean isArray()"/>
  <method class="FieldSchema" name="int getMapToOffset()"/>
  <method class="FieldSchema" name="int getWidth()"/>
  <method class="FieldSchema" name="boolean isAutoIncrement()"/>
  <method class="FieldSchema" name="void setWidth(int)"/>
  <method class="FieldSchema" name="void setArray(boolean)"/>
  <class name="TableSchema"/>
  <method class="TableSchema" name="void setFields(java.util.List)"/>
  <method class="TableSchema" name="void setTableId(int)"/>
  <method class="TableSchema" name="java.lang.Integer getFieldOffset(java.lang.String)"/>
  <method class="TableSchema" name="java.util.Comparator[] getComparators(java.lang.String[])"/>
  <method class="TableSchema" name="java.lang.String[] getPrimaryKey()"/>
  <method class="TableSchema" name="void setPrimaryKey(java.util.List)"/>
  <method class="TableSchema" name="java.util.Map getIndexesById()"/>
  <method class="TableSchema" name="void deserialize(java.io.DataInputStream, int)"/>
  <method class="TableSchema" name="void addField(FieldSchema)"/>
  <method class="TableSchema" name="java.util.Map getIndexes()"/>
  <method class="TableSchema" name="void saveFields(long)"/>
  <method class="TableSchema" name="java.util.List getFields()"/>
  <method class="TableSchema" name="void setName(java.lang.String)"/>
  <method class="TableSchema" name="java.lang.String getName()"/>
  <method class="TableSchema" name="void serialize(java.io.DataOutputStream)"/>
  <method class="TableSchema" name="int getTableId()"/>
  <method class="TableSchema" name="java.util.Map getIndices()"/>
  <method class="TableSchema" name="void addIndex(java.lang.String, boolean, java.lang.String[], TableSchema$Partition[], int)"/>
  <method class="TableSchema" name="TableSchema deepCopy()"/>
  <method class="TableSchema" name="void markChangesComplete()"/>
  <method class="TableSchema" name="java.util.List getFieldsForVersion(long, long)"/>
  <class name="DataType$Type"/>
  <field class="DataType$Type" name="PARAMETER"/>
  <field class="DataType$Type" name="CHAR"/>
  <field class="DataType$Type" name="JAVA_OBJECT"/>
  <field class="DataType$Type" name="OTHER"/>
  <field class="DataType$Type" name="DOUBLE"/>
  <field class="DataType$Type" name="INTEGER"/>
  <field class="DataType$Type" name="TIME"/>
  <field class="DataType$Type" name="ARRAY"/>
  <field class="DataType$Type" name="CLOB"/>
  <field class="DataType$Type" name="REF"/>
  <field class="DataType$Type" name="DATE"/>
  <field class="DataType$Type" name="TINYINT"/>
  <field class="DataType$Type" name="NUMERIC"/>
  <field class="DataType$Type" name="ROWID"/>
  <field class="DataType$Type" name="VARCHAR"/>
  <field class="DataType$Type" name="LONGNVARCHAR"/>
  <field class="DataType$Type" name="BIGINT"/>
  <field class="DataType$Type" name="LONGVARBINARY"/>
  <field class="DataType$Type" name="BOOLEAN"/>
  <field class="DataType$Type" name="DECIMAL"/>
  <field class="DataType$Type" name="NVARCHAR"/>
  <field class="DataType$Type" name="DISTINCT"/>
  <field class="DataType$Type" name="DATALINK"/>
  <field class="DataType$Type" name="NULL"/>
  <field class="DataType$Type" name="TIMESTAMP"/>
  <field class="DataType$Type" name="BIT"/>
  <field class="DataType$Type" name="REAL"/>
  <field class="DataType$Type" name="NCHAR"/>
  <field class="DataType$Type" name="SQLXML"/>
  <field class="DataType$Type" name="LONGVARCHAR"/>
  <field class="DataType$Type" name="FLOAT"/>
  <field class="DataType$Type" name="VARBINARY"/>
  <field class="DataType$Type" name="BLOB"/>
  <field class="DataType$Type" name="SMALLINT"/>
  <field class="DataType$Type" name="BINARY"/>
  <field class="DataType$Type" name="NCLOB"/>
  <field class="DataType$Type" name="STRUCT"/>
  <method class="DataType$Type" name="DataType$Converter getConverter()"/>
  <method class="DataType$Type" name="DataType$Type valueOf(java.lang.String)"/>
  <method class="DataType$Type" name="java.lang.Object getInitialValue()"/>
  <method class="DataType$Type" name="DataType$Type[] values()"/>
  <method class="DataType$Type" name="DataType$Type valueOf(int)"/>
  <method class="DataType$Type" name="DataType$Incrementer getIncrementer()"/>
  <method class="DataType$Type" name="int getValue()"/>
  <method class="DataType$Type" name="java.util.Comparator getComparator()"/>
  <method class="DataType$Type" name="java.util.Comparator getComparatorForValue(java.lang.Object)"/>
  <class name="DataType"/>
  <method class="DataType" name="DataType$Converter getTimestampConverter()"/>
  <method class="DataType" name="DataType$Converter getUtf8Converter()"/>
  <method class="DataType" name="java.util.Comparator getUtf8Comparator()"/>
  <method class="DataType" name="java.util.Comparator getTimestampComparator()"/>
  <method class="DataType" name="java.util.Comparator getByteArrayComparator()"/>
  <method class="DataType" name="DataType$Converter getLongConverter()"/>
  <method class="DataType" name="java.util.Comparator getFloatComparator()"/>
  <method class="DataType" name="java.util.Comparator getShortComparator()"/>
  <method class="DataType" name="DataType$Converter getBooleanConverter()"/>
  <method class="DataType" name="java.util.Comparator getBigDecimalComparator()"/>
  <method class="DataType" name="DataType$Incrementer getBigDecimalIncrementer()"/>
  <method class="DataType" name="DataType$Converter getByteConverter()"/>
  <method class="DataType" name="java.util.Comparator getDateComparator()"/>
  <method class="DataType" name="java.util.Comparator getDoubleComparator()"/>
  <method class="DataType" name="DataType$Converter getBigDecimalConverter()"/>
  <method class="DataType" name="DataType$Converter getBlobConverter()"/>
  <method class="DataType" name="java.util.Comparator getLongComparator()"/>
  <method class="DataType" name="DataType$Converter getTimeConverter()"/>
  <method class="DataType" name="DataType$Converter getStringConverter()"/>
  <method class="DataType" name="DataType$Converter getFloatConverter()"/>
  <method class="DataType" name="java.util.Comparator getBlobComparator()"/>
  <method class="DataType" name="java.util.Comparator getByteComparator()"/>
  <method class="DataType" name="DataType$Converter getByteArrayConverter()"/>
  <method class="DataType" name="java.util.Comparator getBooleanComparator()"/>
  <method class="DataType" name="java.util.Comparator getTimeComparator()"/>
  <method class="DataType" name="DataType$Converter getIntConverter()"/>
  <method class="DataType" name="java.util.Comparator getIntComparator()"/>
  <method class="DataType" name="DataType$Converter getDoubleConverter()"/>
  <method class="DataType" name="java.util.Comparator getStringComparator()"/>
  <method class="DataType" name="DataType$Converter getDateConverter()"/>
  <method class="DataType" name="DataType$Incrementer getIntIncrementer()"/>
  <method class="DataType" name="DataType$Converter getShortConverter()"/>
  <method class="DataType" name="DataType$Incrementer getLongIncrementer()"/>
  <class name="com.sonicbase.util.StreamUtils"/>
  <method class="com.sonicbase.util.StreamUtils" name="byte[] inputStreamToBytes(java.io.InputStream)"/>
  <method class="com.sonicbase.util.StreamUtils" name="java.lang.String readerToString(java.io.Reader)"/>
  <method class="com.sonicbase.util.StreamUtils" name="void copyStream(java.io.InputStream, java.io.OutputStream)"/>
  <method class="com.sonicbase.util.StreamUtils" name="java.lang.String inputStreamToString(java.io.InputStream)"/>
  <class name="com.sonicbase.util.JsonArray"/>
  <method class="com.sonicbase.util.JsonArray" name="com.sonicbase.util.JsonArray fromJson(com.google.gson.JsonArray)"/>
  <method class="com.sonicbase.util.JsonArray" name="long[] toLongArray()"/>
  <method class="com.sonicbase.util.JsonArray" name="com.sonicbase.util.JsonArray addArray()"/>
  <method class="com.sonicbase.util.JsonArray" name="int getInt(int)"/>
  <method class="com.sonicbase.util.JsonArray" name="com.sonicbase.util.JsonDict getDict(int)"/>
  <method class="com.sonicbase.util.JsonArray" name="java.lang.String[] toStringArray()"/>
  <method class="com.sonicbase.util.JsonArray" name="boolean[] toBooleanArray()"/>
  <method class="com.sonicbase.util.JsonArray" name="void remove(int)"/>
  <method class="com.sonicbase.util.JsonArray" name="java.lang.String toString()"/>
  <method class="com.sonicbase.util.JsonArray" name="com.sonicbase.util.JsonDict addDict()"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(int[])"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonArray" name="com.sonicbase.util.JsonArray getArray(int)"/>
  <method class="com.sonicbase.util.JsonArray" name="long getLong(int)"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(boolean)"/>
  <method class="com.sonicbase.util.JsonArray" name="int[] toIntArray()"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(java.lang.String[])"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(long)"/>
  <method class="com.sonicbase.util.JsonArray" name="int size()"/>
  <method class="com.sonicbase.util.JsonArray" name="void toString(java.lang.StringBuilder, boolean)"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(com.sonicbase.util.JsonDict[])"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(boolean[])"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(java.lang.Integer)"/>
  <method class="com.sonicbase.util.JsonArray" name="java.lang.String getString(int)"/>
  <method class="com.sonicbase.util.JsonArray" name="com.sonicbase.util.JsonDict addDict(com.sonicbase.util.JsonDict)"/>
  <method class="com.sonicbase.util.JsonArray" name="com.sonicbase.util.JsonDict[] toDictArray()"/>
  <method class="com.sonicbase.util.JsonArray" name="boolean isArray(int)"/>
  <method class="com.sonicbase.util.JsonArray" name="void add(long[])"/>
  <method class="com.sonicbase.util.JsonArray" name="boolean isDict(int)"/>
  <class name="DateUtils"/>
  <method class="DateUtils" name="java.util.Calendar from8601String(java.lang.String)"/>
  <method class="DateUtils" name="java.lang.String fromDate(java.util.Date)"/>
  <method class="DateUtils" name="java.lang.String to8601String(java.util.Date)"/>
  <method class="DateUtils" name="java.lang.String fromCalendar(java.util.Calendar)"/>
  <class name="com.sonicbase.util.JsonDict"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonArray putArray(java.lang.String, com.sonicbase.util.JsonArray)"/>
  <method class="com.sonicbase.util.JsonDict" name="java.lang.Boolean getBoolean(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="java.lang.Double getDouble(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="boolean hasKey(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="int getInt(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="boolean isBoolean(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonArray putArray(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict fromJson(com.google.gson.JsonObject)"/>
  <method class="com.sonicbase.util.JsonDict" name="boolean isDouble(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="java.lang.String toString()"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict putDict(java.lang.String, com.sonicbase.util.JsonDict)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict put(java.lang.String, boolean)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonArray putArray(java.lang.String, java.util.List)"/>
  <method class="com.sonicbase.util.JsonDict" name="java.lang.String toString(boolean)"/>
  <method class="com.sonicbase.util.JsonDict" name="boolean isDict(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="boolean isLong(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="void add(com.sonicbase.util.JsonDict)"/>
  <method class="com.sonicbase.util.JsonDict" name="java.util.Set getEntrySet()"/>
  <method class="com.sonicbase.util.JsonDict" name="java.util.List keys()"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonArray getArray(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="void remove(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict put(java.lang.String, java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict put(java.lang.String, long)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict putDict(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="int size()"/>
  <method class="com.sonicbase.util.JsonDict" name="void toString(java.lang.StringBuilder, boolean)"/>
  <method class="com.sonicbase.util.JsonDict" name="boolean isString(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict fromString(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="java.lang.String getString(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict getDict(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="boolean isArray(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="java.lang.Long getLong(java.lang.String)"/>
  <method class="com.sonicbase.util.JsonDict" name="com.sonicbase.util.JsonDict put(java.lang.String, double)"/>
  <class name="LicenseOutOfComplianceException"/>
  <class name="MemUtil"/>
  <method class="MemUtil" name="double getMemValue(java.lang.String)"/>
  <class name="ComObject$Tag"/>
  <field class="ComObject$Tag" name="recordLength"/>
  <field class="ComObject$Tag" name="directory"/>
  <field class="ComObject$Tag" name="isPrepared"/>
  <field class="ComObject$Tag" name="bytes"/>
  <field class="ComObject$Tag" name="isComplete"/>
  <field class="ComObject$Tag" name="stage"/>
  <field class="ComObject$Tag" name="tag"/>
  <field class="ComObject$Tag" name="finished"/>
  <field class="ComObject$Tag" name="javaMemMin"/>
  <field class="ComObject$Tag" name="cpu"/>
  <field class="ComObject$Tag" name="retKeys"/>
  <field class="ComObject$Tag" name="count"/>
  <field class="ComObject$Tag" name="indexId"/>
  <field class="ComObject$Tag" name="files"/>
  <field class="ComObject$Tag" name="offset"/>
  <field class="ComObject$Tag" name="schemaVersion"/>
  <field class="ComObject$Tag" name="diskAvail"/>
  <field class="ComObject$Tag" name="sequence1"/>
  <field class="ComObject$Tag" name="method"/>
  <field class="ComObject$Tag" name="legacyCounter"/>
  <field class="ComObject$Tag" name="requestedMasterReplica"/>
  <field class="ComObject$Tag" name="sequence0"/>
  <field class="ComObject$Tag" name="tableId"/>
  <field class="ComObject$Tag" name="records"/>
  <field class="ComObject$Tag" name="percentComplete"/>
  <field class="ComObject$Tag" name="nextId"/>
  <field class="ComObject$Tag" name="isCommitting"/>
  <field class="ComObject$Tag" name="replica"/>
  <field class="ComObject$Tag" name="offsets"/>
  <field class="ComObject$Tag" name="indices"/>
  <field class="ComObject$Tag" name="filename"/>
  <field class="ComObject$Tag" name="binaryFileContent"/>
  <field class="ComObject$Tag" name="port"/>
  <field class="ComObject$Tag" name="message"/>
  <field class="ComObject$Tag" name="javaMemMax"/>
  <field class="ComObject$Tag" name="phase"/>
  <field class="ComObject$Tag" name="size"/>
  <field class="ComObject$Tag" name="status"/>
  <field class="ComObject$Tag" name="shared"/>
  <field class="ComObject$Tag" name="keys"/>
  <field class="ComObject$Tag" name="schemaBytes"/>
  <field class="ComObject$Tag" name="slave"/>
  <field class="ComObject$Tag" name="configBytes"/>
  <field class="ComObject$Tag" name="singleValue"/>
  <field class="ComObject$Tag" name="id"/>
  <field class="ComObject$Tag" name="requestedMasterShard"/>
  <field class="ComObject$Tag" name="bucket"/>
  <field class="ComObject$Tag" name="columnOffsets"/>
  <field class="ComObject$Tag" name="isExcpliciteTrans"/>
  <field class="ComObject$Tag" name="leftOperator"/>
  <field class="ComObject$Tag" name="exception"/>
  <field class="ComObject$Tag" name="haveProLicense"/>
  <field class="ComObject$Tag" name="insertObjects"/>
  <field class="ComObject$Tag" name="force"/>
  <field class="ComObject$Tag" name="command"/>
  <field class="ComObject$Tag" name="type"/>
  <field class="ComObject$Tag" name="tableRecords"/>
  <field class="ComObject$Tag" name="parms"/>
  <field class="ComObject$Tag" name="fileContent"/>
  <field class="ComObject$Tag" name="transactionId"/>
  <field class="ComObject$Tag" name="highestId"/>
  <field class="ComObject$Tag" name="subDirectory"/>
  <field class="ComObject$Tag" name="rightKey"/>
  <field class="ComObject$Tag" name="preparedId"/>
  <field class="ComObject$Tag" name="longKey"/>
  <field class="ComObject$Tag" name="masterSlave"/>
  <field class="ComObject$Tag" name="orderByExpressions"/>
  <field class="ComObject$Tag" name="indexName"/>
  <field class="ComObject$Tag" name="electedMaster"/>
  <field class="ComObject$Tag" name="filenames"/>
  <field class="ComObject$Tag" name="sequenceNumber"/>
  <field class="ComObject$Tag" name="tableName"/>
  <field class="ComObject$Tag" name="avgTransRate"/>
  <field class="ComObject$Tag" name="rightOperator"/>
  <field class="ComObject$Tag" name="counters"/>
  <field class="ComObject$Tag" name="legacySelectStatement"/>
  <field class="ComObject$Tag" name="serializationVersion"/>
  <field class="ComObject$Tag" name="countColumn"/>
  <field class="ComObject$Tag" name="isClient"/>
  <field class="ComObject$Tag" name="originalLeftKey"/>
  <field class="ComObject$Tag" name="countLong"/>
  <field class="ComObject$Tag" name="isUnique"/>
  <field class="ComObject$Tag" name="error"/>
  <field class="ComObject$Tag" name="serversConfig"/>
  <field class="ComObject$Tag" name="prefix"/>
  <field class="ComObject$Tag" name="resultSetId"/>
  <field class="ComObject$Tag" name="fieldsStr"/>
  <field class="ComObject$Tag" name="primaryKeyIndexName"/>
  <field class="ComObject$Tag" name="primaryKeyBytes"/>
  <field class="ComObject$Tag" name="legacyExpression"/>
  <field class="ComObject$Tag" name="keyBytes"/>
  <field class="ComObject$Tag" name="forceSelectOnServer"/>
  <field class="ComObject$Tag" name="maxId"/>
  <field class="ComObject$Tag" name="selectedMasteReplica"/>
  <field class="ComObject$Tag" name="keyLength"/>
  <field class="ComObject$Tag" name="leftKey"/>
  <field class="ComObject$Tag" name="legacyGroupContext"/>
  <field class="ComObject$Tag" name="createTableStatement"/>
  <field class="ComObject$Tag" name="dbNames"/>
  <field class="ComObject$Tag" name="dbName"/>
  <field class="ComObject$Tag" name="columnName"/>
  <field class="ComObject$Tag" name="keyCount"/>
  <field class="ComObject$Tag" name="dataType"/>
  <field class="ComObject$Tag" name="avgRecRate"/>
  <field class="ComObject$Tag" name="originalRightKey"/>
  <field class="ComObject$Tag" name="countTableName"/>
  <field class="ComObject$Tag" name="resGig"/>
  <field class="ComObject$Tag" name="maxBackupCount"/>
  <field class="ComObject$Tag" name="host"/>
  <field class="ComObject$Tag" name="insertObject"/>
  <field class="ComObject$Tag" name="evaluateExpression"/>
  <field class="ComObject$Tag" name="shard"/>
  <field class="ComObject$Tag" name="recordBytes"/>
  <field class="ComObject$Tag" name="tables"/>
  <field class="ComObject$Tag" name="viewVersion"/>
  <method class="ComObject$Tag" name="ComObject$Tag valueOf(java.lang.String)"/>
  <method class="ComObject$Tag" name="ComObject$Tag[] values()"/>
  <class name="ComObject"/>
  <method class="ComObject" name="ComArray putArray(ComObject$Tag, ComObject$Type)"/>
  <method class="ComObject" name="java.lang.Integer getInt(ComObject$Tag)"/>
  <method class="ComObject" name="void deserialize(byte[])"/>
  <method class="ComObject" name="ComObject putObject(ComObject$Tag)"/>
  <method class="ComObject" name="java.lang.Double getDouble(ComObject$Tag)"/>
  <method class="ComObject" name="void put(ComObject$Tag, int)"/>
  <method class="ComObject" name="java.lang.Float getFloat(ComObject$Tag)"/>
  <method class="ComObject" name="java.lang.Boolean getBoolean(ComObject$Tag)"/>
  <method class="ComObject" name="void deserialize(java.io.DataInputStream)"/>
  <method class="ComObject" name="byte[] getByteArray(ComObject$Tag)"/>
  <method class="ComObject" name="byte[] serialize()"/>
  <method class="ComObject" name="java.lang.String getString(ComObject$Tag)"/>
  <method class="ComObject" name="void put(ComObject$Tag, double)"/>
  <method class="ComObject" name="void put(ComObject$Tag, byte[])"/>
  <method class="ComObject" name="ComObject getObject(ComObject$Tag)"/>
  <method class="ComObject" name="void remove(ComObject$Tag)"/>
  <method class="ComObject" name="void put(ComObject$Tag, float)"/>
  <method class="ComObject" name="void put(ComObject$Tag, boolean)"/>
  <method class="ComObject" name="ComArray getArray(ComObject$Tag)"/>
  <method class="ComObject" name="void put(ComObject$Tag, java.lang.String)"/>
  <method class="ComObject" name="java.lang.Long getLong(ComObject$Tag)"/>
  <method class="ComObject" name="void put(ComObject$Tag, long)"/>
  <class name="SchemaOutOfSyncException"/>
  <class name="com.sonicbase.common.WindowsTerminal"/>
  <method class="com.sonicbase.common.WindowsTerminal" name="void enableAnsi()"/>
  <method class="com.sonicbase.common.WindowsTerminal" name="java.lang.String getConsoleSize()"/>
  <class name="ComArray"/>
  <method class="ComArray" name="void add(int)"/>
  <method class="ComArray" name="void add(long)"/>
  <method class="ComArray" name="void serialize(java.io.DataOutputStream)"/>
  <method class="ComArray" name="void add(java.lang.String)"/>
  <method class="ComArray" name="void add(ComObject)"/>
  <method class="ComArray" name="void add(byte[])"/>
  <method class="ComArray" name="java.util.List getArray()"/>
  <method class="ComArray" name="ComArray addArray(ComObject$Tag, ComObject$Type)"/>
  <class name="ResultSetImpl"/>
  <method class="ResultSetImpl" name="java.lang.String getString(java.lang.String)"/>
  <method class="ResultSetImpl" name="boolean isBeforeFirst()"/>
  <method class="ResultSetImpl" name="byte[] getBytes(int)"/>
  <method class="ResultSetImpl" name="int getRow()"/>
  <method class="ResultSetImpl" name="java.lang.Short getShort(int)"/>
  <method class="ResultSetImpl" name="java.lang.Double getDouble(int)"/>
  <method class="ResultSetImpl" name="boolean isLast()"/>
  <method class="ResultSetImpl" name="boolean next()"/>
  <method class="ResultSetImpl" name="java.lang.Integer getInt(int)"/>
  <method class="ResultSetImpl" name="java.lang.Boolean getBoolean(int)"/>
  <method class="ResultSetImpl" name="java.io.InputStream getAsciiStream(java.lang.String)"/>
  <method class="ResultSetImpl" name="boolean isAfterLast()"/>
  <method class="ResultSetImpl" name="java.lang.Integer getInt(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.math.BigDecimal getBigDecimal(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.sql.Time getTime(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.sql.Timestamp getTimestamp(java.lang.String)"/>
  <method class="ResultSetImpl" name="void getMoreResults()"/>
  <method class="ResultSetImpl" name="void close()"/>
  <method class="ResultSetImpl" name="void setCount(int)"/>
  <method class="ResultSetImpl" name="java.lang.Short getShort(java.lang.String)"/>
  <method class="ResultSetImpl" name="void sortResults(java.lang.String, DatabaseCommon, SelectStatementImpl, ExpressionImpl$CachedRecord[][], java.lang.String[])"/>
  <method class="ResultSetImpl" name="java.lang.Long getLong(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.lang.String[] getDescribeStrs()"/>
  <method class="ResultSetImpl" name="boolean last()"/>
  <method class="ResultSetImpl" name="java.io.Reader getCharacterStream(int)"/>
  <method class="ResultSetImpl" name="void forceSelectOnServer()"/>
  <method class="ResultSetImpl" name="java.math.BigDecimal getBigDecimal(int)"/>
  <method class="ResultSetImpl" name="java.math.BigDecimal getBigDecimal(int, int)"/>
  <method class="ResultSetImpl" name="boolean isFirst()"/>
  <method class="ResultSetImpl" name="java.lang.Double getDouble(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.lang.Boolean getBoolean(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.lang.Byte getByte(int)"/>
  <method class="ResultSetImpl" name="java.lang.String getString(int)"/>
  <method class="ResultSetImpl" name="java.io.InputStream getUnicodeStream(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.sql.Timestamp getTimestamp(int)"/>
  <method class="ResultSetImpl" name="java.io.InputStream getBinaryStream(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.lang.Float getFloat(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.lang.Long getLong(int)"/>
  <method class="ResultSetImpl" name="java.sql.Date getDate(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.sql.Time getTime(int)"/>
  <method class="ResultSetImpl" name="ExpressionImpl$RecordCache getRecordCache()"/>
  <method class="ResultSetImpl" name="java.sql.Date getDate(int)"/>
  <method class="ResultSetImpl" name="java.lang.Object getField(int)"/>
  <method class="ResultSetImpl" name="java.math.BigDecimal getBigDecimal(java.lang.String, int)"/>
  <method class="ResultSetImpl" name="java.lang.Byte getByte(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.lang.Float getFloat(int)"/>
  <method class="ResultSetImpl" name="void setPageSize(int)"/>
  <method class="ResultSetImpl" name="java.lang.Object getGroupByFunctionResults(java.lang.String, DataType$Type)"/>
  <method class="ResultSetImpl" name="java.io.Reader getCharacterStream(java.lang.String)"/>
  <method class="ResultSetImpl" name="java.lang.String getIndexUsed()"/>
  <method class="ResultSetImpl" name="byte[] getBytes(java.lang.String)"/>
  <method class="ResultSetImpl" name="ExpressionImpl$CachedRecord[][] getReadRecordsAndSerializedRecords()"/>
  <method class="ResultSetImpl" name="java.io.InputStream getBinaryStream(int)"/>
  <class name="DatabaseException"/>
  <method class="ResultSet" name="java.math.BigDecimal getBigDecimal(int, int)"/>
  <method class="ResultSet" name="java.lang.Long getLong(int)"/>
  <method class="ResultSet" name="byte[] getBytes(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Boolean getBoolean(java.lang.String)"/>
  <method class="ResultSet" name="java.math.BigDecimal getBigDecimal(int)"/>
  <method class="ResultSet" name="java.lang.Double getDouble(java.lang.String)"/>
  <method class="ResultSet" name="java.sql.Timestamp getTimestamp(java.lang.String)"/>
  <method class="ResultSet" name="java.io.InputStream getBinaryStream(int)"/>
  <method class="ResultSet" name="java.lang.Boolean getBoolean(int)"/>
  <method class="ResultSet" name="java.lang.Double getDouble(int)"/>
  <method class="ResultSet" name="java.io.Reader getCharacterStream(java.lang.String)"/>
  <method class="ResultSet" name="boolean next()"/>
  <method class="ResultSet" name="java.io.InputStream getUnicodeStream(java.lang.String)"/>
  <method class="ResultSet" name="java.sql.Date getDate(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Byte getByte(int)"/>
  <method class="ResultSet" name="java.sql.Time getTime(int)"/>
  <method class="ResultSet" name="java.sql.Timestamp getTimestamp(int)"/>
  <method class="ResultSet" name="java.math.BigDecimal getBigDecimal(java.lang.String, int)"/>
  <method class="ResultSet" name="java.lang.Short getShort(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Byte getByte(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Short getShort(int)"/>
  <method class="ResultSet" name="java.lang.Integer getInt(int)"/>
  <method class="ResultSet" name="java.sql.Date getDate(int)"/>
  <method class="ResultSet" name="java.math.BigDecimal getBigDecimal(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Integer getInt(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Float getFloat(int)"/>
  <method class="ResultSet" name="java.sql.Time getTime(java.lang.String)"/>
  <method class="ResultSet" name="java.io.InputStream getBinaryStream(java.lang.String)"/>
  <method class="ResultSet" name="byte[] getBytes(int)"/>
  <method class="ResultSet" name="java.lang.String getString(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Float getFloat(java.lang.String)"/>
  <method class="ResultSet" name="java.lang.Long getLong(java.lang.String)"/>
  <class name="ResultSetProxy"/>
  <method class="ResultSetProxy" name="void updateLong(int, long)"/>
  <method class="ResultSetProxy" name="void updateCharacterStream(java.lang.String, java.io.Reader)"/>
  <method class="ResultSetProxy" name="void updateObject(int, java.lang.Object, int)"/>
  <method class="ResultSetProxy" name="void updateCharacterStream(int, java.io.Reader, int)"/>
  <method class="ResultSetProxy" name="java.io.Reader getNCharacterStream(int)"/>
  <method class="ResultSetProxy" name="void updateTime(int, java.sql.Time)"/>
  <method class="ResultSetProxy" name="java.lang.Object getObject(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.io.InputStream getUnicodeStream(int)"/>
  <method class="ResultSetProxy" name="void updateSQLXML(int, java.sql.SQLXML)"/>
  <method class="ResultSetProxy" name="void updateBinaryStream(int, java.io.InputStream, int)"/>
  <method class="ResultSetProxy" name="java.sql.Date getDate(java.lang.String, java.util.Calendar)"/>
  <method class="ResultSetProxy" name="void beforeFirst()"/>
  <method class="ResultSetProxy" name="int getRow()"/>
  <method class="ResultSetProxy" name="java.math.BigDecimal getBigDecimal(int)"/>
  <method class="ResultSetProxy" name="boolean rowInserted()"/>
  <method class="ResultSetProxy" name="java.net.URL getURL(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateBinaryStream(java.lang.String, java.io.InputStream, int)"/>
  <method class="ResultSetProxy" name="void updateNull(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateNClob(int, java.io.Reader)"/>
  <method class="ResultSetProxy" name="java.sql.Timestamp getTimestamp(java.lang.String, java.util.Calendar)"/>
  <method class="ResultSetProxy" name="void updateCharacterStream(java.lang.String, java.io.Reader, int)"/>
  <method class="ResultSetProxy" name="void updateDouble(int, double)"/>
  <method class="ResultSetProxy" name="void setFetchDirection(int)"/>
  <method class="ResultSetProxy" name="double getDouble(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateNCharacterStream(java.lang.String, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="void updateString(int, java.lang.String)"/>
  <method class="ResultSetProxy" name="void afterLast()"/>
  <method class="ResultSetProxy" name="java.sql.Ref getRef(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateByte(int, byte)"/>
  <method class="ResultSetProxy" name="void updateNull(int)"/>
  <method class="ResultSetProxy" name="void updateAsciiStream(int, java.io.InputStream, int)"/>
  <method class="ResultSetProxy" name="void updateTimestamp(int, java.sql.Timestamp)"/>
  <method class="ResultSetProxy" name="java.math.BigDecimal getBigDecimal(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.sql.Statement getStatement()"/>
  <method class="ResultSetProxy" name="void updateDate(java.lang.String, java.sql.Date)"/>
  <method class="ResultSetProxy" name="void updateLong(java.lang.String, long)"/>
  <method class="ResultSetProxy" name="java.sql.ResultSetMetaData getMetaData()"/>
  <method class="ResultSetProxy" name="void updateInt(int, int)"/>
  <method class="ResultSetProxy" name="void updateObject(java.lang.String, java.lang.Object)"/>
  <method class="ResultSetProxy" name="boolean isClosed()"/>
  <method class="ResultSetProxy" name="boolean getBoolean(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateBlob(java.lang.String, java.io.InputStream, long)"/>
  <method class="ResultSetProxy" name="float getFloat(int)"/>
  <method class="ResultSetProxy" name="void updateNClob(java.lang.String, java.sql.NClob)"/>
  <method class="ResultSetProxy" name="int findColumn(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateClob(int, java.io.Reader)"/>
  <method class="ResultSetProxy" name="java.lang.String getCursorName()"/>
  <method class="ResultSetProxy" name="void updateBinaryStream(int, java.io.InputStream)"/>
  <method class="ResultSetProxy" name="long getLong(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateAsciiStream(java.lang.String, java.io.InputStream)"/>
  <method class="ResultSetProxy" name="void updateRowId(int, java.sql.RowId)"/>
  <method class="ResultSetProxy" name="void updateCharacterStream(int, java.io.Reader)"/>
  <method class="ResultSetProxy" name="void updateRowId(java.lang.String, java.sql.RowId)"/>
  <method class="ResultSetProxy" name="java.net.URL getURL(int)"/>
  <method class="ResultSetProxy" name="byte getByte(int)"/>
  <method class="ResultSetProxy" name="void updateArray(java.lang.String, java.sql.Array)"/>
  <method class="ResultSetProxy" name="void updateBytes(int, byte[])"/>
  <method class="ResultSetProxy" name="byte getByte(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateAsciiStream(int, java.io.InputStream)"/>
  <method class="ResultSetProxy" name="java.sql.Time getTime(int, java.util.Calendar)"/>
  <method class="ResultSetProxy" name="java.sql.Date getDate(int, java.util.Calendar)"/>
  <method class="ResultSetProxy" name="void updateInt(java.lang.String, int)"/>
  <method class="ResultSetProxy" name="void updateTime(java.lang.String, java.sql.Time)"/>
  <method class="ResultSetProxy" name="java.io.Reader getNCharacterStream(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.math.BigDecimal getBigDecimal(java.lang.String, int)"/>
  <method class="ResultSetProxy" name="java.sql.Blob getBlob(java.lang.String)"/>
  <method class="ResultSetProxy" name="long getLong(int)"/>
  <method class="ResultSetProxy" name="java.sql.RowId getRowId(int)"/>
  <method class="ResultSetProxy" name="boolean isWrapperFor(java.lang.Class)"/>
  <method class="ResultSetProxy" name="boolean last()"/>
  <method class="ResultSetProxy" name="void updateBlob(int, java.sql.Blob)"/>
  <method class="ResultSetProxy" name="java.io.InputStream getAsciiStream(int)"/>
  <method class="ResultSetProxy" name="java.sql.SQLXML getSQLXML(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateNClob(int, java.sql.NClob)"/>
  <method class="ResultSetProxy" name="java.sql.Timestamp getTimestamp(int, java.util.Calendar)"/>
  <method class="ResultSetProxy" name="void updateClob(int, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="void clearWarnings()"/>
  <method class="ResultSetProxy" name="void updateObject(java.lang.String, java.lang.Object, int)"/>
  <method class="ResultSetProxy" name="void updateBlob(int, java.io.InputStream, long)"/>
  <method class="ResultSetProxy" name="java.sql.SQLXML getSQLXML(int)"/>
  <method class="ResultSetProxy" name="boolean wasNull()"/>
  <method class="ResultSetProxy" name="java.sql.Clob getClob(int)"/>
  <method class="ResultSetProxy" name="java.sql.RowId getRowId(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.lang.Object unwrap(java.lang.Class)"/>
  <method class="ResultSetProxy" name="byte[] getBytes(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.sql.Array getArray(int)"/>
  <method class="ResultSetProxy" name="void deleteRow()"/>
  <method class="ResultSetProxy" name="int getFetchDirection()"/>
  <method class="ResultSetProxy" name="void updateNString(java.lang.String, java.lang.String)"/>
  <method class="ResultSetProxy" name="java.sql.Array getArray(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateAsciiStream(java.lang.String, java.io.InputStream, int)"/>
  <method class="ResultSetProxy" name="void close()"/>
  <method class="ResultSetProxy" name="java.sql.Ref getRef(int)"/>
  <method class="ResultSetProxy" name="boolean first()"/>
  <method class="ResultSetProxy" name="java.lang.String getNString(int)"/>
  <method class="ResultSetProxy" name="void updateClob(int, java.sql.Clob)"/>
  <method class="ResultSetProxy" name="void updateCharacterStream(int, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="void updateBlob(int, java.io.InputStream)"/>
  <method class="ResultSetProxy" name="boolean getBoolean(int)"/>
  <method class="ResultSetProxy" name="void updateByte(java.lang.String, byte)"/>
  <method class="ResultSetProxy" name="void updateDouble(java.lang.String, double)"/>
  <method class="ResultSetProxy" name="void updateBinaryStream(int, java.io.InputStream, long)"/>
  <method class="ResultSetProxy" name="void updateFloat(java.lang.String, float)"/>
  <method class="ResultSetProxy" name="java.lang.Object getObject(int)"/>
  <method class="ResultSetProxy" name="java.io.InputStream getBinaryStream(int)"/>
  <method class="ResultSetProxy" name="java.io.InputStream getBinaryStream(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateRef(java.lang.String, java.sql.Ref)"/>
  <method class="ResultSetProxy" name="void updateBinaryStream(java.lang.String, java.io.InputStream, long)"/>
  <method class="ResultSetProxy" name="void updateBinaryStream(java.lang.String, java.io.InputStream)"/>
  <method class="ResultSetProxy" name="void updateBigDecimal(int, java.math.BigDecimal)"/>
  <method class="ResultSetProxy" name="int getConcurrency()"/>
  <method class="ResultSetProxy" name="void updateTimestamp(java.lang.String, java.sql.Timestamp)"/>
  <method class="ResultSetProxy" name="void updateCharacterStream(java.lang.String, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="java.io.InputStream getUnicodeStream(java.lang.String)"/>
  <method class="ResultSetProxy" name="double getDouble(int)"/>
  <method class="ResultSetProxy" name="short getShort(int)"/>
  <method class="ResultSetProxy" name="float getFloat(java.lang.String)"/>
  <method class="ResultSetProxy" name="boolean previous()"/>
  <method class="ResultSetProxy" name="void updateArray(int, java.sql.Array)"/>
  <method class="ResultSetProxy" name="void updateShort(int, short)"/>
  <method class="ResultSetProxy" name="void setFetchSize(int)"/>
  <method class="ResultSetProxy" name="short getShort(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateNClob(java.lang.String, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="void moveToInsertRow()"/>
  <method class="ResultSetProxy" name="boolean isAfterLast()"/>
  <method class="ResultSetProxy" name="void updateDate(int, java.sql.Date)"/>
  <method class="ResultSetProxy" name="void updateAsciiStream(int, java.io.InputStream, long)"/>
  <method class="ResultSetProxy" name="void updateBlob(java.lang.String, java.sql.Blob)"/>
  <method class="ResultSetProxy" name="java.sql.Timestamp getTimestamp(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.sql.Clob getClob(java.lang.String)"/>
  <method class="ResultSetProxy" name="int getType()"/>
  <method class="ResultSetProxy" name="java.lang.String getNString(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.sql.Timestamp getTimestamp(int)"/>
  <method class="ResultSetProxy" name="void updateFloat(int, float)"/>
  <method class="ResultSetProxy" name="boolean isFirst()"/>
  <method class="ResultSetProxy" name="java.lang.Object getObject(int, java.util.Map)"/>
  <method class="ResultSetProxy" name="java.sql.Time getTime(int)"/>
  <method class="ResultSetProxy" name="byte[] getBytes(int)"/>
  <method class="ResultSetProxy" name="java.io.Reader getCharacterStream(int)"/>
  <method class="ResultSetProxy" name="void updateClob(java.lang.String, java.io.Reader)"/>
  <method class="ResultSetProxy" name="java.lang.String getString(java.lang.String)"/>
  <method class="ResultSetProxy" name="void moveToCurrentRow()"/>
  <method class="ResultSetProxy" name="java.sql.SQLWarning getWarnings()"/>
  <method class="ResultSetProxy" name="java.lang.Object getObject(java.lang.String, java.lang.Class)"/>
  <method class="ResultSetProxy" name="java.lang.String getString(int)"/>
  <method class="ResultSetProxy" name="void updateNCharacterStream(int, java.io.Reader)"/>
  <method class="ResultSetProxy" name="java.sql.NClob getNClob(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateBytes(java.lang.String, byte[])"/>
  <method class="ResultSetProxy" name="void updateNClob(int, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="void refreshRow()"/>
  <method class="ResultSetProxy" name="boolean relative(int)"/>
  <method class="ResultSetProxy" name="java.lang.Object getObject(int, java.lang.Class)"/>
  <method class="ResultSetProxy" name="void updateSQLXML(java.lang.String, java.sql.SQLXML)"/>
  <method class="ResultSetProxy" name="boolean isBeforeFirst()"/>
  <method class="ResultSetProxy" name="int getFetchSize()"/>
  <method class="ResultSetProxy" name="java.sql.Date getDate(int)"/>
  <method class="ResultSetProxy" name="void updateNString(int, java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateClob(java.lang.String, java.sql.Clob)"/>
  <method class="ResultSetProxy" name="void updateClob(java.lang.String, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="java.sql.Blob getBlob(int)"/>
  <method class="ResultSetProxy" name="void updateNCharacterStream(int, java.io.Reader, long)"/>
  <method class="ResultSetProxy" name="java.sql.Time getTime(java.lang.String, java.util.Calendar)"/>
  <method class="ResultSetProxy" name="void updateObject(int, java.lang.Object)"/>
  <method class="ResultSetProxy" name="java.io.Reader getCharacterStream(java.lang.String)"/>
  <method class="ResultSetProxy" name="java.sql.Date getDate(java.lang.String)"/>
  <method class="ResultSetProxy" name="boolean absolute(int)"/>
  <method class="ResultSetProxy" name="java.io.InputStream getAsciiStream(java.lang.String)"/>
  <method class="ResultSetProxy" name="void updateBlob(java.lang.String, java.io.InputStream)"/>
  <method class="ResultSetProxy" name="void updateString(java.lang.String, java.lang.String)"/>
  <method class="ResultSetProxy" name="int getInt(java.lang.String)"/>
  <method class="ResultSetProxy" name="void insertRow()"/>
  <method class="ResultSetProxy" name="void updateBigDecimal(java.lang.String, java.math.BigDecimal)"/>
  <method class="ResultSetProxy" name="boolean isLast()"/>
  <method class="ResultSetProxy" name="void cancelRowUpdates()"/>
  <method class="ResultSetProxy" name="boolean rowUpdated()"/>
  <method class="ResultSetProxy" name="void updateBoolean(int, boolean)"/>
  <method class="ResultSetProxy" name="void updateBoolean(java.lang.String, boolean)"/>
  <method class="ResultSetProxy" name="boolean rowDeleted()"/>
  <method class="ResultSetProxy" name="java.lang.Object getObject(java.lang.String, java.util.Map)"/>
  <method class="ResultSetProxy" name="void updateNClob(java.lang.String, java.io.Reader)"/>
  <method class="ResultSetProxy" name="int getHoldability()"/>
  <method class="ResultSetProxy" name="boolean next()"/>
  <method class="ResultSetProxy" name="java.sql.NClob getNClob(int)"/>
  <method class="ResultSetProxy" name="void updateShort(java.lang.String, short)"/>
  <method class="ResultSetProxy" name="void updateRow()"/>
  <method class="ResultSetProxy" name="void updateAsciiStream(java.lang.String, java.io.InputStream, long)"/>
  <method class="ResultSetProxy" name="void updateNCharacterStream(java.lang.String, java.io.Reader)"/>
  <method class="ResultSetProxy" name="void updateRef(int, java.sql.Ref)"/>
  <method class="ResultSetProxy" name="java.sql.Time getTime(java.lang.String)"/>
  <method class="ResultSetProxy" name="int getInt(int)"/>
  <method class="ResultSetProxy" name="java.math.BigDecimal getBigDecimal(int, int)"/>
  <class name="ConnectionProxy$Replica"/>
  <field class="ConnectionProxy$Replica" name="secondary"/>
  <field class="ConnectionProxy$Replica" name="all"/>
  <field class="ConnectionProxy$Replica" name="primary"/>
  <field class="ConnectionProxy$Replica" name="master"/>
  <field class="ConnectionProxy$Replica" name="specified"/>
  <field class="ConnectionProxy$Replica" name="def"/>
  <method class="ConnectionProxy$Replica" name="ConnectionProxy$Replica valueOf(java.lang.String)"/>
  <method class="ConnectionProxy$Replica" name="ConnectionProxy$Replica[] values()"/>
  <class name="ConnectionProxy"/>
  <method class="ConnectionProxy" name="java.sql.PreparedStatement prepareStatement(java.lang.String)"/>
  <method class="ConnectionProxy" name="int getTransactionIsolation()"/>
  <method class="ConnectionProxy" name="java.lang.String debugRecord(java.lang.String, java.lang.String, java.lang.String, java.lang.String)"/>
  <method class="ConnectionProxy" name="void beginExplicitTransaction(java.lang.String)"/>
  <method class="ConnectionProxy" name="void setNetworkTimeout(java.util.concurrent.Executor, int)"/>
  <method class="ConnectionProxy" name="void rollback()"/>
  <method class="ConnectionProxy" name="void startRestore(java.lang.String)"/>
  <method class="ConnectionProxy" name="java.util.Properties getClientInfo()"/>
  <method class="ConnectionProxy" name="void releaseSavepoint(java.sql.Savepoint)"/>
  <method class="ConnectionProxy" name="void setHoldability(int)"/>
  <method class="ConnectionProxy" name="java.sql.SQLWarning getWarnings()"/>
  <method class="ConnectionProxy" name="java.sql.Blob createBlob()"/>
  <method class="ConnectionProxy" name="java.sql.PreparedStatement prepareStatement(java.lang.String, int)"/>
  <method class="ConnectionProxy" name="java.sql.Statement createStatement(int, int, int)"/>
  <method class="ConnectionProxy" name="java.sql.PreparedStatement prepareStatement(java.lang.String, int[])"/>
  <method class="ConnectionProxy" name="void syncSchema()"/>
  <method class="ConnectionProxy" name="ResultSet describeLicenses()"/>
  <method class="ConnectionProxy" name="int getHoldability()"/>
  <method class="ConnectionProxy" name="int getShardCount()"/>
  <method class="ConnectionProxy" name="boolean isBackupComplete()"/>
  <method class="ConnectionProxy" name="boolean isRestoreComplete()"/>
  <method class="ConnectionProxy" name="void abort(java.util.concurrent.Executor)"/>
  <method class="ConnectionProxy" name="void clearWarnings()"/>
  <method class="ConnectionProxy" name="void setCatalog(java.lang.String)"/>
  <method class="ConnectionProxy" name="java.sql.Savepoint setSavepoint(java.lang.String)"/>
  <method class="ConnectionProxy" name="java.sql.Savepoint setSavepoint()"/>
  <method class="ConnectionProxy" name="boolean isReadOnly()"/>
  <method class="ConnectionProxy" name="java.lang.String getClientInfo(java.lang.String)"/>
  <method class="ConnectionProxy" name="java.sql.Statement createStatement()"/>
  <method class="ConnectionProxy" name="java.sql.Statement createStatement(int, int)"/>
  <method class="ConnectionProxy" name="void setAutoCommit(boolean)"/>
  <method class="ConnectionProxy" name="boolean isClosed()"/>
  <method class="ConnectionProxy" name="java.lang.String getDbName()"/>
  <method class="ConnectionProxy" name="boolean isWrapperFor(java.lang.Class)"/>
  <method class="ConnectionProxy" name="java.sql.Array createArrayOf(java.lang.String, java.lang.Object[])"/>
  <method class="ConnectionProxy" name="java.util.Map getTypeMap()"/>
  <method class="ConnectionProxy" name="java.sql.PreparedStatement prepareStatement(java.lang.String, int, int)"/>
  <method class="ConnectionProxy" name="java.sql.DatabaseMetaData getMetaData()"/>
  <method class="ConnectionProxy" name="int getMasterReplica(int)"/>
  <method class="ConnectionProxy" name="void createDatabase(java.lang.String)"/>
  <method class="ConnectionProxy" name="byte[] send(java.lang.String, int, long, java.lang.String, ComObject, ConnectionProxy$Replica)"/>
  <method class="ConnectionProxy" name="void setTransactionIsolation(int)"/>
  <method class="ConnectionProxy" name="java.sql.CallableStatement prepareCall(java.lang.String)"/>
  <method class="ConnectionProxy" name="byte[] sendToMaster(java.lang.String, ComObject)"/>
  <method class="ConnectionProxy" name="void setClientInfo(java.util.Properties)"/>
  <method class="ConnectionProxy" name="void commit()"/>
  <method class="ConnectionProxy" name="java.lang.String getSchema()"/>
  <method class="ConnectionProxy" name="byte[] send(java.lang.String, int, long, java.lang.String, ComObject, ConnectionProxy$Replica, boolean)"/>
  <method class="ConnectionProxy" name="void setClientInfo(java.lang.String, java.lang.String)"/>
  <method class="ConnectionProxy" name="java.sql.Clob createClob()"/>
  <method class="ConnectionProxy" name="boolean isValid(int)"/>
  <method class="ConnectionProxy" name="long getSchemaVersion()"/>
  <method class="ConnectionProxy" name="void setSchema(java.lang.String)"/>
  <method class="ConnectionProxy" name="java.util.Map getTables(java.lang.String)"/>
  <method class="ConnectionProxy" name="int getNetworkTimeout()"/>
  <method class="ConnectionProxy" name="java.lang.String nativeSQL(java.lang.String)"/>
  <method class="ConnectionProxy" name="java.sql.Struct createStruct(java.lang.String, java.lang.Object[])"/>
  <method class="ConnectionProxy" name="java.sql.SQLXML createSQLXML()"/>
  <method class="ConnectionProxy" name="DatabaseClient getDatabaseClient()"/>
  <method class="ConnectionProxy" name="void rollback(java.sql.Savepoint)"/>
  <method class="ConnectionProxy" name="int getReplicaCount()"/>
  <method class="ConnectionProxy" name="java.sql.CallableStatement prepareCall(java.lang.String, int, int)"/>
  <method class="ConnectionProxy" name="java.sql.NClob createNClob()"/>
  <method class="ConnectionProxy" name="java.lang.Object unwrap(java.lang.Class)"/>
  <method class="ConnectionProxy" name="void close()"/>
  <method class="ConnectionProxy" name="java.sql.PreparedStatement prepareStatement(java.lang.String, int, int, int)"/>
  <method class="ConnectionProxy" name="boolean getAutoCommit()"/>
  <method class="ConnectionProxy" name="void setReadOnly(boolean)"/>
  <method class="ConnectionProxy" name="java.sql.CallableStatement prepareCall(java.lang.String, int, int, int)"/>
  <method class="ConnectionProxy" name="ReconfigureResults reconfigureCluster()"/>
  <method class="ConnectionProxy" name="void startBackup()"/>
  <method class="ConnectionProxy" name="java.lang.String getCatalog()"/>
  <method class="ConnectionProxy" name="java.sql.PreparedStatement prepareStatement(java.lang.String, java.lang.String[])"/>
  <method class="ConnectionProxy" name="void setTypeMap(java.util.Map)"/>
  <class name="Driver"/>
  <field class="Driver" name="MINOR_VERSION"/>
  <field class="Driver" name="URL_PREFIX"/>
  <field class="Driver" name="MAJOR_VERSION"/>
  <method class="Driver" name="java.util.logging.Logger getParentLogger()"/>
  <method class="Driver" name="int getMajorVersion()"/>
  <method class="Driver" name="java.sql.Connection connect(java.lang.String, java.util.Properties)"/>
  <method class="Driver" name="int getMinorVersion()"/>
  <method class="Driver" name="java.sql.DriverPropertyInfo[] getPropertyInfo(java.lang.String, java.util.Properties)"/>
  <method class="Driver" name="boolean acceptsURL(java.lang.String)"/>
  <method class="Driver" name="boolean jdbcCompliant()"/>
</expose>
<map>
  <package name="com.sonicbase.bench" map="A"/>
  <class name="com.sonicbase.bench.TestServers$2" map="2"/>
  <field class="com.sonicbase.bench.TestServers$2" name="val$dbServers" map="A"/>
  <field class="com.sonicbase.bench.TestServers$2" name="val$shard" map="B"/>
  <method class="com.sonicbase.bench.TestServers$2" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.bench.TestServers$1" map="1"/>
  <field class="com.sonicbase.bench.TestServers$1" name="val$dbServers" map="A"/>
  <method class="com.sonicbase.bench.TestServers$1" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.bench.TestServers" map="A"/>
  <method class="com.sonicbase.bench.TestServers" name="void main(java.lang.String[])" map="A"/>
  <class name="com.sonicbase.bench.TestRebalance$1" map="1"/>
  <field class="com.sonicbase.bench.TestRebalance$1" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestRebalance$1" name="val$dbServers" map="B"/>
  <field class="com.sonicbase.bench.TestRebalance$1" name="val$shard" map="C"/>
  <field class="com.sonicbase.bench.TestRebalance$1" name="val$config" map="D"/>
  <method class="com.sonicbase.bench.TestRebalance$1" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.bench.TestRebalance" map="B"/>
  <method class="com.sonicbase.bench.TestRebalance" name="void testBasics()" map="A"/>
  <class name="com.sonicbase.bench.TestMisc" map="C"/>
  <method class="com.sonicbase.bench.TestMisc" name="void test()" map="A"/>
  <class name="com.sonicbase.bench.TestConcurrentSkipListMap$2" map="2"/>
  <field class="com.sonicbase.bench.TestConcurrentSkipListMap$2" name="val$offset" map="A"/>
  <field class="com.sonicbase.bench.TestConcurrentSkipListMap$2" name="val$begin" map="B"/>
  <field class="com.sonicbase.bench.TestConcurrentSkipListMap$2" name="val$rand" map="C"/>
  <field class="com.sonicbase.bench.TestConcurrentSkipListMap$2" name="val$map" map="D"/>
  <method class="com.sonicbase.bench.TestConcurrentSkipListMap$2" name="void run()" map="run"/>
  <class name="com.sonicbase.bench.TestConcurrentSkipListMap$1" map="1"/>
  <method class="com.sonicbase.bench.TestConcurrentSkipListMap$1" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.bench.TestConcurrentSkipListMap$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.bench.TestConcurrentSkipListMap" map="D"/>
  <method class="com.sonicbase.bench.TestConcurrentSkipListMap" name="void main(java.lang.String[])" map="A"/>
  <class name="com.sonicbase.bench.TestTransactions$6" map="6"/>
  <field class="com.sonicbase.bench.TestTransactions$6" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestTransactions$6" name="val$updated" map="B"/>
  <field class="com.sonicbase.bench.TestTransactions$6" name="val$latch" map="C"/>
  <method class="com.sonicbase.bench.TestTransactions$6" name="void run()" map="run"/>
  <class name="com.sonicbase.bench.TestTransactions$5" map="5"/>
  <field class="com.sonicbase.bench.TestTransactions$5" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestTransactions$5" name="val$latch2" map="B"/>
  <field class="com.sonicbase.bench.TestTransactions$5" name="val$latch" map="C"/>
  <method class="com.sonicbase.bench.TestTransactions$5" name="void run()" map="run"/>
  <class name="com.sonicbase.bench.TestTransactions$4" map="4"/>
  <field class="com.sonicbase.bench.TestTransactions$4" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestTransactions$4" name="val$updated" map="B"/>
  <field class="com.sonicbase.bench.TestTransactions$4" name="val$latch2" map="C"/>
  <field class="com.sonicbase.bench.TestTransactions$4" name="val$latch" map="D"/>
  <method class="com.sonicbase.bench.TestTransactions$4" name="void run()" map="run"/>
  <class name="com.sonicbase.bench.TestTransactions$3" map="3"/>
  <field class="com.sonicbase.bench.TestTransactions$3" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestTransactions$3" name="val$updated" map="B"/>
  <field class="com.sonicbase.bench.TestTransactions$3" name="val$latch" map="C"/>
  <method class="com.sonicbase.bench.TestTransactions$3" name="void run()" map="run"/>
  <class name="com.sonicbase.bench.TestTransactions$2" map="2"/>
  <field class="com.sonicbase.bench.TestTransactions$2" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestTransactions$2" name="val$latch" map="B"/>
  <method class="com.sonicbase.bench.TestTransactions$2" name="void run()" map="run"/>
  <class name="com.sonicbase.bench.TestTransactions$1" map="1"/>
  <field class="com.sonicbase.bench.TestTransactions$1" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestTransactions$1" name="val$dbServers" map="B"/>
  <field class="com.sonicbase.bench.TestTransactions$1" name="val$shard" map="C"/>
  <field class="com.sonicbase.bench.TestTransactions$1" name="val$config" map="D"/>
  <method class="com.sonicbase.bench.TestTransactions$1" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.bench.TestTransactions" map="E"/>
  <field class="com.sonicbase.bench.TestTransactions" name="conn2" map="A"/>
  <field class="com.sonicbase.bench.TestTransactions" name="conn" map="B"/>
  <method class="com.sonicbase.bench.TestTransactions" name="void testConcurrent4()" map="A"/>
  <method class="com.sonicbase.bench.TestTransactions" name="void testConcurrentSecondaryKeys()" map="B"/>
  <method class="com.sonicbase.bench.TestTransactions" name="void testConcurrent()" map="C"/>
  <method class="com.sonicbase.bench.TestTransactions" name="void testConcurrent3()" map="D"/>
  <method class="com.sonicbase.bench.TestTransactions" name="java.sql.Connection access$000(com.sonicbase.bench.TestTransactions)" map="A"/>
  <method class="com.sonicbase.bench.TestTransactions" name="void testConcurrent2()" map="E"/>
  <method class="com.sonicbase.bench.TestTransactions" name="void beforeClass()" map="F"/>
  <method class="com.sonicbase.bench.TestTransactions" name="void test()" map="G"/>
  <class name="com.sonicbase.bench.TestDatabaseAdvancedToDo$1" map="1"/>
  <field class="com.sonicbase.bench.TestDatabaseAdvancedToDo$1" name="this$0" map="A"/>
  <field class="com.sonicbase.bench.TestDatabaseAdvancedToDo$1" name="val$dbServers" map="B"/>
  <field class="com.sonicbase.bench.TestDatabaseAdvancedToDo$1" name="val$shard" map="C"/>
  <field class="com.sonicbase.bench.TestDatabaseAdvancedToDo$1" name="val$config" map="D"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo$1" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.bench.TestDatabaseAdvancedToDo" map="F"/>
  <field class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="ids" map="A"/>
  <field class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="recordCount" map="B"/>
  <field class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="conn" map="C"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testAlterTable()" map="A"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void beforeClass()" map="B"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testInsertFromSelect()" map="C"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testAlias3()" map="D"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testDropTable()" map="E"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testCreateTableLike()" map="F"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testHaving()" map="G"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testDropIndex()" map="H"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testInsertColumn()" map="I"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testCopyTable()" map="J"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testCase()" map="K"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testToDate()" map="L"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testUnion()" map="M"/>
  <method class="com.sonicbase.bench.TestDatabaseAdvancedToDo" name="void testChangeFieldDataType()" map="N"/>
  <class name="com.sonicbase.research.socket.NettyServer$3" map="3"/>
  <field class="com.sonicbase.research.socket.NettyServer$3" name="this$0" map="A"/>
  <field class="com.sonicbase.research.socket.NettyServer$3" name="val$isRunning" map="B"/>
  <field class="com.sonicbase.research.socket.NettyServer$3" name="val$databaseServer" map="C"/>
  <method class="com.sonicbase.research.socket.NettyServer$3" name="void run()" map="run"/>
  <class name="com.sonicbase.research.socket.NettyServer$2" map="2"/>
  <field class="com.sonicbase.research.socket.NettyServer$2" name="this$0" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$2" name="void run()" map="run"/>
  <class name="com.sonicbase.research.socket.NettyServer$Request" map="_A"/>
  <field class="com.sonicbase.research.socket.NettyServer$Request" name="sequence0" map="A"/>
  <field class="com.sonicbase.research.socket.NettyServer$Request" name="body" map="B"/>
  <field class="com.sonicbase.research.socket.NettyServer$Request" name="response" map="C"/>
  <field class="com.sonicbase.research.socket.NettyServer$Request" name="latch" map="D"/>
  <field class="com.sonicbase.research.socket.NettyServer$Request" name="command" map="E"/>
  <field class="com.sonicbase.research.socket.NettyServer$Request" name="sequence1" map="F"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="byte[] getBody()" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="void setBody(byte[])" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="java.lang.String access$000(com.sonicbase.research.socket.NettyServer$Request)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="byte[] access$102(com.sonicbase.research.socket.NettyServer$Request, byte[])" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="long getSequence1()" map="B"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="java.lang.String access$002(com.sonicbase.research.socket.NettyServer$Request, java.lang.String)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="void setCommand(java.lang.String)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="byte[] access$100(com.sonicbase.research.socket.NettyServer$Request)" map="B"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="long getSequence0()" map="C"/>
  <method class="com.sonicbase.research.socket.NettyServer$Request" name="java.lang.String getCommand()" map="D"/>
  <class name="com.sonicbase.research.socket.NettyServer$1" map="1"/>
  <field class="com.sonicbase.research.socket.NettyServer$1" name="this$0" map="this$0"/>
  <method class="com.sonicbase.research.socket.NettyServer$1" name="void initChannel(io.netty.channel.Channel)" map="initChannel"/>
  <method class="com.sonicbase.research.socket.NettyServer$1" name="void initChannel(io.netty.channel.socket.SocketChannel)" map="initChannel"/>
  <class name="com.sonicbase.research.socket.NettyServer$RequestHandler" map="_B"/>
  <method class="com.sonicbase.research.socket.NettyServer$RequestHandler" name="java.lang.String handleCommandOld(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$RequestHandler" name="java.lang.String handleCommand(java.lang.String, java.lang.String)" map="B"/>
  <class name="com.sonicbase.research.socket.NettyServer$ReadState" map="_C"/>
  <field class="com.sonicbase.research.socket.NettyServer$ReadState" name="bytes" map="A"/>
  <field class="com.sonicbase.research.socket.NettyServer$ReadState" name="$VALUES" map="B"/>
  <field class="com.sonicbase.research.socket.NettyServer$ReadState" name="size" map="C"/>
  <field class="com.sonicbase.research.socket.NettyServer$ReadState" name="dlqSize" map="D"/>
  <field class="com.sonicbase.research.socket.NettyServer$ReadState" name="dlqBytes" map="E"/>
  <method class="com.sonicbase.research.socket.NettyServer$ReadState" name="com.sonicbase.research.socket.NettyServer$ReadState valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.sonicbase.research.socket.NettyServer$ReadState" name="com.sonicbase.research.socket.NettyServer$ReadState[] values()" map="values"/>
  <class name="com.sonicbase.research.socket.NettyServer$ServerHandler" map="_D"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="respBuffer" map="A"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="command" map="B"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="readState" map="C"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="destBuff" map="D"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="this$0" map="this$0"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="len" map="E"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="bodyLen" map="F"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="intBuff" map="G"/>
  <field class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="alloc" map="H"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="void channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object)" map="channelRead"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="void channelReadComplete(io.netty.channel.ChannelHandlerContext)" map="channelReadComplete"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="void handlerAdded(io.netty.channel.ChannelHandlerContext)" map="handlerAdded"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="java.util.List doProcessRequests(java.util.List)" map="doProcessRequests"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="byte[] doProcessRequest(com.sonicbase.research.socket.NettyServer$Request)" map="doProcessRequest"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="java.util.List processRequests(java.util.List)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="byte[] processRequest(java.lang.String, byte[])" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="byte[] returnException(java.lang.String, java.lang.Throwable)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="void exceptionCaught(io.netty.channel.ChannelHandlerContext, java.lang.Throwable)" map="exceptionCaught"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="void handlerRemoved(io.netty.channel.ChannelHandlerContext)" map="handlerRemoved"/>
  <method class="com.sonicbase.research.socket.NettyServer$ServerHandler" name="void processError(java.lang.String, java.util.List, java.lang.Throwable)" map="A"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="databaseServer" map="A"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="port" map="B"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="ENABLE_COMPRESSION" map="C"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="UTF8_STR" map="D"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="f" map="E"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="HOST_STR" map="F"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="dlqServer" map="G"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="bossGroup" map="H"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="PORT_STR" map="I"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="cluster" map="J"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="logger" map="K"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="workerGroup" map="L"/>
  <field class="com.sonicbase.research.socket.NettyServer" name="isRunning" map="M"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="java.lang.String getHelpPage(com.sonicbase.research.socket.NettyServer)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="void setDlqServer(com.sonicbase.research.socket.NettyServer$RequestHandler)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="Logger access$300()" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="void startServer(java.lang.String[], java.lang.String, boolean)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="boolean access$200(com.sonicbase.research.socket.NettyServer)" map="B"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="boolean isRunning()" map="B"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="byte[] sendResponse(byte[], java.io.OutputStream, byte[], int, java.util.ArrayList, java.io.ByteArrayOutputStream)" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="byte[] compress(byte[])" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="com.sonicbase.research.socket.NettyServer$Request deserializeRequest(java.io.InputStream, byte[])" map="A"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="com.sonicbase.server.DatabaseServer getDatabaseServer()" map="C"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="byte[] uncompress(byte[])" map="B"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="void run()" map="D"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="com.sonicbase.research.socket.NettyServer$RequestHandler getDlqServer()" map="E"/>
  <method class="com.sonicbase.research.socket.NettyServer" name="void setDatabaseServer(com.sonicbase.server.DatabaseServer)" map="A"/>
  <class name="com.sonicbase.research.socket.ChangeRequest" map="A"/>
  <field class="com.sonicbase.research.socket.ChangeRequest" name="socket" map="A"/>
  <field class="com.sonicbase.research.socket.ChangeRequest" name="CHANGEOPS" map="B"/>
  <field class="com.sonicbase.research.socket.ChangeRequest" name="REGISTER" map="C"/>
  <field class="com.sonicbase.research.socket.ChangeRequest" name="ops" map="D"/>
  <field class="com.sonicbase.research.socket.ChangeRequest" name="type" map="E"/>
  <method class="com.sonicbase.research.socket.ChangeRequest" name="int getType()" map="A"/>
  <method class="com.sonicbase.research.socket.ChangeRequest" name="void setOps(int)" map="A"/>
  <method class="com.sonicbase.research.socket.ChangeRequest" name="void setType(int)" map="B"/>
  <method class="com.sonicbase.research.socket.ChangeRequest" name="java.nio.channels.SocketChannel getSocket()" map="B"/>
  <method class="com.sonicbase.research.socket.ChangeRequest" name="void setSocket(java.nio.channels.SocketChannel)" map="A"/>
  <method class="com.sonicbase.research.socket.ChangeRequest" name="int getOps()" map="C"/>
  <class name="DatabaseClient$StatementCacheEntry" map="_A"/>
  <field class="DatabaseClient$StatementCacheEntry" name="statement" map="A"/>
  <field class="DatabaseClient$StatementCacheEntry" name="whenUsed" map="B"/>
  <method class="DatabaseClient$StatementCacheEntry" name="net.sf.jsqlparser.statement.Statement access$802(DatabaseClient$StatementCacheEntry, net.sf.jsqlparser.statement.Statement)" map="A"/>
  <method class="DatabaseClient$StatementCacheEntry" name="net.sf.jsqlparser.statement.Statement access$800(DatabaseClient$StatementCacheEntry)" map="A"/>
  <method class="DatabaseClient$StatementCacheEntry" name="java.util.concurrent.atomic.AtomicLong access$900(DatabaseClient$StatementCacheEntry)" map="B"/>
  <class name="DatabaseClient$TransactionOperation" map="_B"/>
  <field class="DatabaseClient$TransactionOperation" name="parms" map="A"/>
  <field class="DatabaseClient$TransactionOperation" name="statement" map="B"/>
  <class name="DatabaseClient$FailedToInsertException" map="_C"/>
  <field class="DatabaseClient$FailedToInsertException" name="this$0" map="A"/>
  <class name="DatabaseClient$Server" map="_D"/>
  <field class="DatabaseClient$Server" name="dead" map="A"/>
  <field class="DatabaseClient$Server" name="socketClient" map="B"/>
  <field class="DatabaseClient$Server" name="hostPort" map="C"/>
  <method class="DatabaseClient$Server" name="boolean access$502(DatabaseClient$Server, boolean)" map="A"/>
  <method class="DatabaseClient$Server" name="DatabaseSocketClient access$600(DatabaseClient$Server)" map="A"/>
  <method class="DatabaseClient$Server" name="byte[] do_send(java.lang.String, java.lang.String, byte[])" map="A"/>
  <method class="DatabaseClient$Server" name="byte[] do_send(java.lang.String, java.lang.String, ComObject)" map="A"/>
  <method class="DatabaseClient$Server" name="DatabaseSocketClient getSocketClient()" map="A"/>
  <method class="DatabaseClient$Server" name="boolean access$500(DatabaseClient$Server)" map="B"/>
  <method class="DatabaseClient$Server" name="java.lang.String access$000(DatabaseClient$Server)" map="C"/>
  <class name="DatabaseClient$InsertRequest" map="_E"/>
  <field class="DatabaseClient$InsertRequest" name="this$0" map="A"/>
  <field class="DatabaseClient$InsertRequest" name="parms" map="B"/>
  <field class="DatabaseClient$InsertRequest" name="dbName" map="C"/>
  <field class="DatabaseClient$InsertRequest" name="insertStatement" map="D"/>
  <method class="DatabaseClient$InsertRequest" name="java.lang.String access$102(DatabaseClient$InsertRequest, java.lang.String)" map="A"/>
  <method class="DatabaseClient$InsertRequest" name="InsertStatementImpl access$1400(DatabaseClient$InsertRequest)" map="A"/>
  <method class="DatabaseClient$InsertRequest" name="java.lang.String access$100(DatabaseClient$InsertRequest)" map="B"/>
  <method class="DatabaseClient$InsertRequest" name="ParameterHandler access$1502(DatabaseClient$InsertRequest, ParameterHandler)" map="A"/>
  <method class="DatabaseClient$InsertRequest" name="InsertStatementImpl access$1402(DatabaseClient$InsertRequest, InsertStatementImpl)" map="A"/>
  <class name="DatabaseClient$PreparedInsert" map="_F"/>
  <field class="DatabaseClient$PreparedInsert" name="keyInfo" map="A"/>
  <field class="DatabaseClient$PreparedInsert" name="id" map="B"/>
  <field class="DatabaseClient$PreparedInsert" name="primaryKeyIndexName" map="C"/>
  <field class="DatabaseClient$PreparedInsert" name="record" map="D"/>
  <field class="DatabaseClient$PreparedInsert" name="this$0" map="E"/>
  <field class="DatabaseClient$PreparedInsert" name="dbName" map="F"/>
  <field class="DatabaseClient$PreparedInsert" name="columnNames" map="G"/>
  <field class="DatabaseClient$PreparedInsert" name="tableName" map="H"/>
  <field class="DatabaseClient$PreparedInsert" name="primaryKey" map="I"/>
  <field class="DatabaseClient$PreparedInsert" name="indexName" map="J"/>
  <field class="DatabaseClient$PreparedInsert" name="values" map="K"/>
  <field class="DatabaseClient$PreparedInsert" name="tableSchema" map="L"/>
  <class name="DatabaseClient$Entry" map="_G"/>
  <field class="DatabaseClient$Entry" name="this$0" map="A"/>
  <field class="DatabaseClient$Entry" name="result" map="B"/>
  <field class="DatabaseClient$Entry" name="index" map="C"/>
  <field class="DatabaseClient$Entry" name="table" map="D"/>
  <field class="DatabaseClient$Entry" name="shard" map="E"/>
  <method class="DatabaseClient$Entry" name="java.lang.String access$1200(DatabaseClient$Entry)" map="A"/>
  <method class="DatabaseClient$Entry" name="java.lang.String access$1100(DatabaseClient$Entry)" map="B"/>
  <method class="DatabaseClient$Entry" name="java.lang.String getKey()" map="A"/>
  <class name="DatabaseClient$6" map="6"/>
  <field class="DatabaseClient$6" name="$SwitchMap$com$sonicbase$schema$DataType$Type" map="A"/>
  <class name="DatabaseClient$5" map="5"/>
  <field class="DatabaseClient$5" name="this$0" map="A"/>
  <field class="DatabaseClient$5" name="val$keyInfo" map="B"/>
  <method class="DatabaseClient$5" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="DatabaseClient$5" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DatabaseClient$4" map="4"/>
  <field class="DatabaseClient$4" name="this$0" map="A"/>
  <field class="DatabaseClient$4" name="val$shard" map="B"/>
  <field class="DatabaseClient$4" name="val$replica" map="C"/>
  <method class="DatabaseClient$4" name="java.util.Map call()" map="A"/>
  <method class="DatabaseClient$4" name="java.lang.Object call()" map="call"/>
  <class name="DatabaseClient$KeyInfo" map="_H"/>
  <field class="DatabaseClient$KeyInfo" name="currAndLastMatch" map="A"/>
  <field class="DatabaseClient$KeyInfo" name="key" map="B"/>
  <field class="DatabaseClient$KeyInfo" name="indexSchema" map="C"/>
  <field class="DatabaseClient$KeyInfo" name="currPartition" map="D"/>
  <field class="DatabaseClient$KeyInfo" name="shard" map="E"/>
  <method class="DatabaseClient$KeyInfo" name="java.lang.Object[] access$1302(DatabaseClient$KeyInfo, java.lang.Object[])" map="A"/>
  <method class="DatabaseClient$KeyInfo" name="java.util.Map$Entry access$200(DatabaseClient$KeyInfo)" map="A"/>
  <method class="DatabaseClient$KeyInfo" name="int getShard()" map="A"/>
  <method class="DatabaseClient$KeyInfo" name="void setIndexSchema(java.util.Map$Entry)" map="A"/>
  <method class="DatabaseClient$KeyInfo" name="int access$300(DatabaseClient$KeyInfo)" map="B"/>
  <method class="DatabaseClient$KeyInfo" name="void setKey(java.lang.Object[])" map="A"/>
  <method class="DatabaseClient$KeyInfo" name="int access$302(DatabaseClient$KeyInfo, int)" map="A"/>
  <method class="DatabaseClient$KeyInfo" name="boolean isCurrPartition()" map="B"/>
  <method class="DatabaseClient$KeyInfo" name="java.util.Map$Entry access$202(DatabaseClient$KeyInfo, java.util.Map$Entry)" map="A"/>
  <method class="DatabaseClient$KeyInfo" name="java.lang.Object[] access$1300(DatabaseClient$KeyInfo)" map="C"/>
  <method class="DatabaseClient$KeyInfo" name="java.lang.Object[] getKey()" map="C"/>
  <method class="DatabaseClient$KeyInfo" name="java.util.Map$Entry getIndexSchema()" map="D"/>
  <class name="DatabaseClient$3" map="3"/>
  <field class="DatabaseClient$3" name="this$0" map="A"/>
  <field class="DatabaseClient$3" name="val$batchKey" map="B"/>
  <field class="DatabaseClient$3" name="val$auth_user" map="C"/>
  <field class="DatabaseClient$3" name="val$shard" map="D"/>
  <field class="DatabaseClient$3" name="val$ignoreDeath" map="E"/>
  <field class="DatabaseClient$3" name="val$replica" map="F"/>
  <field class="DatabaseClient$3" name="val$command" map="G"/>
  <field class="DatabaseClient$3" name="val$body" map="H"/>
  <method class="DatabaseClient$3" name="byte[] call()" map="A"/>
  <method class="DatabaseClient$3" name="java.lang.Object call()" map="call"/>
  <class name="DatabaseClient$Replica" map="_I"/>
  <field class="DatabaseClient$Replica" name="secondary" map="A"/>
  <field class="DatabaseClient$Replica" name="$VALUES" map="B"/>
  <field class="DatabaseClient$Replica" name="all" map="C"/>
  <field class="DatabaseClient$Replica" name="primary" map="D"/>
  <field class="DatabaseClient$Replica" name="master" map="E"/>
  <field class="DatabaseClient$Replica" name="specified" map="F"/>
  <field class="DatabaseClient$Replica" name="def" map="G"/>
  <method class="DatabaseClient$Replica" name="DatabaseClient$Replica[] values()" map="values"/>
  <method class="DatabaseClient$Replica" name="DatabaseClient$Replica valueOf(java.lang.String)" map="valueOf"/>
  <class name="DatabaseClient$2" map="2"/>
  <field class="DatabaseClient$2" name="this$0" map="A"/>
  <field class="DatabaseClient$2" name="val$cobjs2" map="B"/>
  <field class="DatabaseClient$2" name="val$offset" map="C"/>
  <field class="DatabaseClient$2" name="val$prepared" map="D"/>
  <field class="DatabaseClient$2" name="val$processed" map="E"/>
  <method class="DatabaseClient$2" name="java.lang.Object call()" map="call"/>
  <class name="DatabaseClient$1" map="1"/>
  <field class="DatabaseClient$1" name="this$0" map="A"/>
  <field class="DatabaseClient$1" name="val$offset" map="B"/>
  <field class="DatabaseClient$1" name="val$cobjs1" map="C"/>
  <field class="DatabaseClient$1" name="val$withRecordProcessed" map="D"/>
  <field class="DatabaseClient$1" name="val$mutex" map="E"/>
  <field class="DatabaseClient$1" name="val$totalCount" map="F"/>
  <field class="DatabaseClient$1" name="val$withRecordPrepared" map="G"/>
  <method class="DatabaseClient$1" name="java.lang.Object call()" map="call"/>
  <class name="DatabaseClient$SocketException" map="_J"/>
  <class name="DatabaseClient" map="A"/>
  <field class="DatabaseClient" name="transactionOps" map="A"/>
  <field class="DatabaseClient" name="executor" map="B"/>
  <field class="DatabaseClient" name="isExplicitTrans" map="C"/>
  <field class="DatabaseClient" name="write_verbs_array" map="D"/>
  <field class="DatabaseClient" name="addedRecords" map="E"/>
  <field class="DatabaseClient" name="nextRecordId" map="F"/>
  <field class="DatabaseClient" name="write_verbs" map="G"/>
  <field class="DatabaseClient" name="isCommitting" map="H"/>
  <field class="DatabaseClient" name="METRICS" map="I"/>
  <field class="DatabaseClient" name="writeVerbs" map="J"/>
  <field class="DatabaseClient" name="tableSchema" map="K"/>
  <field class="DatabaseClient" name="maxAllocatedId" map="L"/>
  <field class="DatabaseClient" name="common" map="M"/>
  <field class="DatabaseClient" name="nextId" map="N"/>
  <field class="DatabaseClient" name="batch" map="O"/>
  <field class="DatabaseClient" name="servers" map="P"/>
  <field class="DatabaseClient" name="JOIN_EVALUATE" map="Q"/>
  <field class="DatabaseClient" name="statsTimer" map="R"/>
  <field class="DatabaseClient" name="INDEX_LOOKUP_STATS" map="S"/>
  <field class="DatabaseClient" name="isClient" map="T"/>
  <field class="DatabaseClient" name="localLogger" map="U"/>
  <field class="DatabaseClient" name="idAllocatorLock" map="V"/>
  <field class="DatabaseClient" name="BATCH_INDEX_LOOKUP_STATS" map="W"/>
  <field class="DatabaseClient" name="transactionId" map="X"/>
  <field class="DatabaseClient" name="statementCache" map="Y"/>
  <field class="DatabaseClient" name="pageSize" map="Z"/>
  <field class="DatabaseClient" name="rand" map="_"/>
  <field class="DatabaseClient" name="lastGotSchema" map="a"/>
  <field class="DatabaseClient" name="logger" map="b"/>
  <method class="DatabaseClient" name="java.lang.StringBuilder doDescribeIndex(java.lang.String, java.lang.String, java.lang.String, java.lang.StringBuilder)" map="A"/>
  <method class="DatabaseClient" name="java.lang.String debugRecord(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="DatabaseClient" name="java.util.concurrent.ThreadPoolExecutor getExecutor()" map="A"/>
  <method class="DatabaseClient" name="ResultSet describeSchemaVersion(java.lang.String)" map="A"/>
  <method class="DatabaseClient" name="int doInsert(java.lang.String, InsertStatementImpl, ParameterHandler)" map="A"/>
  <method class="DatabaseClient" name="void beginExplicitTransaction(java.lang.String)" map="B"/>
  <method class="DatabaseClient" name="java.util.Set getWrite_verbs()" map="B"/>
  <method class="DatabaseClient" name="void startRestore(java.lang.String)" map="C"/>
  <method class="DatabaseClient" name="InsertStatement createInsertStatement()" map="C"/>
  <method class="DatabaseClient" name="void setCommon(DatabaseCommon)" map="A"/>
  <method class="DatabaseClient" name="java.lang.Object doAlter(java.lang.String, ParameterHandler, net.sf.jsqlparser.statement.alter.Alter)" map="A"/>
  <method class="DatabaseClient" name="void doCreateIndex(java.lang.String, CreateIndexStatementImpl)" map="A"/>
  <method class="DatabaseClient" name="byte[] do_send(java.util.List)" map="A"/>
  <method class="DatabaseClient" name="ResultSet describeServerHeath(java.lang.String)" map="D"/>
  <method class="DatabaseClient" name="void syncSchema()" map="D"/>
  <method class="DatabaseClient" name="ResultSetImpl describeServerStats(java.lang.String)" map="E"/>
  <method class="DatabaseClient" name="ResultSet describeLicenses()" map="E"/>
  <method class="DatabaseClient" name="int getShardCount()" map="F"/>
  <method class="DatabaseClient" name="boolean isBackupComplete()" map="G"/>
  <method class="DatabaseClient" name="boolean isRestoreComplete()" map="H"/>
  <method class="DatabaseClient" name="byte[] send(java.lang.String, DatabaseClient$Server[], int, long, java.lang.String, ComObject, DatabaseClient$Replica)" map="A"/>
  <method class="DatabaseClient" name="ComObject serializeInsertKeyWithRecord(java.lang.String, java.lang.String, DatabaseClient$KeyInfo, Record)" map="A"/>
  <method class="DatabaseClient" name="void insertKey(java.lang.String, java.lang.String, DatabaseClient$KeyInfo, java.lang.String, java.lang.Object[])" map="A"/>
  <method class="DatabaseClient" name="void rollback(java.lang.String)" map="F"/>
  <method class="DatabaseClient" name="long getPartitionSize(java.lang.String, int, java.lang.String, java.lang.String)" map="A"/>
  <method class="DatabaseClient" name="java.lang.Object executeQuery(java.lang.String, QueryType, java.lang.String, ParameterHandler)" map="A"/>
  <method class="DatabaseClient" name="void syncConfig()" map="I"/>
  <method class="DatabaseClient" name="Record prepareRecordForInsert(InsertStatementImpl, TableSchema, long)" map="A"/>
  <method class="DatabaseClient" name="ResultSet describeShards(java.lang.String)" map="G"/>
  <method class="DatabaseClient" name="int doCreateTable(java.lang.String, net.sf.jsqlparser.statement.create.table.CreateTable)" map="A"/>
  <method class="DatabaseClient" name="boolean isRepartitioningComplete(java.lang.String)" map="H"/>
  <method class="DatabaseClient" name="void appendChars(java.lang.StringBuilder, java.lang.String, int)" map="A"/>
  <method class="DatabaseClient" name="java.lang.Object doUpdate(java.lang.String, ParameterHandler, net.sf.jsqlparser.statement.update.Update)" map="A"/>
  <method class="DatabaseClient" name="java.util.Set getWriteVerbs()" map="J"/>
  <method class="DatabaseClient" name="void doAddColumn(java.lang.String, java.lang.String, java.lang.String, net.sf.jsqlparser.statement.create.table.ColDataType)" map="A"/>
  <method class="DatabaseClient" name="java.lang.String getCluster()" map="K"/>
  <method class="DatabaseClient" name="java.lang.Object doTruncateTable(java.lang.String, net.sf.jsqlparser.statement.truncate.Truncate)" map="A"/>
  <method class="DatabaseClient" name="byte[][] sendToAllShards(java.lang.String, long, java.lang.String, ComObject, DatabaseClient$Replica, boolean)" map="A"/>
  <method class="DatabaseClient" name="java.lang.Object executeQuery(java.lang.String, QueryType, java.lang.String, ParameterHandler, boolean)" map="A"/>
  <method class="DatabaseClient" name="void initDb(java.lang.String)" map="I"/>
  <method class="DatabaseClient" name="DatabaseCommon access$1000(DatabaseClient)" map="A"/>
  <method class="DatabaseClient" name="void beginRebalance(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="DatabaseClient" name="void deleteKey(java.lang.String, java.lang.String, DatabaseClient$KeyInfo, java.lang.String, java.lang.Object[])" map="B"/>
  <method class="DatabaseClient" name="long getPartitionSize(java.lang.String, int, int, java.lang.String, java.lang.String)" map="A"/>
  <method class="DatabaseClient" name="CreateTableStatement createCreateTableStatement()" map="L"/>
  <method class="DatabaseClient" name="com.google.api.client.http.HttpResponse restGet(java.lang.String)" map="J"/>
  <method class="DatabaseClient" name="int getPageSize()" map="M"/>
  <method class="DatabaseClient" name="int doCreateTable(java.lang.String, CreateTableStatementImpl)" map="A"/>
  <method class="DatabaseClient" name="void configureServers()" map="N"/>
  <method class="DatabaseClient" name="ResultSet doDescribe(java.lang.String, java.lang.String)" map="A"/>
  <method class="DatabaseClient" name="long allocateId(java.lang.String)" map="K"/>
  <method class="DatabaseClient" name="DatabaseCommon getCommon()" map="O"/>
  <method class="DatabaseClient" name="java.lang.Object doExplain(java.lang.String, java.lang.String, ParameterHandler)" map="A"/>
  <method class="DatabaseClient" name="void commit(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <method class="DatabaseClient" name="CreateIndexStatement createCreateIndexStatement()" map="P"/>
  <method class="DatabaseClient" name="Schema getSchema(java.lang.String)" map="L"/>
  <method class="DatabaseClient" name="ComObject serializeInsertKey(java.lang.String, java.lang.String, DatabaseClient$KeyInfo, java.lang.String, java.lang.Object[])" map="C"/>
  <method class="DatabaseClient" name="com.sonicbase.server.DatabaseServer getLocalDbServer(int, int)" map="A"/>
  <method class="DatabaseClient" name="java.lang.Object doDrop(java.lang.String, net.sf.jsqlparser.statement.Statement)" map="A"/>
  <method class="DatabaseClient" name="void createDatabase(java.lang.String)" map="M"/>
  <method class="DatabaseClient" name="SelectStatement createSelectStatement()" map="Q"/>
  <method class="DatabaseClient" name="byte[] sendToMaster(java.lang.String, ComObject)" map="A"/>
  <method class="DatabaseClient" name="byte[] send(java.lang.String, int, long, java.lang.String, ComObject, DatabaseClient$Replica)" map="A"/>
  <method class="DatabaseClient" name="int[] executeBatch()" map="R"/>
  <method class="DatabaseClient" name="java.lang.Object doSelect(java.lang.String, ParameterHandler, net.sf.jsqlparser.statement.select.Select, boolean, SelectStatementImpl$Explain)" map="A"/>
  <method class="DatabaseClient" name="byte[][] sendToAllShards(java.lang.String, long, java.lang.String, ComObject, DatabaseClient$Replica)" map="A"/>
  <method class="DatabaseClient" name="boolean isExplicitTrans()" map="S"/>
  <method class="DatabaseClient" name="byte[] send(java.lang.String, int, long, java.lang.String, ComObject, DatabaseClient$Replica, boolean)" map="A"/>
  <method class="DatabaseClient" name="int doInsert(java.lang.String, ParameterHandler, net.sf.jsqlparser.statement.insert.Insert)" map="A"/>
  <method class="DatabaseClient" name="UpdateStatement createUpdateStatement()" map="T"/>
  <method class="DatabaseClient" name="long getTransactionId()" map="U"/>
  <method class="DatabaseClient" name="byte[] send(java.lang.String, DatabaseClient$Server[], int, long, java.lang.String, ComObject, DatabaseClient$Replica, boolean)" map="A"/>
  <method class="DatabaseClient" name="void setPageSize(int)" map="A"/>
  <method class="DatabaseClient" name="java.lang.String[] getWrite_verbs_array()" map="V"/>
  <method class="DatabaseClient" name="void insertKeyWithRecord(java.lang.String, java.lang.String, DatabaseClient$KeyInfo, Record)" map="B"/>
  <method class="DatabaseClient" name="void handleDeadServer(java.lang.Throwable, DatabaseClient$Server)" map="A"/>
  <method class="DatabaseClient" name="boolean isCommitting()" map="W"/>
  <method class="DatabaseClient" name="java.util.List prepareInsert(DatabaseClient$InsertRequest, long)" map="A"/>
  <method class="DatabaseClient" name="java.util.List getKeys(TableSchema, java.util.List, java.util.List, long)" map="A"/>
  <method class="DatabaseClient" name="int selectShard(long)" map="A"/>
  <method class="DatabaseClient" name="java.util.Random access$400(DatabaseClient)" map="B"/>
  <method class="DatabaseClient" name="int getReplicaCount()" map="X"/>
  <method class="DatabaseClient" name="ExpressionImpl getExpression(java.util.concurrent.atomic.AtomicInteger, net.sf.jsqlparser.expression.Expression, java.lang.String, ParameterHandler)" map="A"/>
  <method class="DatabaseClient" name="void populateOrderedKeyInfo(java.util.Map, java.util.List)" map="A"/>
  <method class="DatabaseClient" name="java.lang.Object doDelete(java.lang.String, ParameterHandler, net.sf.jsqlparser.statement.delete.Delete)" map="A"/>
  <method class="DatabaseClient" name="byte[] checkAddedRecords(java.lang.String, byte[])" map="A"/>
  <method class="DatabaseClient" name="void getConfig()" map="Y"/>
  <method class="DatabaseClient" name="ReconfigureResults reconfigureCluster()" map="Z"/>
  <method class="DatabaseClient" name="void startBackup()" map="_"/>
  <method class="DatabaseClient" name="java.lang.Object doCreateIndex(java.lang.String, net.sf.jsqlparser.statement.create.index.CreateIndex)" map="A"/>
  <method class="DatabaseClient" name="void doDropColumn(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="DatabaseClient" name="void doTruncateTable(java.lang.String, java.lang.String)" map="B"/>
  <method class="DatabaseClient" name="java.lang.String handleSchemaOutOfSyncException(java.lang.String, java.lang.Exception)" map="A"/>
  <method class="DatabaseClient" name="void shutdown()" map="a"/>
  <method class="DatabaseClient" name="void doDescribeOneIndex(TableSchema, IndexSchema, java.lang.StringBuilder)" map="A"/>
  <field class="ReconfigureResults" name="shardCount" map="A"/>
  <field class="ReconfigureResults" name="handedOffToMaster" map="B"/>
  <class name="com.sonicbase.server.DatabaseServer$Shard" map="_A"/>
  <field class="com.sonicbase.server.DatabaseServer$Shard" name="replicas" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$Shard" name="masterReplica" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$Shard" name="boolean contains(java.lang.String, int)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Shard" name="com.sonicbase.server.DatabaseServer$Host[] access$3900(com.sonicbase.server.DatabaseServer$Shard)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Shard" name="void serialize(java.io.DataOutputStream, long)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Shard" name="com.sonicbase.server.DatabaseServer$Host[] getReplicas()" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Shard" name="int getMasterReplica()" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$Shard" name="void setMasterReplica(int)" map="A"/>
  <class name="com.sonicbase.server.DatabaseServer$Response" map="_B"/>
  <field class="com.sonicbase.server.DatabaseServer$Response" name="bytes" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$Response" name="exception" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$Response" name="java.lang.Exception getException()" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Response" name="byte[] getBytes()" map="B"/>
  <class name="com.sonicbase.server.DatabaseServer$LogRequest" map="_C"/>
  <field class="com.sonicbase.server.DatabaseServer$LogRequest" name="buffers" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$LogRequest" name="buffer" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$LogRequest" name="latch" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$LogRequest" name="times" map="D"/>
  <field class="com.sonicbase.server.DatabaseServer$LogRequest" name="sequenceNumbers" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="void setBuffers(java.util.List)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="void setLatch(java.util.concurrent.CountDownLatch)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="byte[] getBuffer()" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="long[] getSequences1()" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="long[] getSequences0()" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="java.util.concurrent.CountDownLatch getLatch()" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="java.util.List getBuffers()" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="void setBuffer(byte[])" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$LogRequest" name="java.util.concurrent.CountDownLatch access$5000(com.sonicbase.server.DatabaseServer$LogRequest)" map="A"/>
  <class name="com.sonicbase.server.DatabaseServer$OSStats" map="_D"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="javaMemMin" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="resGig" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="diskAvail" map="D"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="avgRecRate" map="E"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="avgTransRate" map="F"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="cpu" map="G"/>
  <field class="com.sonicbase.server.DatabaseServer$OSStats" name="javaMemMax" map="H"/>
  <class name="com.sonicbase.server.DatabaseServer$Entry" map="_E"/>
  <field class="com.sonicbase.server.DatabaseServer$Entry" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$Entry" name="key" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$Entry" name="latch" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$Entry" name="id" map="D"/>
  <class name="com.sonicbase.server.DatabaseServer$15" map="15"/>
  <field class="com.sonicbase.server.DatabaseServer$15" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$15" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$NullX509TrustManager" map="_F"/>
  <method class="com.sonicbase.server.DatabaseServer$NullX509TrustManager" name="void checkServerTrusted(java.security.cert.X509Certificate[], java.lang.String)" map="checkServerTrusted"/>
  <method class="com.sonicbase.server.DatabaseServer$NullX509TrustManager" name="void checkClientTrusted(java.security.cert.X509Certificate[], java.lang.String)" map="checkClientTrusted"/>
  <method class="com.sonicbase.server.DatabaseServer$NullX509TrustManager" name="java.security.cert.X509Certificate[] getAcceptedIssuers()" map="getAcceptedIssuers"/>
  <class name="com.sonicbase.server.DatabaseServer$14" map="14"/>
  <field class="com.sonicbase.server.DatabaseServer$14" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$14" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$13" map="13"/>
  <field class="com.sonicbase.server.DatabaseServer$13" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$13" name="val$cobj" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$13" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$NetMonitor" map="_G"/>
  <field class="com.sonicbase.server.DatabaseServer$NetMonitor" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$NetMonitor" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$12" map="12"/>
  <field class="com.sonicbase.server.DatabaseServer$12" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$12" name="val$cobj" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$12" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$11" map="11"/>
  <field class="com.sonicbase.server.DatabaseServer$11" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$11" name="val$cobj" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$11" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$StatsMonitor" map="_H"/>
  <field class="com.sonicbase.server.DatabaseServer$StatsMonitor" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$StatsMonitor" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$10" map="10"/>
  <field class="com.sonicbase.server.DatabaseServer$10" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$10" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="com.sonicbase.server.DatabaseServer$10" name="int compare(java.lang.String, java.lang.String)" map="A"/>
  <class name="com.sonicbase.server.DatabaseServer$NullHostnameVerifier" map="_I"/>
  <method class="com.sonicbase.server.DatabaseServer$NullHostnameVerifier" name="boolean verify(java.lang.String, javax.net.ssl.SSLSession)" map="verify"/>
  <class name="com.sonicbase.server.DatabaseServer$ServersConfig" map="_J"/>
  <field class="com.sonicbase.server.DatabaseServer$ServersConfig" name="cluster" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$ServersConfig" name="shards" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$ServersConfig" name="clientIsInternal" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="int getThisShard(java.lang.String, int)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="int getThisReplica(java.lang.String, int)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="boolean clientIsInternal()" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="com.sonicbase.server.DatabaseServer$Shard[] getShards()" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="void serialize(java.io.DataOutputStream, long)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="byte[] serialize(long)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="java.lang.String getCluster()" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer$ServersConfig" name="int getShardCount()" map="D"/>
  <class name="com.sonicbase.server.DatabaseServer$ResultType" map="_K"/>
  <field class="com.sonicbase.server.DatabaseServer$ResultType" name="bool" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$ResultType" name="records" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$ResultType" name="integer" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$ResultType" name="$VALUES" map="D"/>
  <field class="com.sonicbase.server.DatabaseServer$ResultType" name="type" map="E"/>
  <field class="com.sonicbase.server.DatabaseServer$ResultType" name="schema" map="F"/>
  <method class="com.sonicbase.server.DatabaseServer$ResultType" name="int getType()" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$ResultType" name="com.sonicbase.server.DatabaseServer$ResultType valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.sonicbase.server.DatabaseServer$ResultType" name="com.sonicbase.server.DatabaseServer$ResultType[] values()" map="values"/>
  <class name="com.sonicbase.server.DatabaseServer$9" map="9"/>
  <field class="com.sonicbase.server.DatabaseServer$9" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$9" name="val$wasDoingBackup" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$9" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$8" map="8"/>
  <field class="com.sonicbase.server.DatabaseServer$8" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$8" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="com.sonicbase.server.DatabaseServer$8" name="int compare(java.io.File, java.io.File)" map="A"/>
  <class name="com.sonicbase.server.DatabaseServer$Host" map="_L"/>
  <field class="com.sonicbase.server.DatabaseServer$Host" name="publicAddress" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$Host" name="port" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$Host" name="privateAddress" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$Host" name="dead" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="java.lang.String getPublicAddress()" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="boolean access$1002(com.sonicbase.server.DatabaseServer$Host, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="boolean access$1000(com.sonicbase.server.DatabaseServer$Host)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="void setDead(boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="void serialize(java.io.DataOutputStream, long)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="java.lang.String access$3700(com.sonicbase.server.DatabaseServer$Host)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="java.lang.String getPrivateAddress()" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="boolean isDead()" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="int getPort()" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer$Host" name="int access$3800(com.sonicbase.server.DatabaseServer$Host)" map="C"/>
  <class name="com.sonicbase.server.DatabaseServer$7" map="7"/>
  <field class="com.sonicbase.server.DatabaseServer$7" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$7" name="val$cobj" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$7" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$6" map="6"/>
  <field class="com.sonicbase.server.DatabaseServer$6" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$6" name="val$cobj" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer$6" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$5" map="5"/>
  <field class="com.sonicbase.server.DatabaseServer$5" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$5" name="val$address" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$5" name="val$haventSet" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$5" name="val$lastHaveProLicense" map="D"/>
  <field class="com.sonicbase.server.DatabaseServer$5" name="val$licensePort" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer$5" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$4" map="4"/>
  <field class="com.sonicbase.server.DatabaseServer$4" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$4" name="val$isHealthy" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$4" name="val$finished" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$4" name="val$shard" map="D"/>
  <field class="com.sonicbase.server.DatabaseServer$4" name="val$replica" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer$4" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$BackupJob" map="_M"/>
  <method class="com.sonicbase.server.DatabaseServer$BackupJob" name="void execute(org.quartz.JobExecutionContext)" map="execute"/>
  <class name="com.sonicbase.server.DatabaseServer$3" map="3"/>
  <field class="com.sonicbase.server.DatabaseServer$3" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$3" name="val$shard" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$3" name="val$replica" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer$3" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$2" map="2"/>
  <field class="com.sonicbase.server.DatabaseServer$2" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$2" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$1$1" map="1"/>
  <field class="com.sonicbase.server.DatabaseServer$1$1" name="val$monitorShards" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer$1$1" name="val$shard" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer$1$1" name="val$monitorReplicas" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer$1$1" name="this$1" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer$1$1" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer$1" map="1"/>
  <field class="com.sonicbase.server.DatabaseServer$1" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer$1" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DatabaseServer" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer" name="shutdownDeathMonitor" map="A"/>
  <field class="com.sonicbase.server.DatabaseServer" name="schemaManager" map="B"/>
  <field class="com.sonicbase.server.DatabaseServer" name="isServerRoloadRunning" map="C"/>
  <field class="com.sonicbase.server.DatabaseServer" name="transactionManager" map="D"/>
  <field class="com.sonicbase.server.DatabaseServer" name="FOUR_SERVER_LICENSE" map="E"/>
  <field class="com.sonicbase.server.DatabaseServer" name="deleteManagerImpl" map="F"/>
  <field class="com.sonicbase.server.DatabaseServer" name="batchReadLock" map="G"/>
  <field class="com.sonicbase.server.DatabaseServer" name="doingBackup" map="H"/>
  <field class="com.sonicbase.server.DatabaseServer" name="restoreAwsMutex" map="I"/>
  <field class="com.sonicbase.server.DatabaseServer" name="bytes" map="J"/>
  <field class="com.sonicbase.server.DatabaseServer" name="throttleInsert" map="K"/>
  <field class="com.sonicbase.server.DatabaseServer" name="dead" map="L"/>
  <field class="com.sonicbase.server.DatabaseServer" name="logManager" map="M"/>
  <field class="com.sonicbase.server.DatabaseServer" name="client" map="N"/>
  <field class="com.sonicbase.server.DatabaseServer" name="shardCount" map="O"/>
  <field class="com.sonicbase.server.DatabaseServer" name="deathMonitorMutex" map="P"/>
  <field class="com.sonicbase.server.DatabaseServer" name="dataDir" map="Q"/>
  <field class="com.sonicbase.server.DatabaseServer" name="nextRecordId" map="R"/>
  <field class="com.sonicbase.server.DatabaseServer" name="nextIdLock" map="S"/>
  <field class="com.sonicbase.server.DatabaseServer" name="batchLock" map="T"/>
  <field class="com.sonicbase.server.DatabaseServer" name="gclog" map="U"/>
  <field class="com.sonicbase.server.DatabaseServer" name="recordsByIdPartitionCount" map="V"/>
  <field class="com.sonicbase.server.DatabaseServer" name="replica" map="W"/>
  <field class="com.sonicbase.server.DatabaseServer" name="ENABLE_RECORD_COMPRESSION" map="X"/>
  <field class="com.sonicbase.server.DatabaseServer" name="backupException" map="Y"/>
  <field class="com.sonicbase.server.DatabaseServer" name="usingMultipleReplicas" map="Z"/>
  <field class="com.sonicbase.server.DatabaseServer" name="masterAddress" map="_"/>
  <field class="com.sonicbase.server.DatabaseServer" name="port" map="a"/>
  <field class="com.sonicbase.server.DatabaseServer" name="common" map="b"/>
  <field class="com.sonicbase.server.DatabaseServer" name="repartitioner" map="c"/>
  <field class="com.sonicbase.server.DatabaseServer" name="deathMonitorThreads" map="d"/>
  <field class="com.sonicbase.server.DatabaseServer" name="logger" map="e"/>
  <field class="com.sonicbase.server.DatabaseServer" name="unsafe" map="f"/>
  <field class="com.sonicbase.server.DatabaseServer" name="aboveMemoryThreshold" map="g"/>
  <field class="com.sonicbase.server.DatabaseServer" name="clientErrorLogger" map="h"/>
  <field class="com.sonicbase.server.DatabaseServer" name="role" map="i"/>
  <field class="com.sonicbase.server.DatabaseServer" name="errorLogger" map="j"/>
  <field class="com.sonicbase.server.DatabaseServer" name="updateManager" map="k"/>
  <field class="com.sonicbase.server.DatabaseServer" name="readManager" map="l"/>
  <field class="com.sonicbase.server.DatabaseServer" name="deathOverrideMutex" map="m"/>
  <field class="com.sonicbase.server.DatabaseServer" name="cluster" map="n"/>
  <field class="com.sonicbase.server.DatabaseServer" name="exception" map="o"/>
  <field class="com.sonicbase.server.DatabaseServer" name="indexes" map="p"/>
  <field class="com.sonicbase.server.DatabaseServer" name="cronIdentity" map="q"/>
  <field class="com.sonicbase.server.DatabaseServer" name="haveProLicense" map="r"/>
  <field class="com.sonicbase.server.DatabaseServer" name="backupConfig" map="s"/>
  <field class="com.sonicbase.server.DatabaseServer" name="finalBackupException" map="t"/>
  <field class="com.sonicbase.server.DatabaseServer" name="logSlicePoint" map="u"/>
  <field class="com.sonicbase.server.DatabaseServer" name="finalRestoreException" map="v"/>
  <field class="com.sonicbase.server.DatabaseServer" name="config" map="w"/>
  <field class="com.sonicbase.server.DatabaseServer" name="servers" map="x"/>
  <field class="com.sonicbase.server.DatabaseServer" name="isBackupComplete" map="y"/>
  <field class="com.sonicbase.server.DatabaseServer" name="replicationFactor" map="z"/>
  <field class="com.sonicbase.server.DatabaseServer" name="commandCount" map="&#x00a2;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="executor" map="&#x00a3;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="restoreException" map="&#x00a4;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="awsClient" map="&#x00a5;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="avgTransRate" map="&#x00aa;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="snapshotManager" map="&#x00b5;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="compressRecords" map="&#x00ba;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="overrideProLicense" map="&#x00c0;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="OS" map="&#x00c1;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="LICENSE_KEY" map="&#x00c2;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="debugServers" map="&#x00c3;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="batchWriteLock" map="&#x00c4;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="shutdown" map="&#x00c5;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="replicaDeadForRestart" map="&#x00c6;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="masterPort" map="&#x00c7;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="longRunningCommands" map="&#x00c8;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="commandHandler" map="&#x00c9;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="applyingQueuesAndInteractive" map="&#x00ca;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="onlyQueueCommands" map="&#x00cb;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="isRestoreComplete" map="&#x00cc;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="buffers" map="&#x00cd;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="installDir" map="&#x00ce;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="deathOverride" map="&#x00cf;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="doingRestore" map="&#x00d0;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="avgRecRate" map="&#x00d1;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="xmx" map="&#x00d2;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="pid" map="&#x00d3;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="algorithm" map="&#x00d4;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="disableNow" map="&#x00d5;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="useUnsafe" map="&#x00d6;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="deathReportThread" map="&#x00d8;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="isRunning" map="&#x00d9;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="host" map="&#x00da;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="batchRepartCount" map="&#x00db;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="shard" map="&#x00dc;"/>
  <field class="com.sonicbase.server.DatabaseServer" name="lastBackupDir" map="&#x00dd;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$2900(com.sonicbase.server.DatabaseServer)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int access$400(com.sonicbase.server.DatabaseServer)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="byte[] encryptF(java.lang.String, java.security.Key, javax.crypto.Cipher)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$4900(com.sonicbase.server.DatabaseServer, ComArray)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="DatabaseClient getClient()" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject promoteToMaster(ComObject)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String getDiskAvailWindows()" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Object toUnsafeFromKeys(byte[][])" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="byte[][] fromUnsafeToRecords(java.lang.Object)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.Map getIndices()" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$2000(com.sonicbase.server.DatabaseServer, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$500(com.sonicbase.server.DatabaseServer, int, int, int[], int[])" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isMac()" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject prepareForBackup(ComObject)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isThrottleInsert()" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void runSnapshot()" map="F"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.DatabaseServer$OSStats doGetOSStats()" map="G"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject allocateRecordIds(ComObject)" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String fixReplica(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int getShard()" map="H"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setRole(java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Object toUnsafeFromRecords(byte[][])" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean electNewMaster(int, int, int[], int[])" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject updateServersConfig(ComObject)" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$4500()" map="I"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$4100(com.sonicbase.server.DatabaseServer, java.lang.Double)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="double getCpuUtilizationWindows()" map="J"/>
  <method class="com.sonicbase.server.DatabaseServer" name="byte[][] fromUnsafeToKeys(java.lang.Object)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isUsingMultipleReplicas()" map="K"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setConfig(com.sonicbase.util.JsonDict, java.lang.String, java.lang.String, int, boolean, java.util.concurrent.atomic.AtomicBoolean, boolean, java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject isServerReloadFinished(ComObject)" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setShardCount(int)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.concurrent.atomic.AtomicBoolean getAboveMemoryThreshold()" map="L"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int access$1500(com.sonicbase.server.DatabaseServer)" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Double checkResidentMemory()" map="M"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int getRecordsByIdPartitionCount()" map="N"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject prepareForRestore(ComObject)" map="F"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.SnapshotManagerImpl access$2300(com.sonicbase.server.DatabaseServer)" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void startLicenseValidator()" map="O"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void syncDbNames()" map="P"/>
  <method class="com.sonicbase.server.DatabaseServer" name="long getCommandCount()" map="Q"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void doBackup()" map="R"/>
  <method class="com.sonicbase.server.DatabaseServer" name="byte[] handleCommand(java.lang.String, byte[], long, long, boolean, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="Logger access$600(com.sonicbase.server.DatabaseServer)" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isApplyingQueuesAndInteractive()" map="S"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean haveProLicense()" map="T"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean onlyQueueCommands()" map="U"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String getDiskAvailable()" map="V"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Boolean access$1702(com.sonicbase.server.DatabaseServer, java.lang.Boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="long getSchemaVersion()" map="W"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setMinSizeForRepartition(int)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int access$300(com.sonicbase.server.DatabaseServer)" map="F"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.SchemaManager getSchemaManager()" map="X"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$1100(com.sonicbase.server.DatabaseServer)" map="G"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.DeleteManagerImpl getDeleteManager()" map="Y"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$3000(com.sonicbase.server.DatabaseServer, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void backupAWSSingleDir(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject areAllLongRunningCommandsComplete(ComObject)" map="G"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void shutdownDeathMonitor()" map="Z"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject finishBackup(ComObject)" map="H"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setReplicaDeadForRestart(int)" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void disableLogProcessor()" map="_"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void disable()" map="a"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject isRestoreComplete(ComObject)" map="I"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$4200()" map="b"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String access$1400(com.sonicbase.server.DatabaseServer)" map="H"/>
  <method class="com.sonicbase.server.DatabaseServer" name="Record evaluateRecordForQuery(TableSchema, Record, ExpressionImpl, ParameterHandler)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isWindows()" map="c"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String getDataDir()" map="d"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void startDeathMonitor()" map="e"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$3600(com.sonicbase.server.DatabaseServer, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.LogManager access$2500(com.sonicbase.server.DatabaseServer)" map="I"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String decryptF(byte[], java.security.Key, javax.crypto.Cipher)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$2602(com.sonicbase.server.DatabaseServer, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.LongRunningCommands getLongRunningCommands()" map="f"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Exception access$2702(com.sonicbase.server.DatabaseServer, java.lang.Exception)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="org.apache.log4j.Logger getErrorLogger()" map="g"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.UpdateManager getUpdateManager()" map="h"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void restoreFileSystemSingleDir(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isIdInField(java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject startRestore(ComObject)" map="J"/>
  <method class="com.sonicbase.server.DatabaseServer" name="DatabaseCommon access$700(com.sonicbase.server.DatabaseServer)" map="J"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void initDeathOverride(int, int)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void getSchemaFromPossibleMaster()" map="i"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject reconfigureCluster(ComObject)" map="K"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Thread[][] getDeathMonitorThreads()" map="j"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$3100(com.sonicbase.server.DatabaseServer)" map="K"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void doRestore(java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject prepareSourceForServerReload(ComObject)" map="L"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String access$1800(com.sonicbase.server.DatabaseServer)" map="L"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void startRepartitioner()" map="k"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject doBackupAWS(ComObject)" map="M"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.common.AWSClient getAWSClient()" map="l"/>
  <method class="com.sonicbase.server.DatabaseServer" name="byte[] startBackup(ComObject)" map="N"/>
  <method class="com.sonicbase.server.DatabaseServer" name="DatabaseClient getDatabaseClient()" map="m"/>
  <method class="com.sonicbase.server.DatabaseServer" name="org.apache.log4j.Logger access$1900()" map="n"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.List dont_use_handleCommands(java.util.List, boolean, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Exception access$3302(com.sonicbase.server.DatabaseServer, java.lang.Exception)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void restoreAWSSingleDir(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void scheduleBackup()" map="o"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject getLastBackupDir(ComObject)" map="O"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.List getDbNames(java.lang.String)" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String access$4600(com.sonicbase.server.DatabaseServer)" map="M"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String getCluster()" map="p"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$2800(com.sonicbase.server.DatabaseServer, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject reserveNextIdFromReplica(ComObject)" map="P"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject isEntireBackupComplete(ComObject)" map="Q"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.common.AWSClient access$3500(com.sonicbase.server.DatabaseServer)" map="N"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock getBatchReadLock()" map="q"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int access$200(com.sonicbase.server.DatabaseServer)" map="O"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.util.JsonDict getConfig()" map="r"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject setMaxRecordId(ComObject)" map="R"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject doBackupFileSystem(ComObject)" map="S"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void initServersForUnitTest(java.lang.String, int, boolean, com.sonicbase.server.DatabaseServer$ServersConfig)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int access$900(com.sonicbase.server.DatabaseServer)" map="P"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String format8601(java.util.Date)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock getBatchWriteLock()" map="s"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$2902(com.sonicbase.server.DatabaseServer, boolean)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.LongRunningCommands access$2200(com.sonicbase.server.DatabaseServer)" map="Q"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setThrottleInsert(boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean shouldDisableNow()" map="t"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setConfig(com.sonicbase.util.JsonDict, java.lang.String, java.lang.String, int, java.util.concurrent.atomic.AtomicBoolean, java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$4700()" map="u"/>
  <method class="com.sonicbase.server.DatabaseServer" name="sun.misc.Unsafe getUnsafe()" map="v"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void enableSnapshot(boolean)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$1602(com.sonicbase.server.DatabaseServer, boolean)" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer" name="DatabaseClient$Replica getRole()" map="w"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void checkHealthOfServer(int, int, java.util.concurrent.atomic.AtomicBoolean, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void startMemoryMonitor()" map="x"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void prepareDataFromRestore()" map="y"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.Map getDebugServers()" map="z"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void pushSchema()" map="&#x00a2;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.Map getServers()" map="&#x00a3;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject promoteEntireReplicaToMaster(ComObject)" map="T"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject prepareToComeAlive(ComObject)" map="U"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void recoverFromSnapshot()" map="&#x00a4;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.Double access$4000(com.sonicbase.server.DatabaseServer)" map="R"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void getJavaMemStats(java.util.concurrent.atomic.AtomicReference, java.util.concurrent.atomic.AtomicReference)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void doDeleteAWSBackups(java.lang.String, java.lang.String, java.lang.Integer)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject pushMaxRecordId(ComObject)" map="V"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void startMasterMonitor()" map="&#x00a5;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setConfig(com.sonicbase.util.JsonDict, java.lang.String, java.lang.String, int, boolean, java.util.concurrent.atomic.AtomicBoolean, java.lang.String, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void overrideProLicense()" map="&#x00aa;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.TransactionManager getTransactionManager()" map="&#x00b5;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void freeUnsafeIds(java.lang.Object)" map="C"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isUnix()" map="&#x00ba;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void pushServersConfig()" map="&#x00c0;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int getTestWriteCallCount()" map="&#x00c1;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.LogManager getLogManager()" map="&#x00c2;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.index.Indices getIndices(java.lang.String)" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject isBackupComplete(ComObject)" map="W"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.concurrent.atomic.AtomicInteger getBatchRepartCount()" map="&#x00c3;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$3202(com.sonicbase.server.DatabaseServer, boolean)" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void validateLicense(com.sonicbase.util.JsonDict)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void shutdownRepartitioner()" map="&#x00c4;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject isEntireRestoreComplete(ComObject)" map="X"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.util.concurrent.ThreadPoolExecutor getExecutor()" map="&#x00c5;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void doDeleteFileSystemBackups(java.lang.String, int)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.index.Repartitioner getRepartitioner()" map="&#x00c6;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject getOSStats(ComObject)" map="Y"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$1600(com.sonicbase.server.DatabaseServer)" map="S"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject finishRestore(ComObject)" map="Z"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void checkJavaHeap(java.lang.Double)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void setBackupConfig(com.sonicbase.util.JsonDict)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="byte[] handleCommand(java.lang.String, byte[], boolean, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$3400(com.sonicbase.server.DatabaseServer, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="double access$4302(com.sonicbase.server.DatabaseServer, double)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void backupFileSystemSingleDir(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void purgeMemory()" map="&#x00c7;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.util.JsonDict access$100(com.sonicbase.server.DatabaseServer)" map="T"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject doRestoreFileSystem(ComObject)" map="_"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject getDatabaseFile(ComObject)" map="a"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String getInstallDir()" map="&#x00c8;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.SnapshotManagerImpl getSnapshotManager()" map="&#x00c9;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject reloadServer(ComObject)" map="b"/>
  <method class="com.sonicbase.server.DatabaseServer" name="double access$4402(com.sonicbase.server.DatabaseServer, double)" map="B"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int getReplicationFactor()" map="&#x00ca;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void pushMaxRecordId(java.lang.String, long)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isRunning()" map="&#x00cb;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="double getResGigWindows()" map="&#x00cc;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void startLongRunningCommands()" map="&#x00cd;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int getShardCount()" map="&#x00ce;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String access$2400(com.sonicbase.server.DatabaseServer)" map="U"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void purge(java.lang.String)" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void access$800(com.sonicbase.server.DatabaseServer, int, int, java.util.concurrent.atomic.AtomicBoolean, boolean)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="java.lang.String createLicense(int)" map="D"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject electNewMaster(ComObject)" map="c"/>
  <method class="com.sonicbase.server.DatabaseServer" name="ComObject doRestoreAWS(ComObject)" map="d"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean isNoLongerMaster()" map="&#x00cf;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="boolean access$4802(com.sonicbase.server.DatabaseServer, boolean)" map="E"/>
  <method class="com.sonicbase.server.DatabaseServer" name="com.sonicbase.server.DeleteManagerImpl access$2100(com.sonicbase.server.DatabaseServer)" map="V"/>
  <method class="com.sonicbase.server.DatabaseServer" name="DatabaseCommon getCommon()" map="&#x00d0;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="int getReplica()" map="&#x00d1;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void shutdown()" map="&#x00d2;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="org.apache.log4j.Logger getClientErrorLogger()" map="&#x00d3;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void downloadFilesForReload(ComArray)" map="A"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void replayLogs()" map="&#x00d4;"/>
  <method class="com.sonicbase.server.DatabaseServer" name="void truncateTablesQuietly()" map="&#x00d5;"/>
  <class name="com.sonicbase.server.SchemaManager$AutoIncrementValue" map="_A"/>
  <field class="com.sonicbase.server.SchemaManager$AutoIncrementValue" name="dataType" map="A"/>
  <field class="com.sonicbase.server.SchemaManager$AutoIncrementValue" name="currValue" map="B"/>
  <field class="com.sonicbase.server.SchemaManager$AutoIncrementValue" name="mutex" map="C"/>
  <method class="com.sonicbase.server.SchemaManager$AutoIncrementValue" name="java.lang.Object increment()" map="A"/>
  <method class="com.sonicbase.server.SchemaManager$AutoIncrementValue" name="void setInitialValue()" map="B"/>
  <class name="com.sonicbase.server.SchemaManager" map="B"/>
  <field class="com.sonicbase.server.SchemaManager" name="autoIncrementValues" map="A"/>
  <field class="com.sonicbase.server.SchemaManager" name="logger" map="B"/>
  <field class="com.sonicbase.server.SchemaManager" name="server" map="C"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject createIndex(ComObject, boolean)" map="A"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject createTableSlave(ComObject, boolean)" map="B"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject dropIndexSlave(ComObject)" map="A"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject dropTable(ComObject, boolean)" map="C"/>
  <method class="com.sonicbase.server.SchemaManager" name="java.util.List createIndex(java.lang.String, java.lang.String, java.lang.String, boolean, java.lang.String[])" map="A"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject dropIndex(ComObject)" map="B"/>
  <method class="com.sonicbase.server.SchemaManager" name="void doCreateIndex(java.lang.String, TableSchema, java.lang.String, java.lang.String[])" map="A"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject createIndexSlave(ComObject)" map="C"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject createTable(ComObject, boolean)" map="D"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject addColumn(ComObject)" map="D"/>
  <method class="com.sonicbase.server.SchemaManager" name="void addAllIndices(java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject createDatabase(ComObject, boolean)" map="E"/>
  <method class="com.sonicbase.server.SchemaManager" name="ComObject dropColumn(ComObject)" map="E"/>
  <class name="com.sonicbase.server.PreparedIndexLookupNotFoundException" map="C"/>
  <class name="com.sonicbase.server.MethodInvoker$ReplicaFuture" map="_A"/>
  <field class="com.sonicbase.server.MethodInvoker$ReplicaFuture" name="this$0" map="A"/>
  <field class="com.sonicbase.server.MethodInvoker$ReplicaFuture" name="future" map="B"/>
  <field class="com.sonicbase.server.MethodInvoker$ReplicaFuture" name="replica" map="C"/>
  <method class="com.sonicbase.server.MethodInvoker$ReplicaFuture" name="int access$100(com.sonicbase.server.MethodInvoker$ReplicaFuture)" map="A"/>
  <method class="com.sonicbase.server.MethodInvoker$ReplicaFuture" name="java.util.concurrent.Future access$000(com.sonicbase.server.MethodInvoker$ReplicaFuture)" map="B"/>
  <field class="com.sonicbase.server.MethodInvoker" name="transactionManager" map="A"/>
  <field class="com.sonicbase.server.MethodInvoker" name="snapshotManager" map="B"/>
  <field class="com.sonicbase.server.MethodInvoker" name="testWriteCallCount" map="C"/>
  <field class="com.sonicbase.server.MethodInvoker" name="repartitioner" map="D"/>
  <field class="com.sonicbase.server.MethodInvoker" name="server" map="E"/>
  <field class="com.sonicbase.server.MethodInvoker" name="shutdown" map="F"/>
  <field class="com.sonicbase.server.MethodInvoker" name="priorityCommands" map="G"/>
  <field class="com.sonicbase.server.MethodInvoker" name="updateManager" map="H"/>
  <field class="com.sonicbase.server.MethodInvoker" name="common" map="I"/>
  <field class="com.sonicbase.server.MethodInvoker" name="schemaManager" map="J"/>
  <field class="com.sonicbase.server.MethodInvoker" name="readManager" map="K"/>
  <field class="com.sonicbase.server.MethodInvoker" name="logManager" map="L"/>
  <field class="com.sonicbase.server.MethodInvoker" name="logger" map="M"/>
  <field class="com.sonicbase.server.MethodInvoker" name="deleteManagerImpl" map="N"/>
  <method class="com.sonicbase.server.MethodInvoker" name="java.lang.Long getExistingSequence1(java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.MethodInvoker" name="java.lang.Long getExistingSequence0(java.lang.String)" map="B"/>
  <class name="com.sonicbase.server.UpdateManager$1" map="1"/>
  <field class="com.sonicbase.server.UpdateManager$1" name="$SwitchMap$com$sonicbase$server$TransactionManager$OperationType" map="A"/>
  <class name="com.sonicbase.server.UpdateManager" map="D"/>
  <field class="com.sonicbase.server.UpdateManager" name="insertCount" map="A"/>
  <field class="com.sonicbase.server.UpdateManager" name="logger" map="B"/>
  <field class="com.sonicbase.server.UpdateManager" name="server" map="C"/>
  <field class="com.sonicbase.server.UpdateManager" name="CURR_VER_STR" map="D"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject doPopulateIndex(ComObject)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject rollback(ComObject, boolean)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="void doInsertKeys(java.util.List, com.sonicbase.index.Index, java.lang.String, IndexSchema)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="void doInsertKey(long, byte[], java.lang.Object[], com.sonicbase.index.Index, java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject truncateTable(ComObject, boolean)" map="B"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject deleteIndexEntry(ComObject, boolean)" map="C"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject commit(ComObject, boolean)" map="D"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject populateIndex(ComObject)" map="B"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject insertIndexEntryByKey(ComObject, boolean)" map="E"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject doInsertIndexEntryByKey(ComObject, boolean, java.util.concurrent.atomic.AtomicBoolean, java.util.concurrent.atomic.AtomicLong, boolean)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject deleteIndexEntryByKey(ComObject, boolean)" map="F"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject deleteRecord(ComObject, boolean)" map="G"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject insertIndexEntryByKeyWithRecord(ComObject, boolean)" map="H"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject batchInsertIndexEntryByKeyWithRecord(ComObject, boolean)" map="I"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject updateRecord(ComObject, boolean)" map="J"/>
  <method class="com.sonicbase.server.UpdateManager" name="void doInsertKey(java.lang.Object[], byte[], java.lang.String, com.sonicbase.index.Index, IndexSchema)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject doInsertIndexEntryByKeyWithRecord(ComObject, long, long, long, boolean, java.util.concurrent.atomic.AtomicLong, java.util.concurrent.atomic.AtomicBoolean, boolean)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="void doRemoveIndexEntryByKey(java.lang.String, TableSchema, java.lang.String, java.lang.Object[], java.lang.String, java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="void doActualInsertKeyWithRecord(byte[], java.lang.Object[], com.sonicbase.index.Index, java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="com.sonicbase.server.UpdateManager" name="void doActualInsertKey(java.lang.Object[], byte[], java.lang.String, com.sonicbase.index.Index, IndexSchema)" map="B"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject doUpdateRecord(ComObject, boolean, java.util.concurrent.atomic.AtomicBoolean, java.util.concurrent.atomic.AtomicLong, boolean)" map="B"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject batchInsertIndexEntryByKey(ComObject, boolean)" map="K"/>
  <method class="com.sonicbase.server.UpdateManager" name="ComObject doDeleteIndexEntryByKey(ComObject, boolean, java.util.concurrent.atomic.AtomicBoolean, java.util.concurrent.atomic.AtomicLong, boolean)" map="C"/>
  <class name="com.sonicbase.server.RecordLockedException" map="E"/>
  <class name="com.sonicbase.server.SnapshotManagerImpl$3" map="3"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$outStreams" map="k"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$isPrimaryKey" map="l"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$indexEntry" map="m"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$savedCount" map="n"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$tableEntry" map="o"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="this$0" map="p"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$lastLogged" map="q"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$AtomicInteger" map="r"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$index" map="s"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$countSaved" map="t"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$3" name="val$subBegin" map="u"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$3" name="boolean visit(java.lang.Object[], java.lang.Object)" map="A"/>
  <class name="com.sonicbase.server.SnapshotManagerImpl$2" map="2"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$2" name="this$0" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$2" name="void run()" map="run"/>
  <class name="com.sonicbase.server.SnapshotManagerImpl$1" map="1"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$indexSchema" map="A"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$recoveredCount" map="B"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$currOffset" map="C"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$tableName" map="D"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$indexName" map="E"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="this$0" map="F"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$indexBegin" map="G"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$tableSchema" map="H"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$lastLogged" map="I"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$indexFile" map="J"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$1" name="val$index" map="K"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$1" name="java.lang.Object call()" map="call"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$1" name="java.lang.Boolean call()" map="A"/>
  <class name="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" map="_A"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="this$0" map="A"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="finishedBytes" map="B"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="stream" map="C"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="void reset()" map="reset"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="int read(byte[])" map="read"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="void close()" map="close"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="boolean markSupported()" map="markSupported"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="void mark(int)" map="mark"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="int read()" map="read"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="int read(byte[], int, int)" map="read"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="long skip(long)" map="skip"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl$ByteCounterStream" name="int available()" map="available"/>
  <class name="com.sonicbase.server.SnapshotManagerImpl" map="F"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="DURATION_STR" map="A"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="lockedSnapshots" map="B"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="totalBytes" map="C"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="pauseSnapshotRolling" map="D"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="INDEX_STR" map="E"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="totalFileCount" map="F"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="SNAPSHOT_SERIALIZATION_VERSION_19" map="G"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="SNAPSHOT_STR" map="H"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="SNAPSHOT_BUCKET_COUNT" map="I"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="snapshotThread" map="J"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="SNAPSHOT_SERIALIZATION_VERSION" map="K"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="isRecovering" map="L"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="server" map="M"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="errorRecovering" map="N"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="finishedFileCount" map="O"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="SNAPSHOT_SERIALIZATION_VERSION_21" map="P"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="SNAPSHOT_SERIALIZATION_VERSION_20" map="Q"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="enableSnapshot" map="R"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="lastSnapshot" map="S"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="RATE_STR" map="T"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="finishedBytes" map="U"/>
  <field class="com.sonicbase.server.SnapshotManagerImpl" name="logger" map="V"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="java.lang.Exception getErrorRecovering()" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void runSnapshot(java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="java.lang.String lockSnapshot(java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void restoreFileSystem(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void abortSnapshot()" map="B"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="int getHighestSafeSnapshotVersion(java.io.File)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="java.util.concurrent.atomic.AtomicLong access$000(com.sonicbase.server.SnapshotManagerImpl)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void enableSnapshot(boolean)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void doDeleteInProcessDirs(java.io.File)" map="B"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="boolean isRecovering()" map="C"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void backupAWS(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="int getHighestUnsafeSnapshotVersion(java.io.File)" map="C"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="java.lang.String getSnapshotRootDir(java.lang.String)" map="C"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void backupAWSSchema(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="double getPercentRecoverComplete()" map="D"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="com.sonicbase.server.DatabaseServer access$100(com.sonicbase.server.SnapshotManagerImpl)" map="B"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void getFilesFromDirectory(java.io.File, java.util.List)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void restoreAWS(java.lang.String, java.lang.String, java.lang.String)" map="C"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="java.io.File getSnapshotReplicaDir()" map="E"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void unlockSnapshot(int)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void deleteInProcessDirs()" map="F"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void deleteOldSnapshots(java.lang.String)" map="D"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void recoverFromSnapshot(java.lang.String)" map="E"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void pauseSnapshotRolling(boolean)" map="B"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void backupFileSystemSchema(java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="boolean access$300(com.sonicbase.server.SnapshotManagerImpl)" map="C"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void runSnapshotLoop()" map="G"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="long access$200(com.sonicbase.server.SnapshotManagerImpl)" map="D"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void getFilesForCurrentSnapshot(java.util.List)" map="A"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void deleteSnapshots()" map="H"/>
  <method class="com.sonicbase.server.SnapshotManagerImpl" name="void backupFileSystem(java.lang.String, java.lang.String)" map="C"/>
  <class name="com.sonicbase.server.DeleteManagerImpl$3" map="3"/>
  <field class="com.sonicbase.server.DeleteManagerImpl$3" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl$3" name="void run()" map="run"/>
  <class name="com.sonicbase.server.DeleteManagerImpl$2" map="2"/>
  <field class="com.sonicbase.server.DeleteManagerImpl$2" name="this$0" map="A"/>
  <field class="com.sonicbase.server.DeleteManagerImpl$2" name="val$index" map="B"/>
  <field class="com.sonicbase.server.DeleteManagerImpl$2" name="val$currBatch" map="C"/>
  <method class="com.sonicbase.server.DeleteManagerImpl$2" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.server.DeleteManagerImpl$1" map="1"/>
  <field class="com.sonicbase.server.DeleteManagerImpl$1" name="this$0" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="com.sonicbase.server.DeleteManagerImpl$1" name="int compare(java.io.File, java.io.File)" map="A"/>
  <class name="com.sonicbase.server.DeleteManagerImpl" map="G"/>
  <field class="com.sonicbase.server.DeleteManagerImpl" name="logger" map="A"/>
  <field class="com.sonicbase.server.DeleteManagerImpl" name="mainThread" map="B"/>
  <field class="com.sonicbase.server.DeleteManagerImpl" name="databaseServer" map="C"/>
  <field class="com.sonicbase.server.DeleteManagerImpl" name="executor" map="D"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="com.sonicbase.server.DatabaseServer access$000(com.sonicbase.server.DeleteManagerImpl)" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void getFiles(java.util.List)" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void backupFileSystem(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void saveDeletes(java.lang.String, java.lang.String, java.lang.String, java.util.concurrent.ConcurrentLinkedQueue)" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void restoreAWS(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="java.io.File getReplicaRoot()" map="A"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void start()" map="B"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void backupAWS(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="Logger access$100(com.sonicbase.server.DeleteManagerImpl)" map="B"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void restoreFileSystem(java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void forceDeletes()" map="C"/>
  <method class="com.sonicbase.server.DeleteManagerImpl" name="void doDeletes()" map="D"/>
  <class name="com.sonicbase.server.LogManager$LogWriter" map="_A"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="replica" map="A"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="currLogRequests" map="B"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="writer" map="C"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="offset" map="D"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="this$0" map="E"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="peerReplicaNum" map="F"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="dataDir" map="G"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="currQueueTime" map="H"/>
  <field class="com.sonicbase.server.LogManager$LogWriter" name="shard" map="I"/>
  <method class="com.sonicbase.server.LogManager$LogWriter" name="void access$000(com.sonicbase.server.LogManager$LogWriter)" map="A"/>
  <method class="com.sonicbase.server.LogManager$LogWriter" name="void closeAndCreateLog()" map="A"/>
  <method class="com.sonicbase.server.LogManager$LogWriter" name="void run()" map="run"/>
  <class name="com.sonicbase.server.LogManager$2" map="2"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$sequence1" map="A"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$sequence0" map="B"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$countFinished" map="C"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$begin" map="D"/>
  <field class="com.sonicbase.server.LogManager$2" name="this$0" map="E"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$lastLogged" map="F"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$command" map="G"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$batchCount" map="H"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$countBatched" map="I"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$countProcessed" map="J"/>
  <field class="com.sonicbase.server.LogManager$2" name="val$buffer" map="K"/>
  <method class="com.sonicbase.server.LogManager$2" name="void run()" map="run"/>
  <class name="com.sonicbase.server.LogManager$LogSource" map="_B"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="requests" map="A"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="filename" map="B"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="AtomicInteger" map="C"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="command" map="D"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="totalBytes" map="E"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="offset" map="F"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="buffer" map="G"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="this$0" map="H"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="counterStream" map="I"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="sequence1" map="J"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="sequence0" map="K"/>
  <field class="com.sonicbase.server.LogManager$LogSource" name="in" map="L"/>
  <method class="com.sonicbase.server.LogManager$LogSource" name="com.sonicbase.research.socket.NettyServer$Request readRequest()" map="A"/>
  <method class="com.sonicbase.server.LogManager$LogSource" name="long getTotalBytes()" map="B"/>
  <method class="com.sonicbase.server.LogManager$LogSource" name="void readNext()" map="C"/>
  <method class="com.sonicbase.server.LogManager$LogSource" name="long getBytesRead()" map="D"/>
  <method class="com.sonicbase.server.LogManager$LogSource" name="void close()" map="E"/>
  <method class="com.sonicbase.server.LogManager$LogSource" name="boolean take()" map="F"/>
  <class name="com.sonicbase.server.LogManager$QueueEntry" map="_C"/>
  <field class="com.sonicbase.server.LogManager$QueueEntry" name="body" map="A"/>
  <field class="com.sonicbase.server.LogManager$QueueEntry" name="command" map="B"/>
  <class name="com.sonicbase.server.LogManager$1" map="1"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$countFinished" map="A"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$begin" map="B"/>
  <field class="com.sonicbase.server.LogManager$1" name="this$0" map="C"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$lastLogged" map="D"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$batchCount" map="E"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$request" map="F"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$countBatched" map="G"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$countProcessed" map="H"/>
  <field class="com.sonicbase.server.LogManager$1" name="val$minSource" map="I"/>
  <method class="com.sonicbase.server.LogManager$1" name="void run()" map="run"/>
  <class name="com.sonicbase.server.LogManager$ByteCounterStream" map="_D"/>
  <field class="com.sonicbase.server.LogManager$ByteCounterStream" name="this$0" map="A"/>
  <field class="com.sonicbase.server.LogManager$ByteCounterStream" name="in" map="B"/>
  <field class="com.sonicbase.server.LogManager$ByteCounterStream" name="count" map="C"/>
  <method class="com.sonicbase.server.LogManager$ByteCounterStream" name="int read()" map="read"/>
  <class name="com.sonicbase.server.LogManager" map="H"/>
  <field class="com.sonicbase.server.LogManager" name="shouldSlice" map="A"/>
  <field class="com.sonicbase.server.LogManager" name="allCurrentSources" map="B"/>
  <field class="com.sonicbase.server.LogManager" name="executor" map="C"/>
  <field class="com.sonicbase.server.LogManager" name="logSequenceNumber" map="D"/>
  <field class="com.sonicbase.server.LogManager" name="didSlice" map="E"/>
  <field class="com.sonicbase.server.LogManager" name="maxAllocatedLogSequenceNumber" map="F"/>
  <field class="com.sonicbase.server.LogManager" name="currFilename" map="G"/>
  <field class="com.sonicbase.server.LogManager" name="server" map="H"/>
  <field class="com.sonicbase.server.LogManager" name="peerLogRequests" map="I"/>
  <field class="com.sonicbase.server.LogManager" name="peerLogProcessors" map="J"/>
  <field class="com.sonicbase.server.LogManager" name="SEQUENCE_NUM_ALLOC_COUNT" map="K"/>
  <field class="com.sonicbase.server.LogManager" name="databaseServer" map="L"/>
  <field class="com.sonicbase.server.LogManager" name="logLock" map="M"/>
  <field class="com.sonicbase.server.LogManager" name="logProcessors" map="N"/>
  <field class="com.sonicbase.server.LogManager" name="logRequests" map="O"/>
  <field class="com.sonicbase.server.LogManager" name="unbindQueues" map="P"/>
  <field class="com.sonicbase.server.LogManager" name="UTF8_STR" map="Q"/>
  <field class="com.sonicbase.server.LogManager" name="sliceFilename" map="R"/>
  <field class="com.sonicbase.server.LogManager" name="countLogged" map="S"/>
  <field class="com.sonicbase.server.LogManager" name="logger" map="T"/>
  <method class="com.sonicbase.server.LogManager" name="void bindQueues()" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void replayLogs()" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="void pushMaxSequenceNum()" map="C"/>
  <method class="com.sonicbase.server.LogManager" name="void backupAWS(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="java.lang.String sliceLogs(boolean)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="long getCountLogged()" map="D"/>
  <method class="com.sonicbase.server.LogManager" name="void replayQueues(java.io.File, java.lang.String, boolean, boolean)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="com.sonicbase.server.DatabaseServer access$700(com.sonicbase.server.LogManager)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void applyLogsFromPeers(java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="Logger access$300(com.sonicbase.server.LogManager)" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="ComObject getLogFile(ComObject)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="ComObject sendLogsToPeer(int)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void backupLogDir(java.lang.String, java.io.File, java.io.File)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="boolean access$102(com.sonicbase.server.LogManager, boolean)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void startLoggingForPeer(int)" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="void deleteOldLogs(long)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="boolean hasLogsForPeer(int)" map="C"/>
  <method class="com.sonicbase.server.LogManager" name="void receiveExternalLog(int, java.lang.String, byte[])" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void restoreLogDir(java.io.File, java.io.File)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="double getPercentApplyQueuesComplete()" map="E"/>
  <method class="com.sonicbase.server.LogManager" name="java.lang.String access$600(com.sonicbase.server.LogManager)" map="C"/>
  <method class="com.sonicbase.server.LogManager" name="java.lang.String access$402(com.sonicbase.server.LogManager, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void enableLogProcessor(boolean)" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="boolean access$100(com.sonicbase.server.LogManager)" map="D"/>
  <method class="com.sonicbase.server.LogManager" name="void backupFileSystem(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="java.io.File getLogReplicaDir()" map="F"/>
  <method class="com.sonicbase.server.LogManager" name="void applyLogsAfterSlice(java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="void restoreAWS(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="com.sonicbase.server.DatabaseServer$LogRequest dont_use_logRequests(java.util.List, boolean)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="com.sonicbase.server.DatabaseServer$LogRequest logRequest(java.lang.String, byte[], boolean, java.lang.String, java.lang.Long, java.lang.Long)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="java.lang.String access$502(com.sonicbase.server.LogManager, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="java.util.concurrent.atomic.AtomicLong access$200(com.sonicbase.server.LogManager)" map="E"/>
  <method class="com.sonicbase.server.LogManager" name="ComObject setMaxSequenceNum(ComObject)" map="B"/>
  <method class="com.sonicbase.server.LogManager" name="void skipToMaxSequenceNumber()" map="G"/>
  <method class="com.sonicbase.server.LogManager" name="void deleteLogs()" map="H"/>
  <method class="com.sonicbase.server.LogManager" name="java.lang.String access$400(com.sonicbase.server.LogManager)" map="F"/>
  <method class="com.sonicbase.server.LogManager" name="void deletePeerLogs(int)" map="D"/>
  <method class="com.sonicbase.server.LogManager" name="void logRequestForPeer(java.lang.String, byte[], long, long, int)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void restoreFileSystem(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void backupLogDirToAWS(com.sonicbase.common.AWSClient, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.io.File)" map="A"/>
  <method class="com.sonicbase.server.LogManager" name="void unbindQueues()" map="I"/>
  <method class="com.sonicbase.server.LogManager" name="void applyQueues()" map="J"/>
  <method class="com.sonicbase.server.LogManager" name="long getNextSequencenNum()" map="K"/>
  <method class="com.sonicbase.server.LogManager" name="java.lang.String getLogRoot()" map="L"/>
  <method class="com.sonicbase.server.LogManager" name="void getLogsFromPeer(int)" map="E"/>
  <method class="com.sonicbase.server.LogManager" name="ComObject deletePeerLogs(ComObject)" map="C"/>
  <class name="com.sonicbase.server.LongRunningCommands$Type" map="_A"/>
  <field class="com.sonicbase.server.LongRunningCommands$Type" name="$VALUES" map="A"/>
  <field class="com.sonicbase.server.LongRunningCommands$Type" name="compound" map="B"/>
  <field class="com.sonicbase.server.LongRunningCommands$Type" name="value" map="C"/>
  <field class="com.sonicbase.server.LongRunningCommands$Type" name="single" map="D"/>
  <method class="com.sonicbase.server.LongRunningCommands$Type" name="com.sonicbase.server.LongRunningCommands$Type valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.sonicbase.server.LongRunningCommands$Type" name="com.sonicbase.server.LongRunningCommands$Type[] values()" map="values"/>
  <class name="com.sonicbase.server.LongRunningCommands$SingleCommand$1" map="1"/>
  <field class="com.sonicbase.server.LongRunningCommands$SingleCommand$1" name="this$0" map="A"/>
  <field class="com.sonicbase.server.LongRunningCommands$SingleCommand$1" name="val$parentList" map="B"/>
  <method class="com.sonicbase.server.LongRunningCommands$SingleCommand$1" name="void run()" map="run"/>
  <class name="com.sonicbase.server.LongRunningCommands$SingleCommand" map="_B"/>
  <field class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="body" map="A"/>
  <field class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="longRunningCommands" map="B"/>
  <field class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="command" map="C"/>
  <method class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="void access$000(com.sonicbase.server.LongRunningCommands$SingleCommand, java.util.concurrent.ConcurrentLinkedQueue)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="void doExecute(java.util.concurrent.ConcurrentLinkedQueue)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands$SingleCommand" name="void execute(java.util.concurrent.ConcurrentLinkedQueue)" map="B"/>
  <class name="com.sonicbase.server.LongRunningCommands" map="I"/>
  <field class="com.sonicbase.server.LongRunningCommands" name="commands" map="A"/>
  <field class="com.sonicbase.server.LongRunningCommands" name="logger" map="B"/>
  <field class="com.sonicbase.server.LongRunningCommands" name="lookupTypeById" map="C"/>
  <field class="com.sonicbase.server.LongRunningCommands" name="server" map="D"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void addCommand(com.sonicbase.server.LongRunningCommands$SingleCommand)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void getFiles(java.util.List)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void save()" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="com.sonicbase.server.DatabaseServer access$100(com.sonicbase.server.LongRunningCommands)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="com.sonicbase.server.LongRunningCommands$SingleCommand createSingleCommand(java.lang.String, byte[])" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void backupFileSystem(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void execute()" map="B"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void restoreAWS(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="java.io.File getReplicaRoot()" map="C"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void deleteOldFiles()" map="D"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void backupAWS(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="int getHighestSafeSnapshotVersion(java.io.File)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="int getCommandCount()" map="E"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void restoreFileSystem(java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="com.sonicbase.server.LongRunningCommands" name="void load()" map="F"/>
  <class name="com.sonicbase.server.ReadManager$3" map="3"/>
  <field class="com.sonicbase.server.ReadManager$3" name="this$0" map="A"/>
  <method class="com.sonicbase.server.ReadManager$3" name="void run()" map="run"/>
  <class name="com.sonicbase.server.ReadManager$PreparedIndexLookup" map="_A"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="orderByExpressions" map="A"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="columnOffsets" map="B"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="tableId" map="C"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="this$0" map="D"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="count" map="E"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="lastTimeUsed" map="F"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="expression" map="G"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="indexId" map="H"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="evaluateExpression" map="I"/>
  <field class="com.sonicbase.server.ReadManager$PreparedIndexLookup" name="forceSelectOnServer" map="J"/>
  <class name="com.sonicbase.server.ReadManager$2" map="2"/>
  <field class="com.sonicbase.server.ReadManager$2" name="this$0" map="A"/>
  <method class="com.sonicbase.server.ReadManager$2" name="void run()" map="run"/>
  <class name="com.sonicbase.server.ReadManager$1" map="1"/>
  <field class="com.sonicbase.server.ReadManager$1" name="this$0" map="A"/>
  <method class="com.sonicbase.server.ReadManager$1" name="void run()" map="run"/>
  <class name="com.sonicbase.server.ReadManager" map="J"/>
  <field class="com.sonicbase.server.ReadManager" name="preparedReaper" map="A"/>
  <field class="com.sonicbase.server.ReadManager" name="METRICS" map="B"/>
  <field class="com.sonicbase.server.ReadManager" name="lookupCount" map="C"/>
  <field class="com.sonicbase.server.ReadManager" name="server" map="D"/>
  <field class="com.sonicbase.server.ReadManager" name="diskReaper" map="E"/>
  <field class="com.sonicbase.server.ReadManager" name="preparedIndexLookups" map="F"/>
  <field class="com.sonicbase.server.ReadManager" name="SELECT_PAGE_SIZE" map="G"/>
  <field class="com.sonicbase.server.ReadManager" name="BATCH_INDEX_LOOKUP_STATS" map="H"/>
  <field class="com.sonicbase.server.ReadManager" name="INDEX_LOOKUP_STATS" map="I"/>
  <field class="com.sonicbase.server.ReadManager" name="logger" map="J"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject closeResultSet(ComObject, boolean)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="void handleRecord(java.lang.String, TableSchema, IndexSchema, long, com.sonicbase.index.Index, java.lang.Object[], ParameterHandler, boolean, Expression, java.util.Set, boolean, java.util.List, java.util.List, boolean, Counter[], GroupByContext, byte[][], byte[][])" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="com.sonicbase.server.DatabaseServer access$100(com.sonicbase.server.ReadManager)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="void startDiskResultsReaper()" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject serverSelect(ComObject)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="Logger access$000(com.sonicbase.server.ReadManager)" map="B"/>
  <method class="com.sonicbase.server.ReadManager" name="java.util.Set getSimpleColumnOffsets(java.io.DataInputStream, com.sonicbase.util.DataUtil$ResultLength, java.lang.String, TableSchema)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject countRecords(ComObject)" map="B"/>
  <method class="com.sonicbase.server.ReadManager" name="Record[] applySelectToResultRecords(java.lang.String, java.util.Set, boolean, byte[][], java.lang.Object[], TableSchema, Counter[], GroupByContext)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject evaluateCounter(ComObject)" map="C"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject batchIndexLookup(ComObject)" map="D"/>
  <method class="com.sonicbase.server.ReadManager" name="void expirePreparedStatement(long)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="java.util.concurrent.ConcurrentHashMap access$200(com.sonicbase.server.ReadManager)" map="C"/>
  <method class="com.sonicbase.server.ReadManager" name="byte[][] processViewFlags(java.lang.String, TableSchema, IndexSchema, com.sonicbase.index.Index, long, java.lang.Object[], byte[][])" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject indexLookupExpression(ComObject)" map="E"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject serverSelectDelete(ComObject, boolean)" map="B"/>
  <method class="com.sonicbase.server.ReadManager" name="ComObject indexLookup(ComObject)" map="F"/>
  <method class="com.sonicbase.server.ReadManager" name="void startPreparedReaper()" map="B"/>
  <method class="com.sonicbase.server.ReadManager" name="java.util.Map$Entry doIndexLookupWithRecordsExpression(java.lang.String, int, TableSchema, java.util.Set, ParameterHandler, Expression, com.sonicbase.index.Index, java.lang.Object[], java.lang.Boolean, java.util.List, Counter[], GroupByContext)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="java.util.Map$Entry doIndexLookupOneKey(java.lang.String, int, TableSchema, IndexSchema, ParameterHandler, boolean, Expression, java.util.Set, boolean, java.util.List, java.lang.Object[], java.lang.Object[], BinaryExpression$Operator, com.sonicbase.index.Index, java.lang.Boolean, java.util.List, java.util.List, long, boolean, Counter[], GroupByContext)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="java.util.Set getColumnOffsets(java.io.DataInputStream, com.sonicbase.util.DataUtil$ResultLength, java.lang.String, TableSchema)" map="B"/>
  <method class="com.sonicbase.server.ReadManager" name="java.util.Map$Entry doIndexLookupTwoKeys(java.lang.String, int, TableSchema, IndexSchema, boolean, java.util.List, java.lang.Object[], java.lang.Object[], java.util.Set, java.lang.Object[], java.lang.Object[], BinaryExpression$Operator, BinaryExpression$Operator, ParameterHandler, boolean, Expression, com.sonicbase.index.Index, java.lang.Boolean, java.util.List, java.util.List, boolean, Counter[], GroupByContext)" map="A"/>
  <method class="com.sonicbase.server.ReadManager" name="void count(Counter[], Record)" map="A"/>
  <class name="com.sonicbase.server.TransactionManager$Operation" map="_A"/>
  <field class="com.sonicbase.server.TransactionManager$Operation" name="body" map="A"/>
  <field class="com.sonicbase.server.TransactionManager$Operation" name="type" map="B"/>
  <field class="com.sonicbase.server.TransactionManager$Operation" name="replayed" map="C"/>
  <field class="com.sonicbase.server.TransactionManager$Operation" name="command" map="D"/>
  <method class="com.sonicbase.server.TransactionManager$Operation" name="boolean getReplayed()" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$Operation" name="java.lang.String getCommand()" map="B"/>
  <method class="com.sonicbase.server.TransactionManager$Operation" name="byte[] getBody()" map="C"/>
  <method class="com.sonicbase.server.TransactionManager$Operation" name="com.sonicbase.server.TransactionManager$OperationType getType()" map="D"/>
  <class name="com.sonicbase.server.TransactionManager$Transaction" map="_B"/>
  <field class="com.sonicbase.server.TransactionManager$Transaction" name="records" map="A"/>
  <field class="com.sonicbase.server.TransactionManager$Transaction" name="operations" map="B"/>
  <field class="com.sonicbase.server.TransactionManager$Transaction" name="locks" map="C"/>
  <field class="com.sonicbase.server.TransactionManager$Transaction" name="id" map="D"/>
  <method class="com.sonicbase.server.TransactionManager$Transaction" name="long access$600(com.sonicbase.server.TransactionManager$Transaction)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$Transaction" name="java.util.List getOperations()" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$Transaction" name="void addOperation(com.sonicbase.server.TransactionManager$OperationType, java.lang.String, byte[], boolean)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$Transaction" name="java.util.List getLocks()" map="B"/>
  <method class="com.sonicbase.server.TransactionManager$Transaction" name="java.util.concurrent.ConcurrentHashMap getRecords()" map="C"/>
  <method class="com.sonicbase.server.TransactionManager$Transaction" name="java.util.List access$000(com.sonicbase.server.TransactionManager$Transaction)" map="B"/>
  <class name="com.sonicbase.server.TransactionManager$1" map="1"/>
  <field class="com.sonicbase.server.TransactionManager$1" name="this$0" map="A"/>
  <field class="com.sonicbase.server.TransactionManager$1" name="val$comparators" map="B"/>
  <method class="com.sonicbase.server.TransactionManager$1" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.server.TransactionManager$RecordLock" map="_C"/>
  <field class="com.sonicbase.server.TransactionManager$RecordLock" name="primaryKey" map="A"/>
  <field class="com.sonicbase.server.TransactionManager$RecordLock" name="tableName" map="B"/>
  <field class="com.sonicbase.server.TransactionManager$RecordLock" name="lockCount" map="C"/>
  <field class="com.sonicbase.server.TransactionManager$RecordLock" name="indexName" map="D"/>
  <field class="com.sonicbase.server.TransactionManager$RecordLock" name="transaction" map="E"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="int access$308(com.sonicbase.server.TransactionManager$RecordLock)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="com.sonicbase.server.TransactionManager$Transaction access$400(com.sonicbase.server.TransactionManager$RecordLock)" map="B"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="com.sonicbase.server.TransactionManager$Transaction access$402(com.sonicbase.server.TransactionManager$RecordLock, com.sonicbase.server.TransactionManager$Transaction)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.String access$502(com.sonicbase.server.TransactionManager$RecordLock, java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.String getTableName()" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.Object[] access$202(com.sonicbase.server.TransactionManager$RecordLock, java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="int access$300(com.sonicbase.server.TransactionManager$RecordLock)" map="C"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.String access$100(com.sonicbase.server.TransactionManager$RecordLock)" map="D"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.Object[] getPrimaryKey()" map="B"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.String access$102(com.sonicbase.server.TransactionManager$RecordLock, java.lang.String)" map="B"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="int access$302(com.sonicbase.server.TransactionManager$RecordLock, int)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.Object[] access$200(com.sonicbase.server.TransactionManager$RecordLock)" map="E"/>
  <method class="com.sonicbase.server.TransactionManager$RecordLock" name="java.lang.String getIndexName()" map="C"/>
  <class name="com.sonicbase.server.TransactionManager$OperationType" map="_D"/>
  <field class="com.sonicbase.server.TransactionManager$OperationType" name="insertWithRecord" map="A"/>
  <field class="com.sonicbase.server.TransactionManager$OperationType" name="$VALUES" map="B"/>
  <field class="com.sonicbase.server.TransactionManager$OperationType" name="batchInsert" map="C"/>
  <field class="com.sonicbase.server.TransactionManager$OperationType" name="batchInsertWithRecord" map="D"/>
  <field class="com.sonicbase.server.TransactionManager$OperationType" name="insert" map="E"/>
  <field class="com.sonicbase.server.TransactionManager$OperationType" name="delete" map="F"/>
  <field class="com.sonicbase.server.TransactionManager$OperationType" name="update" map="G"/>
  <method class="com.sonicbase.server.TransactionManager$OperationType" name="com.sonicbase.server.TransactionManager$OperationType valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.sonicbase.server.TransactionManager$OperationType" name="com.sonicbase.server.TransactionManager$OperationType[] values()" map="values"/>
  <class name="com.sonicbase.server.TransactionManager" map="K"/>
  <field class="com.sonicbase.server.TransactionManager" name="transactions" map="A"/>
  <field class="com.sonicbase.server.TransactionManager" name="locks" map="B"/>
  <field class="com.sonicbase.server.TransactionManager" name="server" map="C"/>
  <method class="com.sonicbase.server.TransactionManager" name="java.util.concurrent.ConcurrentHashMap getLocks(java.lang.String)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager" name="java.util.concurrent.ConcurrentHashMap getTransactions()" map="A"/>
  <method class="com.sonicbase.server.TransactionManager" name="void preHandleTransaction(java.lang.String, java.lang.String, java.lang.String, boolean, boolean, long, java.lang.Object[], java.util.concurrent.atomic.AtomicBoolean, java.util.concurrent.atomic.AtomicBoolean)" map="A"/>
  <method class="com.sonicbase.server.TransactionManager" name="void deleteLock(java.lang.String, java.lang.String, java.lang.String, long, TableSchema, java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.server.TransactionManager" name="ComObject abortTransaction(java.lang.String, byte[])" map="A"/>
  <method class="com.sonicbase.server.TransactionManager" name="com.sonicbase.server.TransactionManager$Transaction getTransaction(long)" map="A"/>
  <field class="FieldSchema" name="name" map="A"/>
  <field class="FieldSchema" name="autoIncrement" map="B"/>
  <field class="FieldSchema" name="mapToOffset" map="C"/>
  <field class="FieldSchema" name="width" map="D"/>
  <field class="FieldSchema" name="type" map="E"/>
  <field class="FieldSchema" name="array" map="F"/>
  <class name="TableSchema$PreviousFields" map="_A"/>
  <field class="TableSchema$PreviousFields" name="this$0" map="A"/>
  <field class="TableSchema$PreviousFields" name="fields" map="B"/>
  <field class="TableSchema$PreviousFields" name="schemaVersion" map="C"/>
  <class name="TableSchema$Partition" map="_B"/>
  <field class="TableSchema$Partition" name="shardOwning" map="A"/>
  <field class="TableSchema$Partition" name="upperKey" map="B"/>
  <field class="TableSchema$Partition" name="unboundUpper" map="C"/>
  <method class="TableSchema$Partition" name="void deserialize(TableSchema, java.io.DataInputStream)" map="A"/>
  <method class="TableSchema$Partition" name="int access$002(TableSchema$Partition, int)" map="A"/>
  <method class="TableSchema$Partition" name="java.lang.Object[] access$200(TableSchema$Partition)" map="A"/>
  <method class="TableSchema$Partition" name="void setUnboundUpper(boolean)" map="A"/>
  <method class="TableSchema$Partition" name="void serialize(TableSchema, java.lang.String, java.io.DataOutputStream)" map="A"/>
  <method class="TableSchema$Partition" name="int getShardOwning()" map="A"/>
  <method class="TableSchema$Partition" name="int access$000(TableSchema$Partition)" map="B"/>
  <method class="TableSchema$Partition" name="void setUpperKey(java.lang.Object[])" map="A"/>
  <method class="TableSchema$Partition" name="boolean isUnboundUpper()" map="B"/>
  <method class="TableSchema$Partition" name="java.lang.Object[] getUpperKey()" map="C"/>
  <method class="TableSchema$Partition" name="java.lang.Object[] access$202(TableSchema$Partition, java.lang.Object[])" map="A"/>
  <method class="TableSchema$Partition" name="boolean access$100(TableSchema$Partition)" map="C"/>
  <method class="TableSchema$Partition" name="void setShardOwning(int)" map="A"/>
  <field class="TableSchema" name="name" map="A"/>
  <field class="TableSchema" name="indexesById" map="B"/>
  <field class="TableSchema" name="tableId" map="C"/>
  <field class="TableSchema" name="indexes" map="D"/>
  <field class="TableSchema" name="fields" map="E"/>
  <field class="TableSchema" name="version" map="F"/>
  <field class="TableSchema" name="primaryKey" map="G"/>
  <field class="TableSchema" name="previousFields" map="H"/>
  <field class="TableSchema" name="fieldOffsets" map="I"/>
  <method class="TableSchema" name="int getVersion()" map="A"/>
  <method class="TableSchema" name="void setVersion(int)" map="A"/>
  <class name="DataType$TimeConverter" map="_A"/>
  <method class="DataType$TimeConverter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$23" map="23"/>
  <method class="DataType$23" name="java.lang.Object increment(java.lang.Object)" map="A"/>
  <class name="DataType$22" map="22"/>
  <method class="DataType$22" name="java.lang.Object increment(java.lang.Object)" map="A"/>
  <class name="DataType$21" map="21"/>
  <method class="DataType$21" name="java.lang.Object increment(java.lang.Object)" map="A"/>
  <class name="DataType$20" map="20"/>
  <method class="DataType$20" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$BlobConverter" map="_B"/>
  <method class="DataType$BlobConverter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$Incrementer" map="_C"/>
  <method class="DataType$Incrementer" name="java.lang.Object increment(java.lang.Object)" map="A"/>
  <class name="DataType$LongComparator" map="_D"/>
  <method class="DataType$LongComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$ByteArrayComparator" map="_E"/>
  <method class="DataType$ByteArrayComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$TimestampConverter" map="_F"/>
  <method class="DataType$TimestampConverter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$9" map="9"/>
  <method class="DataType$9" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$8" map="8"/>
  <method class="DataType$8" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$19" map="19"/>
  <method class="DataType$19" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$7" map="7"/>
  <method class="DataType$7" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$18" map="18"/>
  <method class="DataType$18" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$6" map="6"/>
  <method class="DataType$6" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$17" map="17"/>
  <method class="DataType$17" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$5" map="5"/>
  <method class="DataType$5" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$16" map="16"/>
  <method class="DataType$16" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$4" map="4"/>
  <method class="DataType$4" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$15" map="15"/>
  <method class="DataType$15" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$3" map="3"/>
  <method class="DataType$3" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$14" map="14"/>
  <method class="DataType$14" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$2" map="2"/>
  <method class="DataType$2" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$DoubleConverter" map="_G"/>
  <method class="DataType$DoubleConverter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$LongConverter" map="_H"/>
  <method class="DataType$LongConverter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$13" map="13"/>
  <method class="DataType$13" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$1" map="1"/>
  <method class="DataType$1" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$12" map="12"/>
  <method class="DataType$12" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$11" map="11"/>
  <method class="DataType$11" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$10" map="10"/>
  <method class="DataType$10" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$Utf8Comparator" map="_I"/>
  <method class="DataType$Utf8Comparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DataType$DateConverter" map="_J"/>
  <method class="DataType$DateConverter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <class name="DataType$BigDecimalConverter" map="_K"/>
  <method class="DataType$BigDecimalConverter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <field class="DataType$Type" name="incrementer" map="A"/>
  <field class="DataType$Type" name="comparator" map="B"/>
  <field class="DataType$Type" name="initialValue" map="C"/>
  <field class="DataType$Type" name="converter" map="D"/>
  <field class="DataType$Type" name="$VALUES" map="E"/>
  <field class="DataType$Type" name="value" map="F"/>
  <class name="DataType$Converter" map="_L"/>
  <method class="DataType$Converter" name="java.lang.Object convert(java.lang.Object)" map="A"/>
  <field class="DataType" name="byteArrayComparator" map="A"/>
  <field class="DataType" name="intConverter" map="B"/>
  <field class="DataType" name="byteConverter" map="C"/>
  <field class="DataType" name="byteComparator" map="D"/>
  <field class="DataType" name="utf8Converter" map="E"/>
  <field class="DataType" name="stringComparator" map="F"/>
  <field class="DataType" name="doubleConverter" map="G"/>
  <field class="DataType" name="utf8Comparator" map="H"/>
  <field class="DataType" name="longComparator" map="I"/>
  <field class="DataType" name="bigDecimalIncrementer" map="J"/>
  <field class="DataType" name="blobConverter" map="K"/>
  <field class="DataType" name="bigDecimalConverter" map="L"/>
  <field class="DataType" name="doubleComparator" map="M"/>
  <field class="DataType" name="dateComparator" map="N"/>
  <field class="DataType" name="intComparator" map="O"/>
  <field class="DataType" name="longConverter" map="P"/>
  <field class="DataType" name="dateConverter" map="Q"/>
  <field class="DataType" name="types" map="R"/>
  <field class="DataType" name="shortComparator" map="S"/>
  <field class="DataType" name="timestampConverter" map="T"/>
  <field class="DataType" name="floatConverter" map="U"/>
  <field class="DataType" name="intIncrementer" map="V"/>
  <field class="DataType" name="timeComparator" map="W"/>
  <field class="DataType" name="byteArrayConverter" map="X"/>
  <field class="DataType" name="longIncrementer" map="Y"/>
  <field class="DataType" name="booleanConverter" map="Z"/>
  <field class="DataType" name="timeConverter" map="_"/>
  <field class="DataType" name="booleanComparator" map="a"/>
  <field class="DataType" name="timestampComparator" map="b"/>
  <field class="DataType" name="bigDecimalComparator" map="c"/>
  <field class="DataType" name="floatComparator" map="d"/>
  <field class="DataType" name="stringConverter" map="e"/>
  <field class="DataType" name="blobComparator" map="f"/>
  <field class="DataType" name="shortConverter" map="g"/>
  <method class="DataType" name="DataType$Converter access$1300()" map="A"/>
  <method class="DataType" name="DataType$Converter access$400()" map="B"/>
  <method class="DataType" name="java.util.Comparator access$3000()" map="C"/>
  <method class="DataType" name="DataType$Converter access$1000()" map="D"/>
  <method class="DataType" name="java.util.Comparator access$3500()" map="E"/>
  <method class="DataType" name="java.util.Comparator access$2200()" map="F"/>
  <method class="DataType" name="java.util.Comparator access$3600()" map="G"/>
  <method class="DataType" name="DataType$Converter access$1700()" map="H"/>
  <method class="DataType" name="DataType$Converter access$2100()" map="I"/>
  <method class="DataType" name="DataType$Converter access$1400()" map="J"/>
  <method class="DataType" name="java.util.Comparator access$4000()" map="K"/>
  <method class="DataType" name="java.util.Comparator access$2300()" map="L"/>
  <method class="DataType" name="java.util.Comparator access$2800()" map="M"/>
  <method class="DataType" name="DataType$Converter access$1100()" map="N"/>
  <method class="DataType" name="DataType$Converter access$3800()" map="O"/>
  <method class="DataType" name="DataType$Incrementer access$3100()" map="P"/>
  <method class="DataType" name="java.util.Comparator access$3200()" map="Q"/>
  <method class="DataType" name="java.util.Comparator access$3700()" map="R"/>
  <method class="DataType" name="java.util.Comparator access$2400()" map="S"/>
  <method class="DataType" name="java.util.Comparator access$2900()" map="T"/>
  <method class="DataType" name="DataType$Converter access$1800()" map="U"/>
  <method class="DataType" name="DataType$Converter access$1500()" map="V"/>
  <method class="DataType" name="DataType$Converter access$300()" map="W"/>
  <method class="DataType" name="java.util.Comparator access$2000()" map="X"/>
  <method class="DataType" name="DataType$Converter access$3300()" map="Y"/>
  <method class="DataType" name="java.util.Comparator access$3400()" map="Z"/>
  <method class="DataType" name="DataType$Incrementer access$2700()" map="_"/>
  <method class="DataType" name="java.util.Comparator access$3900()" map="a"/>
  <method class="DataType" name="DataType$Incrementer access$2500()" map="b"/>
  <method class="DataType" name="java.util.Comparator access$2600()" map="c"/>
  <method class="DataType" name="DataType$Converter access$1600()" map="d"/>
  <class name="Schema" map="A"/>
  <field class="Schema" name="lastRecordIndexPartitions" map="A"/>
  <field class="Schema" name="currRecordIndexPartitions" map="B"/>
  <field class="Schema" name="tables" map="C"/>
  <field class="Schema" name="schemaMutex" map="D"/>
  <field class="Schema" name="tablesById" map="E"/>
  <method class="Schema" name="void initRecordsById(int, int)" map="A"/>
  <method class="Schema" name="void addTable(TableSchema)" map="A"/>
  <method class="Schema" name="java.util.Map getTables()" map="A"/>
  <method class="Schema" name="RecordIndexPartition[] getRecordIndexPartitions()" map="B"/>
  <method class="Schema" name="void setTables(java.util.Map)" map="A"/>
  <method class="Schema" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="Schema" name="void reshardRecordIndex(RecordIndexPartition[])" map="A"/>
  <method class="Schema" name="void updateTable(TableSchema)" map="B"/>
  <method class="Schema" name="java.lang.Object getSchemaLock()" map="C"/>
  <method class="Schema" name="void deleteLastRecordIndex()" map="D"/>
  <method class="Schema" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="Schema" name="java.util.Map getTablesById()" map="E"/>
  <class name="RecordIndexPartition" map="B"/>
  <field class="RecordIndexPartition" name="shardOwning" map="A"/>
  <method class="RecordIndexPartition" name="int getShardOwning()" map="A"/>
  <method class="RecordIndexPartition" name="void setShardOwning(int)" map="A"/>
  <class name="IndexSchema" map="C"/>
  <field class="IndexSchema" name="comparators" map="A"/>
  <field class="IndexSchema" name="name" map="B"/>
  <field class="IndexSchema" name="currPartitions" map="C"/>
  <field class="IndexSchema" name="lastPartitions" map="D"/>
  <field class="IndexSchema" name="isPrimaryKeyGroup" map="E"/>
  <field class="IndexSchema" name="isPrimaryKey" map="F"/>
  <field class="IndexSchema" name="fields" map="G"/>
  <field class="IndexSchema" name="indexId" map="H"/>
  <field class="IndexSchema" name="isUnique" map="I"/>
  <method class="IndexSchema" name="boolean isUnique()" map="A"/>
  <method class="IndexSchema" name="void setFields(java.lang.String[])" map="A"/>
  <method class="IndexSchema" name="void setIndexId(int)" map="A"/>
  <method class="IndexSchema" name="void setComparators(java.util.Comparator[])" map="A"/>
  <method class="IndexSchema" name="boolean isPrimaryKey()" map="B"/>
  <method class="IndexSchema" name="int getIndexId()" map="C"/>
  <method class="IndexSchema" name="void setIsPrimaryKey(boolean)" map="A"/>
  <method class="IndexSchema" name="boolean isPrimaryKeyGroup()" map="D"/>
  <method class="IndexSchema" name="java.util.Comparator[] getComparators()" map="E"/>
  <method class="IndexSchema" name="void setName(java.lang.String)" map="A"/>
  <method class="IndexSchema" name="java.lang.String[] getFields()" map="F"/>
  <method class="IndexSchema" name="void setIsUnique(boolean)" map="B"/>
  <method class="IndexSchema" name="java.lang.String getName()" map="G"/>
  <method class="IndexSchema" name="void deleteLastPartitions()" map="H"/>
  <method class="IndexSchema" name="void setLastPartitions(TableSchema$Partition[])" map="A"/>
  <method class="IndexSchema" name="void setIsPrimaryKeyGroup(boolean)" map="C"/>
  <method class="IndexSchema" name="TableSchema$Partition[] getCurrPartitions()" map="I"/>
  <method class="IndexSchema" name="void reshardPartitions(java.util.List)" map="A"/>
  <method class="IndexSchema" name="void setCurrPartitions(TableSchema$Partition[])" map="B"/>
  <method class="IndexSchema" name="TableSchema$Partition[] getLastPartitions()" map="J"/>
  <field class="com.sonicbase.util.StreamUtils" name="DEFAULT_BUFFER_SIZE" map="A"/>
  <class name="com.sonicbase.util.SerializationHelper" map="A"/>
  <field class="com.sonicbase.util.JsonArray" name="logger" map="A"/>
  <field class="com.sonicbase.util.JsonArray" name="list" map="B"/>
  <field class="com.sonicbase.util.JsonDict" name="dict" map="A"/>
  <class name="com.sonicbase.util.DataUtil$ResultLength" map="_A"/>
  <field class="com.sonicbase.util.DataUtil$ResultLength" name="length" map="A"/>
  <method class="com.sonicbase.util.DataUtil$ResultLength" name="int access$002(com.sonicbase.util.DataUtil$ResultLength, int)" map="A"/>
  <method class="com.sonicbase.util.DataUtil$ResultLength" name="int getLength()" map="A"/>
  <method class="com.sonicbase.util.DataUtil$ResultLength" name="java.lang.String toString()" map="toString"/>
  <method class="com.sonicbase.util.DataUtil$ResultLength" name="void setLength(int)" map="A"/>
  <class name="com.sonicbase.util.DataUtil" map="B"/>
  <method class="com.sonicbase.util.DataUtil" name="void writeDouble(double, byte[], int)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="long readVLong(java.io.DataInput)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="float readFloat(byte[], int)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="void writeVLong(java.io.DataOutputStream, long)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="void writeFloat(float, byte[], int)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="long readVLong(java.io.DataInput, com.sonicbase.util.DataUtil$ResultLength)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="long readVLong(byte[], int, com.sonicbase.util.DataUtil$ResultLength)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="void writeVLong(java.io.DataOutput, long, com.sonicbase.util.DataUtil$ResultLength)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="void writeVLong(byte[], long, com.sonicbase.util.DataUtil$ResultLength)" map="A"/>
  <method class="com.sonicbase.util.DataUtil" name="double readDouble(byte[], int)" map="B"/>
  <package name="com.sonicbase.index" map="B"/>
  <class name="com.sonicbase.index.Repartitioner$MapEntry" map="_A"/>
  <field class="com.sonicbase.index.Repartitioner$MapEntry" name="key" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$MapEntry" name="value" map="B"/>
  <class name="com.sonicbase.index.Repartitioner$GetKeyAtOffset" map="_B"/>
  <method class="com.sonicbase.index.Repartitioner$GetKeyAtOffset" name="java.util.List getKeyAtOffset(java.lang.String, int, java.lang.String, java.lang.String, java.util.List)" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$MoveProcessor$1$1" map="1"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor$1$1" name="val$list" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor$1$1" name="this$2" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor$1$1" name="void run()" map="run"/>
  <class name="com.sonicbase.index.Repartitioner$MoveProcessor$1" map="1"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor$1" name="this$1" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor$1" name="void run()" map="run"/>
  <class name="com.sonicbase.index.Repartitioner$MoveProcessor" map="_C"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="countFinished" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="keysToDelete" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="shutdown" map="C"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="executor" map="D"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="this$0" map="E"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="countStarted" map="F"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="queue" map="G"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="isPrimaryKey" map="H"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="index" map="I"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="dbName" map="J"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="thread" map="K"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="tableName" map="L"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="indexName" map="M"/>
  <field class="com.sonicbase.index.Repartitioner$MoveProcessor" name="shard" map="N"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.lang.String access$800(com.sonicbase.index.Repartitioner$MoveProcessor)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.util.concurrent.atomic.AtomicInteger access$700(com.sonicbase.index.Repartitioner$MoveProcessor)" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.lang.String access$1000(com.sonicbase.index.Repartitioner$MoveProcessor)" map="C"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="void await()" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="com.sonicbase.index.Index access$1600(com.sonicbase.index.Repartitioner$MoveProcessor)" map="D"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="void shutdown()" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.util.concurrent.ConcurrentLinkedQueue access$1700(com.sonicbase.index.Repartitioner$MoveProcessor)" map="E"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="void start()" map="C"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.lang.String access$900(com.sonicbase.index.Repartitioner$MoveProcessor)" map="F"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="int access$1200(com.sonicbase.index.Repartitioner$MoveProcessor)" map="G"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.util.concurrent.ArrayBlockingQueue access$600(com.sonicbase.index.Repartitioner$MoveProcessor)" map="H"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.util.concurrent.ThreadPoolExecutor access$1900(com.sonicbase.index.Repartitioner$MoveProcessor)" map="I"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="java.util.concurrent.atomic.AtomicInteger access$1800(com.sonicbase.index.Repartitioner$MoveProcessor)" map="J"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="boolean access$500(com.sonicbase.index.Repartitioner$MoveProcessor)" map="K"/>
  <method class="com.sonicbase.index.Repartitioner$MoveProcessor" name="boolean access$1100(com.sonicbase.index.Repartitioner$MoveProcessor)" map="L"/>
  <class name="com.sonicbase.index.Repartitioner$MoveRequest" map="_D"/>
  <field class="com.sonicbase.index.Repartitioner$MoveRequest" name="key" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$MoveRequest" name="shouldDeleteNow" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$MoveRequest" name="content" map="C"/>
  <method class="com.sonicbase.index.Repartitioner$MoveRequest" name="byte[][] getContent()" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$MoveRequest" name="java.lang.Object[] getKey()" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$MoveRequest" name="boolean access$1400(com.sonicbase.index.Repartitioner$MoveRequest)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$MoveRequest" name="void setContent(byte[][])" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$MoveRequest" name="java.lang.Object[] access$1500(com.sonicbase.index.Repartitioner$MoveRequest)" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$MoveRequest" name="void setKey(java.lang.Object[])" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$TableIndexCounts" map="_E"/>
  <field class="com.sonicbase.index.Repartitioner$TableIndexCounts" name="indices" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$TableIndexCounts" name="java.util.concurrent.ConcurrentHashMap getIndices()" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$TableIndexCounts" name="java.util.concurrent.ConcurrentHashMap access$2300(com.sonicbase.index.Repartitioner$TableIndexCounts)" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$10" map="10"/>
  <field class="com.sonicbase.index.Repartitioner$10" name="val$ret" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$10" name="val$client" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$10" name="val$shard" map="C"/>
  <field class="com.sonicbase.index.Repartitioner$10" name="val$dbName" map="D"/>
  <method class="com.sonicbase.index.Repartitioner$10" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.index.Repartitioner$OffsetEntry" map="_F"/>
  <field class="com.sonicbase.index.Repartitioner$OffsetEntry" name="partitionOffset" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$OffsetEntry" name="offset" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$OffsetEntry" name="int getPartitionOffset()" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$OffsetEntry" name="long getOffset()" map="B"/>
  <class name="com.sonicbase.index.Repartitioner$9" map="9"/>
  <field class="com.sonicbase.index.Repartitioner$9" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$9" name="val$cobj" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$9" name="val$replica" map="C"/>
  <method class="com.sonicbase.index.Repartitioner$9" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.index.Repartitioner$8$1" map="1"/>
  <field class="com.sonicbase.index.Repartitioner$8$1" name="val$toProcess" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$8$1" name="this$1" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$8$1" name="void run()" map="run"/>
  <class name="com.sonicbase.index.Repartitioner$8" map="8"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$cobj" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$countVisited" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$dbName" map="C"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$countFinished" map="D"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$indexSchema" map="E"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$executor" map="F"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$tableName" map="G"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$indexName" map="H"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="this$0" map="I"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$tableSchema" map="J"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$fieldOffsets" map="K"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$index" map="L"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$currEntries" map="M"/>
  <field class="com.sonicbase.index.Repartitioner$8" name="val$countSubmitted" map="N"/>
  <method class="com.sonicbase.index.Repartitioner$8" name="boolean visit(java.lang.Object[], java.lang.Object)" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$7$1" map="1"/>
  <field class="com.sonicbase.index.Repartitioner$7$1" name="val$toProcess" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$7$1" name="this$1" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$7$1" name="void run()" map="run"/>
  <class name="com.sonicbase.index.Repartitioner$7" map="7"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$cobj" map="O"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$countVisited" map="P"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$dbName" map="Q"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$countFinished" map="R"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$indexSchema" map="S"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$executor" map="T"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$tableName" map="U"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$indexName" map="V"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="this$0" map="W"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$tableSchema" map="X"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$fieldOffsets" map="Y"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$index" map="Z"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$currEntries" map="_"/>
  <field class="com.sonicbase.index.Repartitioner$7" name="val$countSubmitted" map="a"/>
  <method class="com.sonicbase.index.Repartitioner$7" name="boolean visit(java.lang.Object[], java.lang.Object)" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$6" map="6"/>
  <field class="com.sonicbase.index.Repartitioner$6" name="val$tableName" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$6" name="val$entry" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$6" name="val$getKey" map="C"/>
  <field class="com.sonicbase.index.Repartitioner$6" name="val$indexName" map="D"/>
  <field class="com.sonicbase.index.Repartitioner$6" name="val$newPartitions" map="E"/>
  <field class="com.sonicbase.index.Repartitioner$6" name="val$dbName" map="F"/>
  <method class="com.sonicbase.index.Repartitioner$6" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.index.Repartitioner$5" map="5"/>
  <method class="com.sonicbase.index.Repartitioner$5" name="int compare(com.sonicbase.index.Repartitioner$OffsetEntry, com.sonicbase.index.Repartitioner$OffsetEntry)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$5" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Repartitioner$GlobalIndexCounts" map="_G"/>
  <field class="com.sonicbase.index.Repartitioner$GlobalIndexCounts" name="tables" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$GlobalIndexCounts" name="java.util.concurrent.ConcurrentHashMap access$2200(com.sonicbase.index.Repartitioner$GlobalIndexCounts)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$GlobalIndexCounts" name="java.util.concurrent.ConcurrentHashMap getTables()" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$4" map="4"/>
  <field class="com.sonicbase.index.Repartitioner$4" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$4" name="val$shard" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$4" name="val$finalTableName" map="C"/>
  <field class="com.sonicbase.index.Repartitioner$4" name="val$indexName" map="D"/>
  <field class="com.sonicbase.index.Repartitioner$4" name="val$dbName" map="E"/>
  <field class="com.sonicbase.index.Repartitioner$4" name="val$masters" map="F"/>
  <method class="com.sonicbase.index.Repartitioner$4" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.index.Repartitioner$3" map="3"/>
  <field class="com.sonicbase.index.Repartitioner$3" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$3" name="val$comparators" map="B"/>
  <method class="com.sonicbase.index.Repartitioner$3" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="com.sonicbase.index.Repartitioner$3" name="int compare(TableSchema$Partition, TableSchema$Partition)" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$2" map="2"/>
  <field class="com.sonicbase.index.Repartitioner$2" name="this$0" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$2" name="java.util.List getKeyAtOffset(java.lang.String, int, java.lang.String, java.lang.String, java.util.List)" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$IndexCounts" map="_H"/>
  <field class="com.sonicbase.index.Repartitioner$IndexCounts" name="counts" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$IndexCounts" name="java.util.concurrent.ConcurrentHashMap access$2400(com.sonicbase.index.Repartitioner$IndexCounts)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner$IndexCounts" name="java.util.concurrent.ConcurrentHashMap getCounts()" map="A"/>
  <class name="com.sonicbase.index.Repartitioner$1" map="1"/>
  <field class="com.sonicbase.index.Repartitioner$1" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Repartitioner$1" name="val$offset" map="B"/>
  <field class="com.sonicbase.index.Repartitioner$1" name="val$currPartitionSizes" map="C"/>
  <field class="com.sonicbase.index.Repartitioner$1" name="val$indexName" map="D"/>
  <field class="com.sonicbase.index.Repartitioner$1" name="val$dbName" map="E"/>
  <field class="com.sonicbase.index.Repartitioner$1" name="val$currTableName" map="F"/>
  <method class="com.sonicbase.index.Repartitioner$1" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.index.Repartitioner" map="A"/>
  <field class="com.sonicbase.index.Repartitioner" name="isRepartitioningIndex" map="A"/>
  <field class="com.sonicbase.index.Repartitioner" name="currIndexRepartitioning" map="B"/>
  <field class="com.sonicbase.index.Repartitioner" name="INDEX_STR" map="C"/>
  <field class="com.sonicbase.index.Repartitioner" name="indices" map="D"/>
  <field class="com.sonicbase.index.Repartitioner" name="isShardRepartitioningComplete" map="E"/>
  <field class="com.sonicbase.index.Repartitioner" name="isComplete" map="F"/>
  <field class="com.sonicbase.index.Repartitioner" name="minSizeForRepartition" map="G"/>
  <field class="com.sonicbase.index.Repartitioner" name="beginRepartitioningThread" map="H"/>
  <field class="com.sonicbase.index.Repartitioner" name="NAME_STR" map="I"/>
  <field class="com.sonicbase.index.Repartitioner" name="common" map="J"/>
  <field class="com.sonicbase.index.Repartitioner" name="isRebalancing" map="K"/>
  <field class="com.sonicbase.index.Repartitioner" name="tableToDeleteEntriesFrom" map="L"/>
  <field class="com.sonicbase.index.Repartitioner" name="entriesToDelete" map="M"/>
  <field class="com.sonicbase.index.Repartitioner" name="shutdown" map="N"/>
  <field class="com.sonicbase.index.Repartitioner" name="currTableRepartitioning" map="O"/>
  <field class="com.sonicbase.index.Repartitioner" name="deletingComplete" map="P"/>
  <field class="com.sonicbase.index.Repartitioner" name="databaseServer" map="Q"/>
  <field class="com.sonicbase.index.Repartitioner" name="repartitioningComplete" map="R"/>
  <field class="com.sonicbase.index.Repartitioner" name="repartitioningRecordsByIdComplete" map="S"/>
  <field class="com.sonicbase.index.Repartitioner" name="moveProcessors" map="T"/>
  <field class="com.sonicbase.index.Repartitioner" name="logger" map="U"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject doRebalanceOrderedIndex(ComObject)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject getIndexCounts(ComObject)" map="B"/>
  <method class="com.sonicbase.index.Repartitioner" name="void logPartitionsToApply(java.lang.String, java.lang.String, java.lang.String, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void deleteIndexEntry(java.lang.String, java.lang.String, java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void calculatePartitions(java.lang.String, int, java.util.List, java.lang.String, java.lang.String, long[], long, com.sonicbase.index.Repartitioner$GetKeyAtOffset)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void run()" map="run"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject beginRebalance(ComObject)" map="C"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject moveIndexEntries(ComObject)" map="D"/>
  <method class="com.sonicbase.index.Repartitioner" name="void access$2100(com.sonicbase.index.Repartitioner, com.sonicbase.index.Repartitioner$MoveProcessor[], java.lang.String, java.lang.String, java.util.List, com.sonicbase.index.Index, IndexSchema, java.lang.String, int[], TableSchema, ComObject)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void setMinSizeForRepartition(int)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="DatabaseCommon access$200(com.sonicbase.index.Repartitioner)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject getPartitionSize(ComObject)" map="E"/>
  <method class="com.sonicbase.index.Repartitioner" name="java.util.List findOrderedPartitionForRecord(boolean, boolean, int[], DatabaseCommon, TableSchema, java.lang.String, java.util.List, BinaryExpression$Operator, BinaryExpression$Operator, java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject isRepartitioningComplete(ComObject)" map="F"/>
  <method class="com.sonicbase.index.Repartitioner" name="boolean undeleteIndexEntry(java.lang.String, java.lang.String, java.lang.String, java.lang.Object[], byte[])" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void resetRepartitioningComplete()" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="com.sonicbase.index.Repartitioner$MoveProcessor[] access$2000(com.sonicbase.index.Repartitioner)" map="B"/>
  <method class="com.sonicbase.index.Repartitioner" name="void doSelectPartitions(TableSchema$Partition[], TableSchema, java.lang.String, BinaryExpression$Operator, java.util.Comparator[], java.lang.Object[], boolean, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="long getPartitionSize(java.lang.String, int, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="byte[] beginRebalance(java.lang.String, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject notifyRepartitioningComplete(ComObject)" map="G"/>
  <method class="com.sonicbase.index.Repartitioner" name="void deleteRecordsOnOtherReplicas(java.lang.String, java.lang.String, java.lang.String, java.util.concurrent.ConcurrentLinkedQueue)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject stopRepartitioning(ComObject)" map="H"/>
  <method class="com.sonicbase.index.Repartitioner" name="long access$000(com.sonicbase.index.Repartitioner, java.lang.String, int, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void stopShardsFromRepartitioning()" map="B"/>
  <method class="com.sonicbase.index.Repartitioner" name="java.util.concurrent.ConcurrentHashMap getIndicesToDeleteFrom(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject rebalanceOrderedIndex(ComObject)" map="I"/>
  <method class="com.sonicbase.index.Repartitioner" name="Logger access$400()" map="C"/>
  <method class="com.sonicbase.index.Repartitioner" name="java.util.List access$100(com.sonicbase.index.Repartitioner, java.lang.String, int, java.lang.String, java.lang.String, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="byte[] finishRebalance(java.lang.String, byte[])" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void logCurrPartitions(java.lang.String, java.lang.String, java.lang.String, TableSchema$Partition[])" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="com.sonicbase.server.DatabaseServer access$300(com.sonicbase.index.Repartitioner)" map="C"/>
  <method class="com.sonicbase.index.Repartitioner" name="int getCompareValue(java.util.Comparator[], java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject deleteMovedRecords(ComObject)" map="J"/>
  <method class="com.sonicbase.index.Repartitioner" name="void doSelectPartitions(TableSchema$Partition[], TableSchema, java.lang.String, BinaryExpression$Operator, java.util.Comparator[], java.lang.Object[], java.lang.Object[], boolean, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void moveIndexEntriesToShard(java.lang.String, java.lang.String, java.lang.String, boolean, int, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void resetDeletingComplete()" map="D"/>
  <method class="com.sonicbase.index.Repartitioner" name="boolean addToRebalance(java.util.List, java.util.Map$Entry, java.lang.String, com.sonicbase.index.Repartitioner$IndexCounts, boolean)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="java.util.List getKeyAtOffset(java.lang.String, int, java.lang.String, java.lang.String, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void shutdown()" map="E"/>
  <method class="com.sonicbase.index.Repartitioner" name="com.sonicbase.index.Repartitioner$GlobalIndexCounts getIndexCounts(java.lang.String, DatabaseClient)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject isShardRepartitioningComplete(ComObject, boolean)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="void access$1300(com.sonicbase.index.Repartitioner, java.lang.String, java.lang.String, java.lang.String, boolean, int, java.util.List)" map="A"/>
  <method class="com.sonicbase.index.Repartitioner" name="boolean isRepartitioningComplete()" map="F"/>
  <method class="com.sonicbase.index.Repartitioner" name="ComObject getKeyAtOffset(ComObject)" map="K"/>
  <method class="com.sonicbase.index.Repartitioner" name="void doProcessEntries(com.sonicbase.index.Repartitioner$MoveProcessor[], java.lang.String, java.lang.String, java.util.List, com.sonicbase.index.Index, IndexSchema, java.lang.String, int[], TableSchema, ComObject)" map="A"/>
  <class name="com.sonicbase.index.Indices" map="B"/>
  <field class="com.sonicbase.index.Indices" name="indexes" map="A"/>
  <method class="com.sonicbase.index.Indices" name="void addIndex(TableSchema, java.lang.String, java.util.Comparator[])" map="A"/>
  <method class="com.sonicbase.index.Indices" name="java.util.concurrent.ConcurrentHashMap getIndices()" map="A"/>
  <class name="com.sonicbase.index.Index$9" map="9"/>
  <field class="com.sonicbase.index.Index$9" name="this$0" map="b"/>
  <field class="com.sonicbase.index.Index$9" name="val$ret" map="c"/>
  <field class="com.sonicbase.index.Index$9" name="val$offsets" map="d"/>
  <field class="com.sonicbase.index.Index$9" name="val$curr" map="e"/>
  <field class="com.sonicbase.index.Index$9" name="val$currOffset" map="f"/>
  <field class="com.sonicbase.index.Index$9" name="val$maxKey" map="g"/>
  <method class="com.sonicbase.index.Index$9" name="boolean visit(java.lang.Object[], java.lang.Object)" map="A"/>
  <class name="com.sonicbase.index.Index$MyEntry" map="_A"/>
  <field class="com.sonicbase.index.Index$MyEntry" name="key" map="A"/>
  <field class="com.sonicbase.index.Index$MyEntry" name="value" map="B"/>
  <method class="com.sonicbase.index.Index$MyEntry" name="java.lang.Object getKey()" map="getKey"/>
  <method class="com.sonicbase.index.Index$MyEntry" name="java.lang.Object setValue(java.lang.Object)" map="setValue"/>
  <method class="com.sonicbase.index.Index$MyEntry" name="java.lang.Object getValue()" map="getValue"/>
  <class name="com.sonicbase.index.Index$8" map="8"/>
  <field class="com.sonicbase.index.Index$8" name="this$0" map="h"/>
  <field class="com.sonicbase.index.Index$8" name="val$currOffset" map="i"/>
  <field class="com.sonicbase.index.Index$8" name="val$maxKey" map="j"/>
  <method class="com.sonicbase.index.Index$8" name="boolean visit(java.lang.Object[], java.lang.Object)" map="A"/>
  <class name="com.sonicbase.index.Index$7" map="7"/>
  <field class="com.sonicbase.index.Index$7" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Index$7" name="val$comparators" map="B"/>
  <method class="com.sonicbase.index.Index$7" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index$7" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Index$6" map="6"/>
  <field class="com.sonicbase.index.Index$6" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Index$6" name="val$comparators" map="B"/>
  <method class="com.sonicbase.index.Index$6" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index$6" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Index$5" map="5"/>
  <field class="com.sonicbase.index.Index$5" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Index$5" name="val$comparators" map="B"/>
  <method class="com.sonicbase.index.Index$5" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index$5" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Index$4" map="4"/>
  <field class="com.sonicbase.index.Index$4" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Index$4" name="val$comparators" map="B"/>
  <method class="com.sonicbase.index.Index$4" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index$4" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Index$3" map="3"/>
  <field class="com.sonicbase.index.Index$3" name="this$0" map="A"/>
  <method class="com.sonicbase.index.Index$3" name="int compare(java.lang.Long, java.lang.Long)" map="A"/>
  <method class="com.sonicbase.index.Index$3" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Index$2" map="2"/>
  <field class="com.sonicbase.index.Index$2" name="this$0" map="A"/>
  <field class="com.sonicbase.index.Index$2" name="val$comparators" map="B"/>
  <method class="com.sonicbase.index.Index$2" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index$2" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Index$1" map="1"/>
  <method class="com.sonicbase.index.Index$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="com.sonicbase.index.Index$Visitor" map="_B"/>
  <method class="com.sonicbase.index.Index$Visitor" name="boolean visit(java.lang.Object[], java.lang.Object)" map="A"/>
  <class name="com.sonicbase.index.Index" map="C"/>
  <field class="com.sonicbase.index.Index" name="comparator" map="A"/>
  <field class="com.sonicbase.index.Index" name="comparators" map="B"/>
  <field class="com.sonicbase.index.Index" name="utf8Comparator" map="C"/>
  <field class="com.sonicbase.index.Index" name="fastUtil" map="D"/>
  <field class="com.sonicbase.index.Index" name="ordered" map="E"/>
  <field class="com.sonicbase.index.Index" name="mutexes" map="F"/>
  <field class="com.sonicbase.index.Index" name="longIndex" map="G"/>
  <field class="com.sonicbase.index.Index" name="objectIndex" map="H"/>
  <field class="com.sonicbase.index.Index" name="objectSkipIndex" map="I"/>
  <field class="com.sonicbase.index.Index" name="stringIndex" map="J"/>
  <field class="com.sonicbase.index.Index" name="logger" map="K"/>
  <field class="com.sonicbase.index.Index" name="size" map="L"/>
  <field class="com.sonicbase.index.Index" name="stringSkipIndex" map="M"/>
  <field class="com.sonicbase.index.Index" name="longSkipIndex" map="N"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry ceilingEntry(java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry higherEntry(java.lang.Object[])" map="B"/>
  <method class="com.sonicbase.index.Index" name="java.lang.Object remove(java.lang.Object[])" map="C"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry firstEntry()" map="A"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry floorEntry(java.lang.Object[])" map="D"/>
  <method class="com.sonicbase.index.Index" name="java.lang.Object getMutex(java.lang.Object[])" map="E"/>
  <method class="com.sonicbase.index.Index" name="java.lang.Iterable values()" map="B"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry lastEntry()" map="C"/>
  <method class="com.sonicbase.index.Index" name="java.util.Comparator[] getComparators()" map="D"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry lowerEntry(java.lang.Object[])" map="F"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry[] lowerEntries(java.lang.Object[], java.util.Map$Entry[])" map="A"/>
  <method class="com.sonicbase.index.Index" name="boolean visitHeadMap(java.lang.Object[], com.sonicbase.index.Index$Visitor)" map="A"/>
  <method class="com.sonicbase.index.Index" name="java.lang.Object unsafePutIfAbsent(java.lang.Object[], java.lang.Object)" map="A"/>
  <method class="com.sonicbase.index.Index" name="java.lang.Object get(java.lang.Object[])" map="G"/>
  <method class="com.sonicbase.index.Index" name="boolean visitTailMap(java.lang.Object[], com.sonicbase.index.Index$Visitor)" map="B"/>
  <method class="com.sonicbase.index.Index" name="long size()" map="E"/>
  <method class="com.sonicbase.index.Index" name="long getSize(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index" name="boolean iterate(com.sonicbase.index.Index$Visitor)" map="A"/>
  <method class="com.sonicbase.index.Index" name="java.util.List getKeyAtOffset(java.util.List, java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="com.sonicbase.index.Index" name="void clear()" map="F"/>
  <method class="com.sonicbase.index.Index" name="java.util.List equalsEntries(java.lang.Object[])" map="H"/>
  <method class="com.sonicbase.index.Index" name="java.util.Map$Entry[] higherEntries(java.lang.Object[], java.util.Map$Entry[])" map="B"/>
  <method class="com.sonicbase.index.Index" name="java.lang.Object put(java.lang.Object[], java.lang.Object)" map="B"/>
  <method class="com.sonicbase.index.Index" name="boolean isOrdered()" map="G"/>
  <class name="ExcludeRename" map="A"/>
  <method class="ExcludeRename" name="boolean exclude()" map="A"/>
  <method class="ExcludeRename" name="boolean applyToMembers()" map="B"/>
  <class name="Logger$1" map="1"/>
  <method class="Logger$1" name="void run()" map="run"/>
  <class name="Logger$Error" map="_A"/>
  <field class="Logger$Error" name="this$0" map="A"/>
  <field class="Logger$Error" name="client" map="B"/>
  <field class="Logger$Error" name="e" map="C"/>
  <field class="Logger$Error" name="msg" map="D"/>
  <class name="Logger" map="B"/>
  <field class="Logger" name="replica" map="A"/>
  <field class="Logger" name="hostName" map="B"/>
  <field class="Logger" name="databaseClient" map="C"/>
  <field class="Logger" name="sendThread" map="D"/>
  <field class="Logger" name="queue" map="E"/>
  <field class="Logger" name="ready" map="F"/>
  <field class="Logger" name="isClient" map="G"/>
  <field class="Logger" name="logger" map="H"/>
  <field class="Logger" name="shard" map="I"/>
  <method class="Logger" name="void warn(java.lang.String)" map="A"/>
  <method class="Logger" name="void error(java.lang.String, java.lang.Throwable)" map="A"/>
  <method class="Logger" name="void sendErrorToServer(java.lang.String, java.lang.Throwable)" map="B"/>
  <method class="Logger" name="void errorLocalOnly(java.lang.String, java.lang.Throwable)" map="C"/>
  <method class="Logger" name="void error(java.lang.String)" map="B"/>
  <method class="Logger" name="java.lang.String access$200()" map="A"/>
  <method class="Logger" name="boolean access$100()" map="B"/>
  <method class="Logger" name="void setIsClient(boolean)" map="A"/>
  <method class="Logger" name="org.apache.log4j.Logger access$300()" map="C"/>
  <method class="Logger" name="void setReady()" map="D"/>
  <method class="Logger" name="void info(java.lang.String)" map="C"/>
  <method class="Logger" name="java.util.concurrent.ArrayBlockingQueue access$000()" map="E"/>
  <class name="DatabaseCommon" map="C"/>
  <field class="DatabaseCommon" name="replica" map="A"/>
  <field class="DatabaseCommon" name="schemaReadWriteLock" map="B"/>
  <field class="DatabaseCommon" name="masterReplicas" map="C"/>
  <field class="DatabaseCommon" name="haveProLicense" map="D"/>
  <field class="DatabaseCommon" name="deadNodes" map="E"/>
  <field class="DatabaseCommon" name="schema" map="F"/>
  <field class="DatabaseCommon" name="schemaWriteLock" map="G"/>
  <field class="DatabaseCommon" name="schemaReadLock" map="H"/>
  <field class="DatabaseCommon" name="schemaVersion" map="I"/>
  <field class="DatabaseCommon" name="logger" map="J"/>
  <field class="DatabaseCommon" name="shard" map="K"/>
  <field class="DatabaseCommon" name="serversConfig" map="L"/>
  <method class="DatabaseCommon" name="int compareKey(java.util.Comparator[], java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="DatabaseCommon" name="Schema getSchema(java.lang.String)" map="A"/>
  <method class="DatabaseCommon" name="void setShard(int)" map="A"/>
  <method class="DatabaseCommon" name="void setSchema(java.lang.String, Schema)" map="A"/>
  <method class="DatabaseCommon" name="void saveServersConfig(java.lang.String)" map="B"/>
  <method class="DatabaseCommon" name="void deserializeConfig(byte[])" map="A"/>
  <method class="DatabaseCommon" name="byte[] serializeKey(TableSchema, java.lang.String, java.lang.Object[])" map="A"/>
  <method class="DatabaseCommon" name="void addTable(java.lang.String, java.lang.String, TableSchema)" map="A"/>
  <method class="DatabaseCommon" name="com.sonicbase.server.DatabaseServer$ServersConfig getServersConfig()" map="A"/>
  <method class="DatabaseCommon" name="java.util.Map getTables(java.lang.String)" map="C"/>
  <method class="DatabaseCommon" name="int getShard()" map="B"/>
  <method class="DatabaseCommon" name="boolean haveProLicense()" map="C"/>
  <method class="DatabaseCommon" name="void dropTable(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="DatabaseCommon" name="void serializeFields(java.lang.Object[], java.io.DataOutputStream, TableSchema, long, boolean)" map="A"/>
  <method class="DatabaseCommon" name="void deserializeSchema(java.io.DataInputStream)" map="A"/>
  <method class="DatabaseCommon" name="long getSchemaVersion()" map="D"/>
  <method class="DatabaseCommon" name="java.util.Map getTablesById(java.lang.String)" map="D"/>
  <method class="DatabaseCommon" name="int getReplica()" map="E"/>
  <method class="DatabaseCommon" name="void addDatabase(java.lang.String)" map="E"/>
  <method class="DatabaseCommon" name="void saveSchema(java.lang.String)" map="F"/>
  <method class="DatabaseCommon" name="byte[] serializeSchema(long)" map="A"/>
  <method class="DatabaseCommon" name="void setReplica(int)" map="B"/>
  <method class="DatabaseCommon" name="void serializeSchema(java.lang.String, java.io.DataOutputStream)" map="A"/>
  <method class="DatabaseCommon" name="java.lang.Object[] deserializeKey(TableSchema, java.io.DataInputStream)" map="A"/>
  <method class="DatabaseCommon" name="java.util.concurrent.locks.Lock getSchemaReadLock(java.lang.String)" map="G"/>
  <method class="DatabaseCommon" name="void loadSchema(java.lang.String)" map="H"/>
  <method class="DatabaseCommon" name="java.lang.Object[] deserializeKey(TableSchema, byte[])" map="A"/>
  <method class="DatabaseCommon" name="void createSchemaLocks(java.lang.String)" map="I"/>
  <method class="DatabaseCommon" name="byte[] serializeConfig(long)" map="B"/>
  <method class="DatabaseCommon" name="void deserializeSchema(byte[])" map="B"/>
  <method class="DatabaseCommon" name="java.lang.String keyToString(java.lang.Object[])" map="A"/>
  <method class="DatabaseCommon" name="java.util.concurrent.locks.Lock getSchemaWriteLock(java.lang.String)" map="J"/>
  <method class="DatabaseCommon" name="void setServersConfig(com.sonicbase.server.DatabaseServer$ServersConfig)" map="A"/>
  <method class="DatabaseCommon" name="java.lang.Object[] deserializeFields(java.lang.String, DatabaseCommon, byte[], int, TableSchema, long, java.util.Set, java.util.concurrent.atomic.AtomicLong, boolean)" map="A"/>
  <method class="DatabaseCommon" name="void deserializeConfig(java.io.DataInputStream)" map="B"/>
  <method class="DatabaseCommon" name="void serializeSchema(java.io.DataOutputStream, long)" map="A"/>
  <method class="DatabaseCommon" name="void setHaveProLicense(boolean)" map="A"/>
  <method class="DatabaseCommon" name="void updateTable(java.lang.String, java.lang.String, TableSchema)" map="B"/>
  <method class="DatabaseCommon" name="void loadServersConfig(java.lang.String)" map="K"/>
  <class name="QueryPlan" map="D"/>
  <field class="QueryPlan" name="expression" map="A"/>
  <class name="ComObject$DynamicType" map="_A"/>
  <field class="ComObject$DynamicType" name="tag" map="A"/>
  <class name="ComObject$Type" map="_B"/>
  <field class="ComObject$Type" name="objectType" map="A"/>
  <field class="ComObject$Type" name="byteArrayType" map="B"/>
  <field class="ComObject$Type" name="$VALUES" map="C"/>
  <field class="ComObject$Type" name="dateType" map="D"/>
  <field class="ComObject$Type" name="bigDecimalType" map="E"/>
  <field class="ComObject$Type" name="intType" map="F"/>
  <field class="ComObject$Type" name="timeStampType" map="G"/>
  <field class="ComObject$Type" name="arrayType" map="H"/>
  <field class="ComObject$Type" name="doubleType" map="I"/>
  <field class="ComObject$Type" name="booleanType" map="J"/>
  <field class="ComObject$Type" name="floatType" map="K"/>
  <field class="ComObject$Type" name="longType" map="L"/>
  <field class="ComObject$Type" name="smallIntType" map="M"/>
  <field class="ComObject$Type" name="stringType" map="N"/>
  <field class="ComObject$Type" name="tinyIntType" map="O"/>
  <field class="ComObject$Type" name="timeType" map="P"/>
  <field class="ComObject$Type" name="tag" map="Q"/>
  <method class="ComObject$Type" name="ComObject$Type[] values()" map="values"/>
  <method class="ComObject$Type" name="ComObject$Type valueOf(java.lang.String)" map="valueOf"/>
  <field class="ComObject$Tag" name="$VALUES" map="A"/>
  <class name="ComObject$DynamicTag" map="_C"/>
  <field class="ComObject$DynamicTag" name="tag" map="A"/>
  <field class="ComObject$DynamicTag" name="type" map="B"/>
  <method class="ComObject$DynamicTag" name="ComObject$DynamicType access$000(ComObject$DynamicTag)" map="A"/>
  <field class="ComObject" name="tagsByTag" map="A"/>
  <field class="ComObject" name="typesByTag" map="B"/>
  <field class="ComObject" name="map" map="C"/>
  <class name="Record" map="E"/>
  <field class="Record" name="transId" map="A"/>
  <field class="Record" name="id" map="B"/>
  <field class="Record" name="DB_VIEW_FLAG_DELETING" map="C"/>
  <field class="Record" name="serializedSchemaVersion" map="D"/>
  <field class="Record" name="fields" map="E"/>
  <field class="Record" name="sequence2" map="F"/>
  <field class="Record" name="sequence1" map="G"/>
  <field class="Record" name="DB_VIEW_FLAG_ADDING" map="H"/>
  <field class="Record" name="sequence0" map="I"/>
  <field class="Record" name="dbViewNumber" map="J"/>
  <field class="Record" name="dbViewFlags" map="K"/>
  <field class="Record" name="tableSchema" map="L"/>
  <method class="Record" name="void setSequence0(long)" map="A"/>
  <method class="Record" name="long getDbViewNumber()" map="A"/>
  <method class="Record" name="void deserialize(java.lang.String, DatabaseCommon, byte[], java.util.Set, boolean)" map="A"/>
  <method class="Record" name="long getSerializedSchemaVersion()" map="B"/>
  <method class="Record" name="long getTableId(byte[])" map="A"/>
  <method class="Record" name="void setDbViewFlags(long)" map="B"/>
  <method class="Record" name="void recoverFromSnapshot(java.lang.String, DatabaseCommon, byte[], int, java.util.Set, boolean)" map="A"/>
  <method class="Record" name="void setTransId(long)" map="C"/>
  <method class="Record" name="void setId(long)" map="D"/>
  <method class="Record" name="long getDbViewFlags()" map="C"/>
  <method class="Record" name="long getDbViewNumber(byte[])" map="B"/>
  <method class="Record" name="void setSequence2(long)" map="E"/>
  <method class="Record" name="void deserialize(java.lang.String, DatabaseCommon, byte[], java.util.Set)" map="A"/>
  <method class="Record" name="long getDbViewFlags(byte[])" map="C"/>
  <method class="Record" name="void setDbViewNumber(long)" map="F"/>
  <method class="Record" name="java.lang.Object getField(java.lang.String)" map="A"/>
  <method class="Record" name="void snapshot(java.io.DataOutputStream, DatabaseCommon)" map="A"/>
  <method class="Record" name="long getSequence0()" map="D"/>
  <method class="Record" name="long getId()" map="E"/>
  <method class="Record" name="long getSequence1()" map="F"/>
  <method class="Record" name="void setSequence1(long)" map="G"/>
  <method class="Record" name="long readFlags(byte[])" map="D"/>
  <method class="Record" name="java.lang.Object[] getFields()" map="G"/>
  <method class="Record" name="void setFields(java.lang.Object[])" map="A"/>
  <method class="Record" name="long getSequence2()" map="H"/>
  <method class="Record" name="long getTransId(byte[])" map="E"/>
  <method class="Record" name="byte[] serialize(DatabaseCommon)" map="A"/>
  <method class="Record" name="long getTransId()" map="I"/>
  <method class="Record" name="TableSchema getTableSchema()" map="J"/>
  <class name="InsufficientLicense" map="F"/>
  <field class="ComArray" name="nestedType" map="A"/>
  <field class="ComArray" name="array" map="B"/>
  <method class="ComArray" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <class name="com.sonicbase.common.AWSClient$2" map="2"/>
  <field class="com.sonicbase.common.AWSClient$2" name="this$0" map="A"/>
  <field class="com.sonicbase.common.AWSClient$2" name="val$destFile" map="B"/>
  <field class="com.sonicbase.common.AWSClient$2" name="val$bucket" map="C"/>
  <field class="com.sonicbase.common.AWSClient$2" name="val$finalKey" map="D"/>
  <method class="com.sonicbase.common.AWSClient$2" name="void run()" map="run"/>
  <class name="com.sonicbase.common.AWSClient$1" map="1"/>
  <field class="com.sonicbase.common.AWSClient$1" name="this$0" map="A"/>
  <field class="com.sonicbase.common.AWSClient$1" name="val$bucket" map="B"/>
  <field class="com.sonicbase.common.AWSClient$1" name="val$file" map="C"/>
  <field class="com.sonicbase.common.AWSClient$1" name="val$path" map="D"/>
  <field class="com.sonicbase.common.AWSClient$1" name="val$prefix" map="E"/>
  <method class="com.sonicbase.common.AWSClient$1" name="java.lang.Object call()" map="call"/>
  <class name="com.sonicbase.common.AWSClient" map="G"/>
  <field class="com.sonicbase.common.AWSClient" name="client" map="A"/>
  <field class="com.sonicbase.common.AWSClient" name="logger" map="B"/>
  <field class="com.sonicbase.common.AWSClient" name="installDir" map="C"/>
  <field class="com.sonicbase.common.AWSClient" name="executor" map="D"/>
  <method class="com.sonicbase.common.AWSClient" name="void uploadDirectory(java.lang.String, java.lang.String, java.lang.String, java.io.File)" map="A"/>
  <method class="com.sonicbase.common.AWSClient" name="com.sonicbase.util.JsonDict getConfig()" map="A"/>
  <method class="com.sonicbase.common.AWSClient" name="void downloadFile(java.lang.String, java.lang.String, java.lang.String, java.io.File)" map="B"/>
  <method class="com.sonicbase.common.AWSClient" name="Logger access$000(com.sonicbase.common.AWSClient)" map="A"/>
  <method class="com.sonicbase.common.AWSClient" name="java.util.List listDirectSubdirectories(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.sonicbase.common.AWSClient" name="void deleteDirectory(java.lang.String, java.lang.String)" map="B"/>
  <method class="com.sonicbase.common.AWSClient" name="com.amazonaws.services.s3.transfer.TransferManager getTransferManager()" map="B"/>
  <method class="com.sonicbase.common.AWSClient" name="void downloadFile(java.lang.String, java.lang.String, java.io.File)" map="A"/>
  <method class="com.sonicbase.common.AWSClient" name="void downloadDirectory(java.lang.String, java.lang.String, java.lang.String, java.io.File)" map="C"/>
  <method class="com.sonicbase.common.AWSClient" name="com.amazonaws.services.s3.AmazonS3 getS3Client()" map="C"/>
  <method class="com.sonicbase.common.AWSClient" name="java.io.File getInstallDir()" map="D"/>
  <method class="com.sonicbase.common.AWSClient" name="byte[] downloadBytes(java.lang.String, java.lang.String)" map="C"/>
  <method class="com.sonicbase.common.AWSClient" name="void uploadFile(java.lang.String, java.lang.String, java.lang.String, java.io.File)" map="D"/>
  <package name="com.sonicbase.test" map="C"/>
  <class name="com.sonicbase.test.TestAWSBackup" map="A"/>
  <field class="com.sonicbase.test.TestAWSBackup" name="client" map="A"/>
  <field class="com.sonicbase.test.TestAWSBackup" name="ids" map="B"/>
  <field class="com.sonicbase.test.TestAWSBackup" name="recordCount" map="C"/>
  <field class="com.sonicbase.test.TestAWSBackup" name="conn" map="D"/>
  <method class="com.sonicbase.test.TestAWSBackup" name="void assertTrue(boolean)" map="A"/>
  <method class="com.sonicbase.test.TestAWSBackup" name="void main(java.lang.String[])" map="A"/>
  <method class="com.sonicbase.test.TestAWSBackup" name="void verifyData()" map="A"/>
  <method class="com.sonicbase.test.TestAWSBackup" name="void assertEquals(int, int)" map="A"/>
  <method class="com.sonicbase.test.TestAWSBackup" name="void assertEquals(long, long)" map="A"/>
  <class name="InsertStatementImpl" map="A"/>
  <field class="InsertStatementImpl" name="client" map="B"/>
  <field class="InsertStatementImpl" name="values" map="C"/>
  <field class="InsertStatementImpl" name="tableName" map="D"/>
  <field class="InsertStatementImpl" name="columnNames" map="E"/>
  <method class="InsertStatementImpl" name="void setTableName(java.lang.String)" map="B"/>
  <method class="InsertStatementImpl" name="java.lang.String getTableName()" map="C"/>
  <method class="InsertStatementImpl" name="void addValue(java.lang.String, java.lang.Object)" map="A"/>
  <method class="InsertStatementImpl" name="java.util.List getValues()" map="D"/>
  <method class="InsertStatementImpl" name="void setValues(java.util.List)" map="A"/>
  <method class="InsertStatementImpl" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <method class="InsertStatementImpl" name="java.util.List getColumns()" map="E"/>
  <class name="CreateIndexStatementImpl" map="B"/>
  <field class="CreateIndexStatementImpl" name="client" map="A"/>
  <field class="CreateIndexStatementImpl" name="tableName" map="B"/>
  <field class="CreateIndexStatementImpl" name="name" map="C"/>
  <field class="CreateIndexStatementImpl" name="columns" map="D"/>
  <field class="CreateIndexStatementImpl" name="isUnique" map="E"/>
  <method class="CreateIndexStatementImpl" name="void setTableName(java.lang.String)" map="A"/>
  <method class="CreateIndexStatementImpl" name="void setName(java.lang.String)" map="B"/>
  <method class="CreateIndexStatementImpl" name="java.lang.String getTableName()" map="A"/>
  <method class="CreateIndexStatementImpl" name="int execute(java.lang.String)" map="C"/>
  <method class="CreateIndexStatementImpl" name="boolean isUnique()" map="B"/>
  <method class="CreateIndexStatementImpl" name="java.lang.String getName()" map="C"/>
  <method class="CreateIndexStatementImpl" name="void setColumns(java.util.List)" map="A"/>
  <method class="CreateIndexStatementImpl" name="java.util.List getColumns()" map="D"/>
  <method class="CreateIndexStatementImpl" name="void setIsUnique(boolean)" map="A"/>
  <class name="Blob" map="C"/>
  <field class="Blob" name="data" map="A"/>
  <method class="Blob" name="java.io.InputStream getBinaryStream(long, long)" map="getBinaryStream"/>
  <method class="Blob" name="byte[] getData()" map="A"/>
  <method class="Blob" name="int setBytes(long, byte[])" map="setBytes"/>
  <method class="Blob" name="int setBytes(long, byte[], int, int)" map="setBytes"/>
  <method class="Blob" name="java.io.OutputStream setBinaryStream(long)" map="setBinaryStream"/>
  <method class="Blob" name="java.io.InputStream getBinaryStream()" map="getBinaryStream"/>
  <method class="Blob" name="long position(byte[], long)" map="position"/>
  <method class="Blob" name="long length()" map="length"/>
  <method class="Blob" name="byte[] getBytes(long, int)" map="getBytes"/>
  <method class="Blob" name="void free()" map="free"/>
  <method class="Blob" name="long position(java.sql.Blob, long)" map="position"/>
  <method class="Blob" name="void setData(byte[])" map="A"/>
  <method class="Blob" name="void truncate(long)" map="truncate"/>
  <class name="AllRecordsExpressionImpl" map="D"/>
  <field class="AllRecordsExpressionImpl" name="fromTable" map="Z"/>
  <method class="AllRecordsExpressionImpl" name="void queryRewrite()" map="L"/>
  <method class="AllRecordsExpressionImpl" name="boolean canUseIndex()" map="I"/>
  <method class="AllRecordsExpressionImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="AllRecordsExpressionImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="AllRecordsExpressionImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="AllRecordsExpressionImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="AllRecordsExpressionImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <method class="AllRecordsExpressionImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="AllRecordsExpressionImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="AllRecordsExpressionImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="AllRecordsExpressionImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="AllRecordsExpressionImpl" name="java.lang.String getFromTable()" map="Y"/>
  <method class="AllRecordsExpressionImpl" name="java.lang.String toString()" map="toString"/>
  <method class="AllRecordsExpressionImpl" name="void setFromTable(java.lang.String)" map="D"/>
  <class name="Clob" map="E"/>
  <field class="Clob" name="data" map="A"/>
  <method class="Clob" name="java.io.InputStream getAsciiStream()" map="getAsciiStream"/>
  <method class="Clob" name="java.lang.String getSubString(long, int)" map="getSubString"/>
  <method class="Clob" name="java.io.Reader getCharacterStream()" map="getCharacterStream"/>
  <method class="Clob" name="long position(java.lang.String, long)" map="position"/>
  <method class="Clob" name="java.io.Reader getCharacterStream(long, long)" map="getCharacterStream"/>
  <method class="Clob" name="int setString(long, java.lang.String)" map="setString"/>
  <method class="Clob" name="java.io.Writer setCharacterStream(long)" map="setCharacterStream"/>
  <method class="Clob" name="java.lang.String getString()" map="A"/>
  <method class="Clob" name="long position(java.sql.Clob, long)" map="position"/>
  <method class="Clob" name="long length()" map="length"/>
  <method class="Clob" name="void free()" map="free"/>
  <method class="Clob" name="void truncate(long)" map="truncate"/>
  <method class="Clob" name="int setString(long, java.lang.String, int, int)" map="setString"/>
  <method class="Clob" name="java.io.OutputStream setAsciiStream(long)" map="setAsciiStream"/>
  <class name="WrongTableException" map="F"/>
  <class name="ParameterImpl" map="G"/>
  <field class="ParameterImpl" name="parmOffset" map="_"/>
  <field class="ParameterImpl" name="parmName" map="a"/>
  <method class="ParameterImpl" name="void queryRewrite()" map="L"/>
  <method class="ParameterImpl" name="boolean canUseIndex()" map="I"/>
  <method class="ParameterImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="ParameterImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="ParameterImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="ParameterImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="ParameterImpl" name="void setParmOffset(int)" map="B"/>
  <method class="ParameterImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <method class="ParameterImpl" name="void setParmName(java.lang.String)" map="E"/>
  <method class="ParameterImpl" name="java.lang.String getParmName()" map="Z"/>
  <method class="ParameterImpl" name="int getParmOffset()" map="_"/>
  <method class="ParameterImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="ParameterImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="ParameterImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="ParameterImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="ParameterImpl" name="java.lang.String toString()" map="toString"/>
  <class name="BinaryExpressionImpl$1" map="1"/>
  <field class="BinaryExpressionImpl$1" name="this$0" map="A"/>
  <field class="BinaryExpressionImpl$1" name="val$retIds" map="B"/>
  <field class="BinaryExpressionImpl$1" name="val$tableSchema" map="C"/>
  <field class="BinaryExpressionImpl$1" name="val$currBatch" map="D"/>
  <field class="BinaryExpressionImpl$1" name="val$tableNames" map="E"/>
  <method class="BinaryExpressionImpl$1" name="java.lang.Object call()" map="call"/>
  <class name="BinaryExpressionImpl" map="H"/>
  <field class="BinaryExpressionImpl" name="rewroteQuery" map="c"/>
  <field class="BinaryExpressionImpl" name="originalRightValue" map="d"/>
  <field class="BinaryExpressionImpl" name="rightExpression" map="e"/>
  <field class="BinaryExpressionImpl" name="operator" map="f"/>
  <field class="BinaryExpressionImpl" name="originalLeftValue" map="g"/>
  <field class="BinaryExpressionImpl" name="isNot" map="h"/>
  <field class="BinaryExpressionImpl" name="columnName" map="i"/>
  <field class="BinaryExpressionImpl" name="exhausted" map="j"/>
  <field class="BinaryExpressionImpl" name="leftExpression" map="k"/>
  <field class="BinaryExpressionImpl" name="indexName" map="l"/>
  <method class="BinaryExpressionImpl" name="boolean isNot()" map="c"/>
  <method class="BinaryExpressionImpl" name="void setOperator(BinaryExpression$Operator)" map="A"/>
  <method class="BinaryExpressionImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="BinaryExpressionImpl" name="void doQueryRewrite()" map="d"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl$NextReturn evaluateOneSidedIndex(java.lang.String[], int, ExpressionImpl, ExpressionImpl, java.lang.String, BinaryExpression$Operator, java.lang.Object, java.lang.String, BinaryExpression$Operator, java.lang.Object, SelectStatementImpl$Explain)" map="A"/>
  <method class="BinaryExpressionImpl" name="void queryRewrite()" map="L"/>
  <method class="BinaryExpressionImpl" name="void setParms(ParameterHandler)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setTableName(java.lang.String)" map="B"/>
  <method class="BinaryExpressionImpl" name="void setDebug(boolean)" map="A"/>
  <method class="BinaryExpressionImpl" name="void getMostUsedIndex(java.util.Map, ExpressionImpl)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setTopLevelExpression(Expression)" map="A"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl getRightExpression()" map="e"/>
  <method class="BinaryExpressionImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setCounters(Counter[])" map="A"/>
  <method class="BinaryExpressionImpl" name="void extractAndExpressions(java.lang.String, java.util.List, java.util.List, ExpressionImpl)" map="A"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl buildQueryTree(java.util.List)" map="D"/>
  <method class="BinaryExpressionImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="BinaryExpressionImpl" name="java.lang.Object[] makeSingleKeyExpression(java.lang.String, java.lang.String, java.util.List, BinaryExpression$Operator, java.lang.String, java.util.List, BinaryExpression$Operator)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setLimit(net.sf.jsqlparser.statement.select.Limit)" map="A"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl$NextReturn evaluateAndExpression(int, java.util.concurrent.atomic.AtomicReference, SelectStatementImpl$Explain)" map="A"/>
  <method class="BinaryExpressionImpl" name="int getAndOrCount(ExpressionImpl)" map="B"/>
  <method class="BinaryExpressionImpl" name="void setNot(boolean)" map="C"/>
  <method class="BinaryExpressionImpl" name="void setLeftExpression(Expression)" map="B"/>
  <method class="BinaryExpressionImpl" name="void setOrderByExpressions(java.util.List)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setDbName(java.lang.String)" map="C"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl$NextReturn evaluateRelationalOp(int, java.util.concurrent.atomic.AtomicReference, SelectStatementImpl$Explain)" map="B"/>
  <method class="BinaryExpressionImpl" name="void access$000(BinaryExpressionImpl, java.util.List, java.lang.String, TableSchema, java.util.List)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setRightExpression(Expression)" map="C"/>
  <method class="BinaryExpressionImpl" name="java.lang.String toString()" map="toString"/>
  <method class="BinaryExpressionImpl" name="BinaryExpression$Operator getOperator()" map="f"/>
  <method class="BinaryExpressionImpl" name="void reset()" map="Q"/>
  <method class="BinaryExpressionImpl" name="void setGroupByContext(GroupByContext)" map="A"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <method class="BinaryExpressionImpl" name="java.lang.String isIndexed(ExpressionImpl, java.util.concurrent.atomic.AtomicBoolean)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setColumns(java.util.List)" map="B"/>
  <method class="BinaryExpressionImpl" name="boolean isColumnCompare(ExpressionImpl)" map="C"/>
  <method class="BinaryExpressionImpl" name="void setViewVersion(long)" map="B"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="BinaryExpressionImpl" name="void getColumnsInExpression(java.util.List)" map="C"/>
  <method class="BinaryExpressionImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="BinaryExpressionImpl" name="boolean canUseIndex()" map="I"/>
  <method class="BinaryExpressionImpl" name="void setReplica(java.lang.Integer)" map="A"/>
  <method class="BinaryExpressionImpl" name="void forceSelectOnServer(boolean)" map="B"/>
  <method class="BinaryExpressionImpl" name="void setClient(DatabaseClient)" map="B"/>
  <method class="BinaryExpressionImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl getLeftExpression()" map="g"/>
  <method class="BinaryExpressionImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl$NextReturn evaluateOrExpression(int, SelectStatementImpl$Explain)" map="B"/>
  <method class="BinaryExpressionImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="BinaryExpressionImpl" name="Expression getRightExpression()" map="b"/>
  <method class="BinaryExpressionImpl" name="void processBatch(java.util.List, java.lang.String, TableSchema, java.util.List)" map="A"/>
  <method class="BinaryExpressionImpl" name="Expression getLeftExpression()" map="a"/>
  <method class="BinaryExpressionImpl" name="boolean like(java.lang.String, java.lang.String)" map="A"/>
  <method class="BinaryExpressionImpl" name="void setRecordCache(ExpressionImpl$RecordCache)" map="A"/>
  <class name="NClob" map="I"/>
  <class name="SelectContextImpl" map="J"/>
  <field class="SelectContextImpl" name="tableNames" map="A"/>
  <field class="SelectContextImpl" name="currKeys" map="B"/>
  <field class="SelectContextImpl" name="operator" map="C"/>
  <field class="SelectContextImpl" name="selectStatement" map="D"/>
  <field class="SelectContextImpl" name="lastKeys" map="E"/>
  <field class="SelectContextImpl" name="nextKey" map="F"/>
  <field class="SelectContextImpl" name="indexName" map="G"/>
  <field class="SelectContextImpl" name="nextShard" map="H"/>
  <field class="SelectContextImpl" name="recordCache" map="I"/>
  <field class="SelectContextImpl" name="sortWithIndex" map="J"/>
  <method class="SelectContextImpl" name="java.lang.Object[] getNextKey()" map="A"/>
  <method class="SelectContextImpl" name="void setNextShard(int)" map="A"/>
  <method class="SelectContextImpl" name="void setOperator(BinaryExpression$Operator)" map="A"/>
  <method class="SelectContextImpl" name="void setNextKey(java.lang.Object[])" map="A"/>
  <method class="SelectContextImpl" name="void setCurrKeys(java.lang.Object[][][])" map="A"/>
  <method class="SelectContextImpl" name="int getNextShard()" map="B"/>
  <method class="SelectContextImpl" name="ExpressionImpl$RecordCache getRecordCache()" map="C"/>
  <method class="SelectContextImpl" name="void setRecordCache(ExpressionImpl$RecordCache)" map="A"/>
  <method class="SelectContextImpl" name="java.lang.Object[][][] getLastKeys()" map="D"/>
  <method class="SelectContextImpl" name="java.lang.Boolean getSortWithIndex()" map="E"/>
  <method class="SelectContextImpl" name="SelectStatementImpl getSelectStatement()" map="F"/>
  <method class="SelectContextImpl" name="void setSortWithIndex(java.lang.Boolean)" map="A"/>
  <method class="SelectContextImpl" name="java.lang.String getIndexName()" map="G"/>
  <method class="SelectContextImpl" name="BinaryExpression$Operator getOperator()" map="H"/>
  <method class="SelectContextImpl" name="java.lang.String[] getTableNames()" map="I"/>
  <method class="SelectContextImpl" name="java.lang.Object[][][] getCurrKeys()" map="J"/>
  <class name="CreateTableStatementImpl" map="K"/>
  <field class="CreateTableStatementImpl" name="fields" map="A"/>
  <field class="CreateTableStatementImpl" name="client" map="B"/>
  <field class="CreateTableStatementImpl" name="primaryKey" map="C"/>
  <field class="CreateTableStatementImpl" name="tableName" map="D"/>
  <method class="CreateTableStatementImpl" name="void setTableName(java.lang.String)" map="A"/>
  <method class="CreateTableStatementImpl" name="java.util.List getPrimaryKey()" map="A"/>
  <method class="CreateTableStatementImpl" name="void setPrimaryKey(java.util.List)" map="A"/>
  <method class="CreateTableStatementImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="CreateTableStatementImpl" name="int execute(java.lang.String)" map="B"/>
  <method class="CreateTableStatementImpl" name="void addField(java.lang.String, int)" map="A"/>
  <method class="CreateTableStatementImpl" name="java.util.List getFields()" map="B"/>
  <method class="CreateTableStatementImpl" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="CreateTableStatementImpl" name="byte[] serialize()" map="C"/>
  <method class="CreateTableStatementImpl" name="java.lang.String getTablename()" map="D"/>
  <method class="CreateTableStatementImpl" name="void setFields(java.util.List)" map="B"/>
  <method class="CreateTableStatementImpl" name="void deserialize(byte[])" map="A"/>
  <class name="ResultSetImpl$1" map="1"/>
  <field class="ResultSetImpl$1" name="val$tableOffsets" map="A"/>
  <field class="ResultSetImpl$1" name="val$comparators" map="B"/>
  <field class="ResultSetImpl$1" name="val$fieldOffsets" map="C"/>
  <field class="ResultSetImpl$1" name="val$ascendingFlags" map="D"/>
  <method class="ResultSetImpl$1" name="int compare(ExpressionImpl$CachedRecord[], ExpressionImpl$CachedRecord[])" map="A"/>
  <method class="ResultSetImpl$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="ResultSetImpl$MultiTableRecordList" map="_A"/>
  <field class="ResultSetImpl$MultiTableRecordList" name="tableNames" map="A"/>
  <field class="ResultSetImpl$MultiTableRecordList" name="ids" map="B"/>
  <method class="ResultSetImpl$MultiTableRecordList" name="void setIds(long[][])" map="A"/>
  <method class="ResultSetImpl$MultiTableRecordList" name="long[][] getIds()" map="A"/>
  <method class="ResultSetImpl$MultiTableRecordList" name="void setTableNames(java.lang.String[])" map="A"/>
  <method class="ResultSetImpl$MultiTableRecordList" name="java.lang.String[] getTableNames()" map="B"/>
  <field class="ResultSetImpl" name="groupByContext" map="A"/>
  <field class="ResultSetImpl" name="readRecords" map="B"/>
  <field class="ResultSetImpl" name="uniqueRecords" map="C"/>
  <field class="ResultSetImpl" name="columns" map="D"/>
  <field class="ResultSetImpl" name="LENGTH_STR" map="E"/>
  <field class="ResultSetImpl" name="selectStatement" map="F"/>
  <field class="ResultSetImpl" name="parms" map="G"/>
  <field class="ResultSetImpl" name="offset" map="H"/>
  <field class="ResultSetImpl" name="databaseClient" map="I"/>
  <field class="ResultSetImpl" name="count" map="J"/>
  <field class="ResultSetImpl" name="recordCache" map="K"/>
  <field class="ResultSetImpl" name="currPos" map="L"/>
  <field class="ResultSetImpl" name="indexUsed" map="M"/>
  <field class="ResultSetImpl" name="mapResults" map="N"/>
  <field class="ResultSetImpl" name="currTotalPos" map="O"/>
  <field class="ResultSetImpl" name="isCount" map="P"/>
  <field class="ResultSetImpl" name="lastReadRecords" map="Q"/>
  <field class="ResultSetImpl" name="counters" map="R"/>
  <field class="ResultSetImpl" name="selectContext" map="S"/>
  <field class="ResultSetImpl" name="describeStrs" map="T"/>
  <field class="ResultSetImpl" name="limit" map="U"/>
  <field class="ResultSetImpl" name="pageSize" map="V"/>
  <field class="ResultSetImpl" name="currRecord" map="W"/>
  <field class="ResultSetImpl" name="dbName" map="X"/>
  <field class="ResultSetImpl" name="UTF8_STR" map="Y"/>
  <field class="ResultSetImpl" name="groupByColumns" map="Z"/>
  <method class="ResultSetImpl" name="java.lang.String[] getActualColumn(java.lang.String)" map="A"/>
  <method class="ResultSetImpl" name="java.lang.String getString(java.lang.Object)" map="A"/>
  <method class="ResultSetImpl" name="java.math.BigDecimal getBigDecimal(java.lang.Object, int)" map="A"/>
  <method class="ResultSetImpl" name="Record doReadRecord(java.lang.Object[], java.lang.String)" map="A"/>
  <method class="ResultSetImpl" name="ExpressionImpl$CachedRecord[][] readRecords(ExpressionImpl$NextReturn)" map="A"/>
  <method class="ResultSetImpl" name="java.lang.Double getDouble(java.lang.Object, SelectStatementImpl$Function)" map="A"/>
  <method class="ResultSetImpl" name="java.lang.Object getCounterValue(SelectStatementImpl$Function)" map="A"/>
  <method class="ResultSetImpl" name="void getMoreServerResults(SelectStatementImpl)" map="A"/>
  <method class="ResultSetImpl" name="boolean isMatchingAlias(java.lang.String)" map="B"/>
  <method class="ResultSetImpl" name="java.lang.Object getField(java.lang.String[])" map="A"/>
  <method class="ResultSetImpl" name="java.lang.Float getFloat(java.lang.Object, SelectStatementImpl$Function)" map="B"/>
  <method class="ResultSetImpl" name="java.lang.Byte getByte(java.lang.Object, java.lang.String)" map="A"/>
  <method class="ResultSetImpl" name="java.lang.Integer getInt(java.lang.Object, SelectStatementImpl$Function)" map="C"/>
  <method class="ResultSetImpl" name="java.lang.Boolean getBoolean(java.lang.Object)" map="B"/>
  <method class="ResultSetImpl" name="java.lang.Long getLong(java.lang.Object, SelectStatementImpl$Function)" map="D"/>
  <method class="ResultSetImpl" name="java.lang.Short getShort(java.lang.Object, java.lang.String)" map="B"/>
  <class name="OrderByExpressionImpl" map="L"/>
  <field class="OrderByExpressionImpl" name="columnName" map="A"/>
  <field class="OrderByExpressionImpl" name="tableName" map="B"/>
  <field class="OrderByExpressionImpl" name="isAscending" map="C"/>
  <method class="OrderByExpressionImpl" name="void setTableName(java.lang.String)" map="A"/>
  <method class="OrderByExpressionImpl" name="void setAscending(boolean)" map="A"/>
  <method class="OrderByExpressionImpl" name="void setColumnName(java.lang.String)" map="B"/>
  <method class="OrderByExpressionImpl" name="boolean isAscending()" map="A"/>
  <method class="OrderByExpressionImpl" name="java.lang.String getTableName()" map="B"/>
  <method class="OrderByExpressionImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="OrderByExpressionImpl" name="java.lang.String getColumnName()" map="C"/>
  <method class="OrderByExpressionImpl" name="byte[] serialize()" map="D"/>
  <method class="OrderByExpressionImpl" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="OrderByExpressionImpl" name="void deserialize(byte[])" map="A"/>
  <class name="ExpressionImpl$Type" map="_A"/>
  <field class="ExpressionImpl$Type" name="parenthesis" map="A"/>
  <field class="ExpressionImpl$Type" name="id" map="B"/>
  <field class="ExpressionImpl$Type" name="column" map="C"/>
  <field class="ExpressionImpl$Type" name="$VALUES" map="D"/>
  <field class="ExpressionImpl$Type" name="allExpression" map="E"/>
  <field class="ExpressionImpl$Type" name="inExpression" map="F"/>
  <field class="ExpressionImpl$Type" name="constant" map="G"/>
  <field class="ExpressionImpl$Type" name="parameter" map="H"/>
  <field class="ExpressionImpl$Type" name="binaryOp" map="I"/>
  <method class="ExpressionImpl$Type" name="ExpressionImpl$Type valueOf(java.lang.String)" map="valueOf"/>
  <method class="ExpressionImpl$Type" name="ExpressionImpl$Type[] values()" map="values"/>
  <method class="ExpressionImpl$Type" name="int getId()" map="A"/>
  <class name="ExpressionImpl$RecordToRead" map="_B"/>
  <field class="ExpressionImpl$RecordToRead" name="tableId" map="A"/>
  <field class="ExpressionImpl$RecordToRead" name="id" map="B"/>
  <class name="ExpressionImpl$PreparedIndexLookup" map="_C"/>
  <field class="ExpressionImpl$PreparedIndexLookup" name="preparedId" map="A"/>
  <field class="ExpressionImpl$PreparedIndexLookup" name="serversPrepared" map="B"/>
  <field class="ExpressionImpl$PreparedIndexLookup" name="lastTimeUsed" map="C"/>
  <method class="ExpressionImpl$PreparedIndexLookup" name="boolean[][] access$1100(ExpressionImpl$PreparedIndexLookup)" map="A"/>
  <method class="ExpressionImpl$PreparedIndexLookup" name="long access$902(ExpressionImpl$PreparedIndexLookup, long)" map="A"/>
  <method class="ExpressionImpl$PreparedIndexLookup" name="boolean[][] access$1102(ExpressionImpl$PreparedIndexLookup, boolean[][])" map="A"/>
  <method class="ExpressionImpl$PreparedIndexLookup" name="long access$802(ExpressionImpl$PreparedIndexLookup, long)" map="B"/>
  <method class="ExpressionImpl$PreparedIndexLookup" name="long access$900(ExpressionImpl$PreparedIndexLookup)" map="B"/>
  <method class="ExpressionImpl$PreparedIndexLookup" name="long access$800(ExpressionImpl$PreparedIndexLookup)" map="C"/>
  <class name="ExpressionImpl$NextReturn" map="_D"/>
  <field class="ExpressionImpl$NextReturn" name="fields" map="A"/>
  <field class="ExpressionImpl$NextReturn" name="tableNames" map="B"/>
  <field class="ExpressionImpl$NextReturn" name="ids" map="C"/>
  <method class="ExpressionImpl$NextReturn" name="void setIds(java.lang.Object[][][])" map="A"/>
  <method class="ExpressionImpl$NextReturn" name="java.lang.Object[][][] getKeys()" map="A"/>
  <method class="ExpressionImpl$NextReturn" name="java.lang.Object[][][] getIds()" map="B"/>
  <method class="ExpressionImpl$NextReturn" name="java.util.concurrent.ConcurrentHashMap getFields()" map="C"/>
  <method class="ExpressionImpl$NextReturn" name="void setTableNames(java.lang.String[])" map="A"/>
  <method class="ExpressionImpl$NextReturn" name="void setFields(java.util.concurrent.ConcurrentHashMap)" map="A"/>
  <method class="ExpressionImpl$NextReturn" name="java.lang.String[] getTableNames()" map="D"/>
  <method class="ExpressionImpl$NextReturn" name="void setFields(java.lang.String, java.lang.String[])" map="A"/>
  <class name="ExpressionImpl$RecordCache$Key" map="_A"/>
  <field class="ExpressionImpl$RecordCache$Key" name="this$0" map="A"/>
  <field class="ExpressionImpl$RecordCache$Key" name="hashCode" map="B"/>
  <field class="ExpressionImpl$RecordCache$Key" name="key" map="C"/>
  <method class="ExpressionImpl$RecordCache$Key" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="ExpressionImpl$RecordCache$Key" name="int hashCode()" map="hashCode"/>
  <class name="ExpressionImpl$RecordCache" map="_E"/>
  <field class="ExpressionImpl$RecordCache" name="recordsForTable" map="A"/>
  <method class="ExpressionImpl$RecordCache" name="void clear()" map="A"/>
  <method class="ExpressionImpl$RecordCache" name="ExpressionImpl$CachedRecord get(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="ExpressionImpl$RecordCache" name="boolean containsKey(java.lang.String, java.lang.Object[])" map="B"/>
  <method class="ExpressionImpl$RecordCache" name="void put(java.lang.String, java.lang.Object[], ExpressionImpl$CachedRecord)" map="A"/>
  <method class="ExpressionImpl$RecordCache" name="java.util.Map getRecordsForTable()" map="B"/>
  <class name="ExpressionImpl$CachedRecord" map="_F"/>
  <field class="ExpressionImpl$CachedRecord" name="record" map="A"/>
  <field class="ExpressionImpl$CachedRecord" name="serializedRecord" map="B"/>
  <method class="ExpressionImpl$CachedRecord" name="byte[] getSerializedRecord()" map="A"/>
  <method class="ExpressionImpl$CachedRecord" name="void setRecord(Record)" map="A"/>
  <method class="ExpressionImpl$CachedRecord" name="Record getRecord()" map="B"/>
  <method class="ExpressionImpl$CachedRecord" name="void setSerializedRecord(byte[])" map="A"/>
  <class name="ExpressionImpl$BatchLookupReturn" map="_G"/>
  <field class="ExpressionImpl$BatchLookupReturn" name="records" map="A"/>
  <field class="ExpressionImpl$BatchLookupReturn" name="keys" map="B"/>
  <method class="ExpressionImpl$BatchLookupReturn" name="java.util.Map access$202(ExpressionImpl$BatchLookupReturn, java.util.Map)" map="A"/>
  <method class="ExpressionImpl$BatchLookupReturn" name="java.util.Map access$300(ExpressionImpl$BatchLookupReturn)" map="A"/>
  <method class="ExpressionImpl$BatchLookupReturn" name="java.util.Map access$200(ExpressionImpl$BatchLookupReturn)" map="B"/>
  <method class="ExpressionImpl$BatchLookupReturn" name="java.util.Map access$302(ExpressionImpl$BatchLookupReturn, java.util.Map)" map="B"/>
  <class name="ExpressionImpl$4" map="4"/>
  <field class="ExpressionImpl$4" name="$SwitchMap$com$sonicbase$query$impl$ExpressionImpl$Type" map="A"/>
  <class name="ExpressionImpl$3" map="3"/>
  <field class="ExpressionImpl$3" name="val$client" map="A"/>
  <method class="ExpressionImpl$3" name="void run()" map="run"/>
  <class name="ExpressionImpl$2" map="2"/>
  <field class="ExpressionImpl$2" name="val$forceSelectOnServer" map="A"/>
  <field class="ExpressionImpl$2" name="val$shard" map="B"/>
  <field class="ExpressionImpl$2" name="val$dbName" map="C"/>
  <field class="ExpressionImpl$2" name="val$common" map="D"/>
  <field class="ExpressionImpl$2" name="val$operator" map="E"/>
  <field class="ExpressionImpl$2" name="val$indexSchema" map="F"/>
  <field class="ExpressionImpl$2" name="val$viewVersion" map="G"/>
  <field class="ExpressionImpl$2" name="val$tableSchema" map="H"/>
  <field class="ExpressionImpl$2" name="val$srcValues" map="I"/>
  <field class="ExpressionImpl$2" name="val$columns" map="J"/>
  <field class="ExpressionImpl$2" name="val$count" map="K"/>
  <field class="ExpressionImpl$2" name="val$recordCache" map="L"/>
  <field class="ExpressionImpl$2" name="val$previousSchemaVersion" map="M"/>
  <field class="ExpressionImpl$2" name="val$client" map="N"/>
  <method class="ExpressionImpl$2" name="ExpressionImpl$BatchLookupReturn call()" map="A"/>
  <method class="ExpressionImpl$2" name="java.lang.Object call()" map="call"/>
  <class name="ExpressionImpl$1" map="1"/>
  <field class="ExpressionImpl$1" name="val$forceSelectOnServer" map="A"/>
  <field class="ExpressionImpl$1" name="val$dbName" map="B"/>
  <field class="ExpressionImpl$1" name="val$indexSchema" map="C"/>
  <field class="ExpressionImpl$1" name="val$viewVersion" map="D"/>
  <field class="ExpressionImpl$1" name="val$tableSchema" map="E"/>
  <field class="ExpressionImpl$1" name="val$recordCache" map="F"/>
  <field class="ExpressionImpl$1" name="val$pageSize" map="G"/>
  <field class="ExpressionImpl$1" name="val$client" map="H"/>
  <field class="ExpressionImpl$1" name="val$selectColumns" map="I"/>
  <field class="ExpressionImpl$1" name="val$entry" map="J"/>
  <method class="ExpressionImpl$1" name="java.lang.Object call()" map="call"/>
  <class name="ExpressionImpl$IdEntry" map="_H"/>
  <field class="ExpressionImpl$IdEntry" name="value" map="A"/>
  <field class="ExpressionImpl$IdEntry" name="offset" map="B"/>
  <method class="ExpressionImpl$IdEntry" name="int getOffset()" map="A"/>
  <method class="ExpressionImpl$IdEntry" name="java.lang.Object[] getValue()" map="B"/>
  <class name="ExpressionImpl" map="M"/>
  <field class="ExpressionImpl" name="groupByContext" map="A"/>
  <field class="ExpressionImpl" name="columns" map="B"/>
  <field class="ExpressionImpl" name="indexCount" map="C"/>
  <field class="ExpressionImpl" name="tableName" map="D"/>
  <field class="ExpressionImpl" name="client" map="E"/>
  <field class="ExpressionImpl" name="topLevelExpression" map="F"/>
  <field class="ExpressionImpl" name="parms" map="G"/>
  <field class="ExpressionImpl" name="METRICS" map="H"/>
  <field class="ExpressionImpl" name="recordCache" map="I"/>
  <field class="ExpressionImpl" name="nextKey" map="J"/>
  <field class="ExpressionImpl" name="replica" map="K"/>
  <field class="ExpressionImpl" name="dbViewNum" map="L"/>
  <field class="ExpressionImpl" name="counters" map="M"/>
  <field class="ExpressionImpl" name="debug" map="N"/>
  <field class="ExpressionImpl" name="forceSelectOnServer" map="O"/>
  <field class="ExpressionImpl" name="indexBegin" map="P"/>
  <field class="ExpressionImpl" name="typesById" map="Q"/>
  <field class="ExpressionImpl" name="viewVersion" map="R"/>
  <field class="ExpressionImpl" name="orderByExpressions" map="S"/>
  <field class="ExpressionImpl" name="limit" map="T"/>
  <field class="ExpressionImpl" name="preparedReaper" map="U"/>
  <field class="ExpressionImpl" name="nextShard" map="V"/>
  <field class="ExpressionImpl" name="preparedIndexLookups" map="W"/>
  <field class="ExpressionImpl" name="dbName" map="X"/>
  <field class="ExpressionImpl" name="logger" map="Y"/>
  <method class="ExpressionImpl" name="java.lang.String getTableName()" map="A"/>
  <method class="ExpressionImpl" name="void setViewVersion(long)" map="B"/>
  <method class="ExpressionImpl" name="SelectContextImpl lookupIds(java.lang.String, DatabaseCommon, DatabaseClient, int, int, java.lang.String, java.lang.String, boolean, BinaryExpression$Operator, BinaryExpression$Operator, java.util.List, java.lang.Object[], ParameterHandler, Expression, java.lang.Object[], java.lang.Object[], java.lang.Object[], java.util.List, java.lang.String, int, ExpressionImpl$RecordCache, java.util.concurrent.atomic.AtomicReference, boolean, long, Counter[], GroupByContext, boolean)" map="A"/>
  <method class="ExpressionImpl" name="SelectContextImpl tableScan(java.lang.String, DatabaseClient, int, TableSchema, java.util.List, ExpressionImpl, ParameterHandler, java.util.List, int, java.lang.Object[], ExpressionImpl$RecordCache, Counter[], GroupByContext)" map="A"/>
  <method class="ExpressionImpl" name="java.lang.Object getValueFromExpression(ParameterHandler, ExpressionImpl)" map="A"/>
  <method class="ExpressionImpl" name="ExpressionImpl deserializeExpression(java.io.DataInputStream)" map="A"/>
  <method class="ExpressionImpl" name="Counter[] getCounters()" map="B"/>
  <method class="ExpressionImpl" name="void setTopLevelExpression(Expression)" map="A"/>
  <method class="ExpressionImpl" name="byte[][] aggregateResults(byte[][], byte[][])" map="A"/>
  <method class="ExpressionImpl" name="java.util.Map access$000()" map="C"/>
  <method class="ExpressionImpl" name="void setReplica(java.lang.Integer)" map="A"/>
  <method class="ExpressionImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="ExpressionImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <method class="ExpressionImpl" name="java.util.List getOrderByExpressions()" map="D"/>
  <method class="ExpressionImpl" name="void setDebug(boolean)" map="A"/>
  <method class="ExpressionImpl" name="java.lang.Object[][][] aggregateResults(java.lang.Object[][][], java.lang.Object[][][])" map="A"/>
  <method class="ExpressionImpl" name="void setLimit(net.sf.jsqlparser.statement.select.Limit)" map="A"/>
  <method class="ExpressionImpl" name="void setParms(ParameterHandler)" map="A"/>
  <method class="ExpressionImpl" name="void setRecordCache(ExpressionImpl$RecordCache)" map="A"/>
  <method class="ExpressionImpl" name="int getNextShard()" map="E"/>
  <method class="ExpressionImpl" name="long getViewVersion()" map="F"/>
  <method class="ExpressionImpl" name="void aggregateRecords(java.util.Map, int, Record[])" map="A"/>
  <method class="ExpressionImpl" name="java.util.HashMap readRecords(java.lang.String, DatabaseClient, int, boolean, TableSchema, java.util.List, java.lang.String[], java.util.List, ExpressionImpl$RecordCache, long)" map="A"/>
  <method class="ExpressionImpl" name="GroupByContext getGroupByContext()" map="G"/>
  <method class="ExpressionImpl" name="void stopPreparedReaper()" map="H"/>
  <method class="ExpressionImpl" name="Record doReadRecord(java.lang.String, DatabaseClient, boolean, ExpressionImpl$RecordCache, java.lang.Object[], java.lang.String, java.util.List, Expression, ParameterHandler, long, boolean)" map="A"/>
  <method class="ExpressionImpl" name="Record[] aggregateResults(Record[], Record[])" map="A"/>
  <method class="ExpressionImpl" name="boolean canUseIndex()" map="I"/>
  <method class="ExpressionImpl" name="void setTableName(java.lang.String)" map="B"/>
  <method class="ExpressionImpl" name="java.util.List getColumns()" map="J"/>
  <method class="ExpressionImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="ExpressionImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="ExpressionImpl" name="void aggregateRecords(java.util.Map, int, byte[])" map="A"/>
  <method class="ExpressionImpl" name="void access$400(TableSchema, java.util.List, ComArray)" map="A"/>
  <method class="ExpressionImpl" name="void access$500(java.util.Map, int, java.lang.Object[][])" map="A"/>
  <method class="ExpressionImpl" name="void forceSelectOnServer(boolean)" map="B"/>
  <method class="ExpressionImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="ExpressionImpl" name="void serializeExpression(ExpressionImpl, java.io.DataOutputStream)" map="A"/>
  <method class="ExpressionImpl" name="boolean handlePreparedNotFound(java.lang.Throwable)" map="A"/>
  <method class="ExpressionImpl" name="void queryRewrite()" map="L"/>
  <method class="ExpressionImpl" name="ParameterHandler getParms()" map="M"/>
  <method class="ExpressionImpl" name="void setOrderByExpressions(java.util.List)" map="A"/>
  <method class="ExpressionImpl" name="java.util.HashMap doReadRecords(java.lang.String, DatabaseClient, int, boolean, TableSchema, java.util.List, java.lang.String[], java.util.List, ExpressionImpl$RecordCache, long)" map="B"/>
  <method class="ExpressionImpl" name="ExpressionImpl$RecordCache getRecordCache()" map="N"/>
  <method class="ExpressionImpl" name="void setCounters(Counter[])" map="A"/>
  <method class="ExpressionImpl" name="void setColumns(java.util.List)" map="B"/>
  <method class="ExpressionImpl" name="void startPreparedReaper(DatabaseClient)" map="A"/>
  <method class="ExpressionImpl" name="void writeColumns(TableSchema, java.util.List, ComArray)" map="B"/>
  <method class="ExpressionImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="ExpressionImpl" name="byte[] serializeExpression(ExpressionImpl)" map="A"/>
  <method class="ExpressionImpl" name="Expression getTopLevelExpression()" map="O"/>
  <method class="ExpressionImpl" name="void aggregateRecords(java.util.Map, int, byte[][])" map="A"/>
  <method class="ExpressionImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="ExpressionImpl" name="void getColumnsInExpression(java.util.List)" map="C"/>
  <method class="ExpressionImpl" name="void setNextKey(java.lang.Object[])" map="A"/>
  <method class="ExpressionImpl" name="Record doReadRecord(java.lang.String, DatabaseClient, boolean, ParameterHandler, Expression, ExpressionImpl$RecordCache, java.lang.Object[], java.lang.String, java.util.List, long, boolean)" map="A"/>
  <method class="ExpressionImpl" name="void setClient(DatabaseClient)" map="B"/>
  <method class="ExpressionImpl" name="void evaluateCounter(DatabaseCommon, DatabaseClient, java.lang.String, Counter)" map="A"/>
  <method class="ExpressionImpl" name="java.util.concurrent.ConcurrentHashMap access$700()" map="P"/>
  <method class="ExpressionImpl" name="void reset()" map="Q"/>
  <method class="ExpressionImpl" name="void setNextShard(int)" map="A"/>
  <method class="ExpressionImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="ExpressionImpl" name="void setDbName(java.lang.String)" map="C"/>
  <method class="ExpressionImpl" name="ExpressionImpl$BatchLookupReturn access$100(java.lang.String, DatabaseCommon, DatabaseClient, boolean, int, TableSchema, BinaryExpression$Operator, java.util.Map$Entry, java.util.List, java.util.List, int, java.util.concurrent.atomic.AtomicReference, ExpressionImpl$RecordCache, long)" map="A"/>
  <method class="ExpressionImpl" name="ExpressionImpl$BatchLookupReturn batchLookupIds(java.lang.String, DatabaseCommon, DatabaseClient, boolean, int, TableSchema, BinaryExpression$Operator, java.util.Map$Entry, java.util.List, java.util.List, int, java.util.concurrent.atomic.AtomicReference, ExpressionImpl$RecordCache, long)" map="B"/>
  <method class="ExpressionImpl" name="java.lang.Object[] getNextKey()" map="S"/>
  <method class="ExpressionImpl" name="java.lang.Object[][] aggregateResults(java.lang.Object[][], java.lang.Object[][])" map="A"/>
  <method class="ExpressionImpl" name="org.apache.log4j.Logger access$1000()" map="T"/>
  <method class="ExpressionImpl" name="boolean isForceSelectOnServer()" map="U"/>
  <method class="ExpressionImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="ExpressionImpl" name="void aggregateKeys(java.util.Map, int, java.lang.Object[][])" map="B"/>
  <method class="ExpressionImpl" name="ExpressionImpl deserializeExpression(byte[])" map="A"/>
  <method class="ExpressionImpl" name="void writeColumns(TableSchema, java.util.List, java.io.DataOutputStream, com.sonicbase.util.DataUtil$ResultLength)" map="A"/>
  <method class="ExpressionImpl" name="java.lang.Integer getReplica()" map="W"/>
  <method class="ExpressionImpl" name="DatabaseClient getClient()" map="X"/>
  <method class="ExpressionImpl" name="java.lang.Object[] buildKey(java.util.List, java.lang.String[])" map="A"/>
  <method class="ExpressionImpl" name="void setGroupByContext(GroupByContext)" map="A"/>
  <class name="StatementImpl" map="N"/>
  <field class="StatementImpl" name="parms" map="A"/>
  <method class="StatementImpl" name="InExpression createInExpression()" map="A"/>
  <method class="StatementImpl" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <method class="StatementImpl" name="void setParms(ParameterHandler)" map="A"/>
  <method class="StatementImpl" name="ParameterHandler getParms()" map="B"/>
  <method class="StatementImpl" name="BinaryExpression createBinaryExpression(Expression, BinaryExpression$Operator, Expression)" map="A"/>
  <method class="StatementImpl" name="BinaryExpression createBinaryExpression(java.lang.String, BinaryExpression$Operator, java.lang.String)" map="A"/>
  <method class="StatementImpl" name="BinaryExpression createBinaryExpression(java.lang.String, BinaryExpression$Operator, long)" map="A"/>
  <class name="DeleteStatementImpl" map="O"/>
  <field class="DeleteStatementImpl" name="recordCache" map="q"/>
  <field class="DeleteStatementImpl" name="client" map="r"/>
  <field class="DeleteStatementImpl" name="tableName" map="s"/>
  <field class="DeleteStatementImpl" name="expression" map="t"/>
  <method class="DeleteStatementImpl" name="void serialize(java.io.DataOutputStream)" map="B"/>
  <method class="DeleteStatementImpl" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="DeleteStatementImpl" name="void setWhereClause(Expression)" map="A"/>
  <method class="DeleteStatementImpl" name="void setTableName(java.lang.String)" map="A"/>
  <method class="DeleteStatementImpl" name="java.lang.String getTableName()" map="d"/>
  <method class="DeleteStatementImpl" name="ExpressionImpl getExpression()" map="e"/>
  <method class="DeleteStatementImpl" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <class name="InExpressionImpl" map="P"/>
  <field class="InExpressionImpl" name="isNot" map="v"/>
  <field class="InExpressionImpl" name="client" map="w"/>
  <field class="InExpressionImpl" name="tableName" map="x"/>
  <field class="InExpressionImpl" name="expressionList" map="y"/>
  <field class="InExpressionImpl" name="parms" map="z"/>
  <field class="InExpressionImpl" name="leftExpression" map="&#x00a2;"/>
  <method class="InExpressionImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="InExpressionImpl" name="void addValue(java.lang.String)" map="A"/>
  <method class="InExpressionImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="InExpressionImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="InExpressionImpl" name="void setTableName(java.lang.String)" map="B"/>
  <method class="InExpressionImpl" name="java.lang.String toString()" map="toString"/>
  <method class="InExpressionImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="InExpressionImpl" name="void addValue(long)" map="A"/>
  <method class="InExpressionImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="InExpressionImpl" name="ExpressionImpl getLeftExpression()" map="p"/>
  <method class="InExpressionImpl" name="void addExpression(ExpressionImpl)" map="E"/>
  <method class="InExpressionImpl" name="void setColumns(java.util.List)" map="B"/>
  <method class="InExpressionImpl" name="void setNot(boolean)" map="E"/>
  <method class="InExpressionImpl" name="java.util.List getExpressionList()" map="q"/>
  <method class="InExpressionImpl" name="void setExpressionList(java.util.List)" map="E"/>
  <method class="InExpressionImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="InExpressionImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="InExpressionImpl" name="void setColumn(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="InExpressionImpl" name="void setLeftExpression(Expression)" map="D"/>
  <method class="InExpressionImpl" name="void queryRewrite()" map="L"/>
  <method class="InExpressionImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="InExpressionImpl" name="boolean canUseIndex()" map="I"/>
  <method class="InExpressionImpl" name="boolean isNot()" map="r"/>
  <method class="InExpressionImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <class name="ParenthesisImpl" map="Q"/>
  <field class="ParenthesisImpl" name="isNot" map="m"/>
  <field class="ParenthesisImpl" name="expression" map="n"/>
  <method class="ParenthesisImpl" name="void queryRewrite()" map="L"/>
  <method class="ParenthesisImpl" name="boolean canUseIndex()" map="I"/>
  <method class="ParenthesisImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="ParenthesisImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="ParenthesisImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="ParenthesisImpl" name="void setExpression(ExpressionImpl)" map="D"/>
  <method class="ParenthesisImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="ParenthesisImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <method class="ParenthesisImpl" name="void setNot(boolean)" map="D"/>
  <method class="ParenthesisImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="ParenthesisImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="ParenthesisImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="ParenthesisImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="ParenthesisImpl" name="ExpressionImpl getExpression()" map="h"/>
  <method class="ParenthesisImpl" name="boolean isNot()" map="i"/>
  <class name="UpdateStatementImpl$1" map="1"/>
  <field class="UpdateStatementImpl$1" name="$SwitchMap$com$sonicbase$schema$DataType$Type" map="A"/>
  <class name="UpdateStatementImpl" map="R"/>
  <field class="UpdateStatementImpl" name="setExpressions" map="F"/>
  <field class="UpdateStatementImpl" name="whereClause" map="G"/>
  <field class="UpdateStatementImpl" name="recordCache" map="H"/>
  <field class="UpdateStatementImpl" name="client" map="I"/>
  <field class="UpdateStatementImpl" name="tableName" map="J"/>
  <field class="UpdateStatementImpl" name="columns" map="K"/>
  <method class="UpdateStatementImpl" name="void addColumn(net.sf.jsqlparser.schema.Column)" map="A"/>
  <method class="UpdateStatementImpl" name="void setTableName(java.lang.String)" map="C"/>
  <method class="UpdateStatementImpl" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <method class="UpdateStatementImpl" name="java.lang.String getTableName()" map="F"/>
  <method class="UpdateStatementImpl" name="void addSetExpression(Expression)" map="C"/>
  <method class="UpdateStatementImpl" name="void setWhereClause(Expression)" map="B"/>
  <method class="UpdateStatementImpl" name="ExpressionImpl getWhereClause()" map="G"/>
  <method class="UpdateStatementImpl" name="java.util.List getSetExpressions()" map="H"/>
  <method class="UpdateStatementImpl" name="int getCurrParmNum()" map="I"/>
  <method class="UpdateStatementImpl" name="java.util.List getColumns()" map="J"/>
  <class name="SelectStatementImpl$Function" map="_A"/>
  <field class="SelectStatementImpl$Function" name="name" map="A"/>
  <field class="SelectStatementImpl$Function" name="parms" map="B"/>
  <method class="SelectStatementImpl$Function" name="net.sf.jsqlparser.expression.operators.relational.ExpressionList getParms()" map="A"/>
  <method class="SelectStatementImpl$Function" name="java.lang.String getName()" map="B"/>
  <class name="SelectStatementImpl$1" map="1"/>
  <field class="SelectStatementImpl$1" name="$SwitchMap$com$sonicbase$schema$DataType$Type" map="A"/>
  <class name="SelectStatementImpl$Explain" map="_B"/>
  <field class="SelectStatementImpl$Explain" name="indent" map="A"/>
  <field class="SelectStatementImpl$Explain" name="builder" map="B"/>
  <method class="SelectStatementImpl$Explain" name="void outdent()" map="A"/>
  <method class="SelectStatementImpl$Explain" name="java.lang.StringBuilder getBuilder()" map="B"/>
  <method class="SelectStatementImpl$Explain" name="void appendSpaces()" map="C"/>
  <method class="SelectStatementImpl$Explain" name="int getIndent()" map="D"/>
  <method class="SelectStatementImpl$Explain" name="void indent()" map="E"/>
  <method class="SelectStatementImpl$Explain" name="void setBuilder(java.lang.StringBuilder)" map="A"/>
  <method class="SelectStatementImpl$Explain" name="void setIndent(int)" map="A"/>
  <class name="SelectStatementImpl$Join" map="_C"/>
  <field class="SelectStatementImpl$Join" name="rightFrom" map="A"/>
  <field class="SelectStatementImpl$Join" name="type" map="B"/>
  <field class="SelectStatementImpl$Join" name="expression" map="C"/>
  <method class="SelectStatementImpl$Join" name="SelectStatement$JoinType access$200(SelectStatementImpl$Join)" map="A"/>
  <method class="SelectStatementImpl$Join" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="SelectStatementImpl$Join" name="Expression access$100(SelectStatementImpl$Join)" map="B"/>
  <method class="SelectStatementImpl$Join" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="SelectStatementImpl$Join" name="java.lang.String access$000(SelectStatementImpl$Join)" map="C"/>
  <class name="SelectStatementImpl$JoinReturn" map="_D"/>
  <field class="SelectStatementImpl$JoinReturn" name="this$0" map="A"/>
  <field class="SelectStatementImpl$JoinReturn" name="keys" map="B"/>
  <method class="SelectStatementImpl$JoinReturn" name="java.util.List access$300(SelectStatementImpl$JoinReturn)" map="A"/>
  <method class="SelectStatementImpl$JoinReturn" name="java.util.List access$302(SelectStatementImpl$JoinReturn, java.util.List)" map="A"/>
  <class name="SelectStatementImpl$DistinctRecord" map="_E"/>
  <field class="SelectStatementImpl$DistinctRecord" name="this$0" map="A"/>
  <field class="SelectStatementImpl$DistinctRecord" name="isArray" map="B"/>
  <field class="SelectStatementImpl$DistinctRecord" name="record" map="C"/>
  <field class="SelectStatementImpl$DistinctRecord" name="selectColumns" map="D"/>
  <field class="SelectStatementImpl$DistinctRecord" name="distinctFields" map="E"/>
  <field class="SelectStatementImpl$DistinctRecord" name="comparators" map="F"/>
  <method class="SelectStatementImpl$DistinctRecord" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="SelectStatementImpl$DistinctRecord" name="int hashCode()" map="hashCode"/>
  <class name="SelectStatementImpl$KeyEntry" map="_F"/>
  <field class="SelectStatementImpl$KeyEntry" name="this$0" map="A"/>
  <field class="SelectStatementImpl$KeyEntry" name="comparators" map="B"/>
  <field class="SelectStatementImpl$KeyEntry" name="key" map="C"/>
  <method class="SelectStatementImpl$KeyEntry" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="SelectStatementImpl$KeyEntry" name="int hashCode()" map="hashCode"/>
  <class name="SelectStatementImpl" map="S"/>
  <field class="SelectStatementImpl" name="joins" map="L"/>
  <field class="SelectStatementImpl" name="groupByContext" map="M"/>
  <field class="SelectStatementImpl" name="functionAliases" map="N"/>
  <field class="SelectStatementImpl" name="columns" map="O"/>
  <field class="SelectStatementImpl" name="serverSort" map="P"/>
  <field class="SelectStatementImpl" name="client" map="Q"/>
  <field class="SelectStatementImpl" name="serverSelect" map="R"/>
  <field class="SelectStatementImpl" name="isCountFunction" map="S"/>
  <field class="SelectStatementImpl" name="offset" map="T"/>
  <field class="SelectStatementImpl" name="serverSelectShardNumber" map="U"/>
  <field class="SelectStatementImpl" name="recordCache" map="V"/>
  <field class="SelectStatementImpl" name="isDistinct" map="W"/>
  <field class="SelectStatementImpl" name="serverSelectReplicaNumber" map="X"/>
  <field class="SelectStatementImpl" name="serverSelectPageNumber" map="Y"/>
  <field class="SelectStatementImpl" name="counters" map="Z"/>
  <field class="SelectStatementImpl" name="expression" map="_"/>
  <field class="SelectStatementImpl" name="selectColumns" map="a"/>
  <field class="SelectStatementImpl" name="countTable" map="b"/>
  <field class="SelectStatementImpl" name="expressionDuration" map="c"/>
  <field class="SelectStatementImpl" name="forceSelectOnServer" map="d"/>
  <field class="SelectStatementImpl" name="isOnServer" map="e"/>
  <field class="SelectStatementImpl" name="tableNames" map="f"/>
  <field class="SelectStatementImpl" name="expressionCount" map="g"/>
  <field class="SelectStatementImpl" name="fromTable" map="h"/>
  <field class="SelectStatementImpl" name="aliases" map="i"/>
  <field class="SelectStatementImpl" name="countColumn" map="j"/>
  <field class="SelectStatementImpl" name="orderByExpressions" map="k"/>
  <field class="SelectStatementImpl" name="limit" map="l"/>
  <field class="SelectStatementImpl" name="pageSize" map="m"/>
  <field class="SelectStatementImpl" name="serverSelectResultSetId" map="n"/>
  <field class="SelectStatementImpl" name="groupByColumns" map="o"/>
  <field class="SelectStatementImpl" name="logger" map="p"/>
  <method class="SelectStatementImpl" name="java.lang.String[] getTableNames()" map="K"/>
  <method class="SelectStatementImpl" name="void getActualJoinExpression(ExpressionImpl, java.util.concurrent.atomic.AtomicReference, java.util.List)" map="A"/>
  <method class="SelectStatementImpl" name="java.util.List getOrderByExpressions()" map="L"/>
  <method class="SelectStatementImpl" name="long getServerSelectResultSetId()" map="M"/>
  <method class="SelectStatementImpl" name="ExpressionImpl getExpression()" map="N"/>
  <method class="SelectStatementImpl" name="void setCountFunction()" map="O"/>
  <method class="SelectStatementImpl" name="void setServerSelectPageNumber(int)" map="A"/>
  <method class="SelectStatementImpl" name="void setWhereClause(Expression)" map="D"/>
  <method class="SelectStatementImpl" name="ExpressionImpl$NextReturn serverSelect(java.lang.String, boolean, java.lang.String[])" map="A"/>
  <method class="SelectStatementImpl" name="ExpressionImpl$NextReturn next(java.lang.String, SelectStatementImpl$Explain)" map="B"/>
  <method class="SelectStatementImpl" name="java.util.Map getFunctionAliases()" map="P"/>
  <method class="SelectStatementImpl" name="void addOrderByExpression(java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="SelectStatementImpl" name="void setIsDistinct()" map="Q"/>
  <method class="SelectStatementImpl" name="boolean isServerSelect()" map="R"/>
  <method class="SelectStatementImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="SelectStatementImpl" name="void setIsOnServer(boolean)" map="A"/>
  <method class="SelectStatementImpl" name="void applyDistinct(java.lang.String, java.lang.String[], ExpressionImpl$NextReturn, java.util.Set)" map="A"/>
  <method class="SelectStatementImpl" name="byte[] serialize()" map="S"/>
  <method class="SelectStatementImpl" name="void setServerSelectShardNumber(int)" map="B"/>
  <method class="SelectStatementImpl" name="void setServerSelectResultSetId(long)" map="A"/>
  <method class="SelectStatementImpl" name="void setLimit(net.sf.jsqlparser.statement.select.Limit)" map="A"/>
  <method class="SelectStatementImpl" name="int getServerSelectPageNumber()" map="T"/>
  <method class="SelectStatementImpl" name="java.util.List getSelectColumns()" map="U"/>
  <method class="SelectStatementImpl" name="void setOffset(net.sf.jsqlparser.statement.select.Offset)" map="A"/>
  <method class="SelectStatementImpl" name="void setOrderByExpressions(java.util.List)" map="B"/>
  <method class="SelectStatementImpl" name="void deserialize(java.io.DataInputStream, java.lang.String)" map="A"/>
  <method class="SelectStatementImpl" name="void setCountFunction(java.lang.String, java.lang.String)" map="A"/>
  <method class="SelectStatementImpl" name="int getServerSelectShardNumber()" map="V"/>
  <method class="SelectStatementImpl" name="int getServerSelectReplicaNumber()" map="W"/>
  <method class="SelectStatementImpl" name="void forceSelectOnServer()" map="X"/>
  <method class="SelectStatementImpl" name="boolean isOnServer()" map="Y"/>
  <method class="SelectStatementImpl" name="ResultSet countRecords(java.lang.String, java.lang.String[])" map="A"/>
  <method class="SelectStatementImpl" name="void addOrderBy(java.lang.String, java.lang.String, boolean)" map="B"/>
  <method class="SelectStatementImpl" name="ExpressionImpl$NextReturn handleJoins(int, java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <method class="SelectStatementImpl" name="void setServerSelectReplicaNumber(int)" map="C"/>
  <method class="SelectStatementImpl" name="boolean isForceSelectOnServer()" map="Z"/>
  <method class="SelectStatementImpl" name="java.util.Map getAliases()" map="_"/>
  <method class="SelectStatementImpl" name="boolean isExpressionForRightTable(TableSchema, ExpressionImpl)" map="A"/>
  <method class="SelectStatementImpl" name="Expression getWhereClause()" map="a"/>
  <method class="SelectStatementImpl" name="void setFromTable(java.lang.String)" map="D"/>
  <method class="SelectStatementImpl" name="void setGroupByColumns(java.util.List)" map="C"/>
  <method class="SelectStatementImpl" name="void dedupIds(java.lang.String, java.lang.String[], ExpressionImpl$NextReturn)" map="A"/>
  <method class="SelectStatementImpl" name="SelectStatementImpl$JoinReturn evaluateJoin(int, java.lang.String, java.util.concurrent.atomic.AtomicReference, SelectStatement$JoinType, java.util.concurrent.atomic.AtomicReference, java.util.concurrent.atomic.AtomicReference, TableSchema, TableSchema, java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, SelectStatementImpl$Explain)" map="A"/>
  <method class="SelectStatementImpl" name="void deserialize(byte[], java.lang.String)" map="A"/>
  <method class="SelectStatementImpl" name="void addSelectColumn(java.lang.String, net.sf.jsqlparser.expression.operators.relational.ExpressionList, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="SelectStatementImpl" name="java.lang.String getFromTable()" map="b"/>
  <method class="SelectStatementImpl" name="void setPageSize(long)" map="B"/>
  <method class="SelectStatementImpl" name="void addJoinExpression(SelectStatement$JoinType, java.lang.String, Expression)" map="A"/>
  <method class="SelectStatementImpl" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <method class="SelectStatementImpl" name="java.lang.Long getPageSize()" map="c"/>
  <class name="ColumnImpl" map="T"/>
  <field class="ColumnImpl" name="function" map="o"/>
  <field class="ColumnImpl" name="columnName" map="p"/>
  <field class="ColumnImpl" name="tableName" map="q"/>
  <field class="ColumnImpl" name="alias" map="r"/>
  <field class="ColumnImpl" name="parameters" map="s"/>
  <method class="ColumnImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="ColumnImpl" name="java.lang.String getColumnName()" map="j"/>
  <method class="ColumnImpl" name="java.lang.String getAlias()" map="k"/>
  <method class="ColumnImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="ColumnImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="ColumnImpl" name="void setTableName(java.lang.String)" map="B"/>
  <method class="ColumnImpl" name="void getColumnsInExpression(java.util.List)" map="C"/>
  <method class="ColumnImpl" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="ColumnImpl" name="java.lang.String toString()" map="toString"/>
  <method class="ColumnImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="ColumnImpl" name="net.sf.jsqlparser.expression.operators.relational.ExpressionList getParameters()" map="l"/>
  <method class="ColumnImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="ColumnImpl" name="java.lang.String getFunction()" map="m"/>
  <method class="ColumnImpl" name="java.lang.String getTableName()" map="A"/>
  <method class="ColumnImpl" name="int hashCode()" map="hashCode"/>
  <method class="ColumnImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="ColumnImpl" name="void setColumnName(java.lang.String)" map="F"/>
  <method class="ColumnImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="ColumnImpl" name="void queryRewrite()" map="L"/>
  <method class="ColumnImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="ColumnImpl" name="boolean canUseIndex()" map="I"/>
  <method class="ColumnImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <class name="DiskBasedResultSet$MergeRow" map="_A"/>
  <field class="DiskBasedResultSet$MergeRow" name="streamOffset" map="A"/>
  <field class="DiskBasedResultSet$MergeRow" name="row" map="B"/>
  <method class="DiskBasedResultSet$MergeRow" name="int access$102(DiskBasedResultSet$MergeRow, int)" map="A"/>
  <method class="DiskBasedResultSet$MergeRow" name="int access$100(DiskBasedResultSet$MergeRow)" map="A"/>
  <method class="DiskBasedResultSet$MergeRow" name="Record[] access$002(DiskBasedResultSet$MergeRow, Record[])" map="A"/>
  <method class="DiskBasedResultSet$MergeRow" name="Record[] access$000(DiskBasedResultSet$MergeRow)" map="B"/>
  <class name="DiskBasedResultSet$2" map="2"/>
  <field class="DiskBasedResultSet$2" name="this$0" map="A"/>
  <field class="DiskBasedResultSet$2" name="val$tableOffsets" map="B"/>
  <field class="DiskBasedResultSet$2" name="val$comparators" map="C"/>
  <field class="DiskBasedResultSet$2" name="val$fieldOffsets" map="D"/>
  <field class="DiskBasedResultSet$2" name="val$ascendingFlags" map="E"/>
  <method class="DiskBasedResultSet$2" name="int compare(DiskBasedResultSet$MergeRow, DiskBasedResultSet$MergeRow)" map="A"/>
  <method class="DiskBasedResultSet$2" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="DiskBasedResultSet$1" map="1"/>
  <field class="DiskBasedResultSet$1" name="this$0" map="A"/>
  <field class="DiskBasedResultSet$1" name="val$tableOffsets" map="B"/>
  <field class="DiskBasedResultSet$1" name="val$comparators" map="C"/>
  <field class="DiskBasedResultSet$1" name="val$fieldOffsets" map="D"/>
  <field class="DiskBasedResultSet$1" name="val$ascendingFlags" map="E"/>
  <method class="DiskBasedResultSet$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="DiskBasedResultSet$1" name="int compare(Record[], Record[])" map="A"/>
  <class name="DiskBasedResultSet" map="U"/>
  <field class="DiskBasedResultSet" name="select" map="A"/>
  <field class="DiskBasedResultSet" name="tableNames" map="B"/>
  <field class="DiskBasedResultSet" name="logger" map="C"/>
  <field class="DiskBasedResultSet" name="count" map="D"/>
  <field class="DiskBasedResultSet" name="server" map="E"/>
  <field class="DiskBasedResultSet" name="nextResultSetId" map="F"/>
  <field class="DiskBasedResultSet" name="resultSetId" map="G"/>
  <method class="DiskBasedResultSet" name="void deleteOldResultSets(com.sonicbase.server.DatabaseServer)" map="A"/>
  <method class="DiskBasedResultSet" name="Record[] readRow(java.lang.String, java.io.DataInputStream, com.sonicbase.util.DataUtil$ResultLength)" map="A"/>
  <method class="DiskBasedResultSet" name="void writeRecordsToFile(java.io.File, ExpressionImpl$CachedRecord[][], int)" map="A"/>
  <method class="DiskBasedResultSet" name="void mergeNFiles(java.lang.String, java.io.File, java.io.File[])" map="A"/>
  <method class="DiskBasedResultSet" name="void mergeSort(java.lang.String, java.io.File)" map="A"/>
  <method class="DiskBasedResultSet" name="void mergeTwoFiles(java.lang.String, java.io.File, java.io.File, java.io.File, boolean)" map="A"/>
  <method class="DiskBasedResultSet" name="void getKeepers(java.lang.String, com.sonicbase.server.DatabaseServer, java.lang.String[], java.util.Map, boolean[][], java.lang.String, java.lang.String)" map="A"/>
  <method class="DiskBasedResultSet" name="byte[][][] nextPage(int, int)" map="A"/>
  <method class="DiskBasedResultSet" name="long getResultSetId()" map="A"/>
  <method class="DiskBasedResultSet" name="java.io.DataOutputStream writeRow(Record[], java.io.DataOutputStream, java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, java.io.File, com.sonicbase.util.DataUtil$ResultLength)" map="A"/>
  <method class="DiskBasedResultSet" name="void delete()" map="B"/>
  <method class="DiskBasedResultSet" name="void updateAccessTime(java.io.File)" map="A"/>
  <class name="GroupByContext$GroupCounter" map="_A"/>
  <field class="GroupByContext$GroupCounter" name="counter" map="A"/>
  <field class="GroupByContext$GroupCounter" name="groupValues" map="B"/>
  <method class="GroupByContext$GroupCounter" name="Counter access$000(GroupByContext$GroupCounter)" map="A"/>
  <method class="GroupByContext$GroupCounter" name="Counter access$002(GroupByContext$GroupCounter, Counter)" map="A"/>
  <method class="GroupByContext$GroupCounter" name="Counter getCounter()" map="A"/>
  <method class="GroupByContext$GroupCounter" name="void setCounter(Counter)" map="A"/>
  <method class="GroupByContext$GroupCounter" name="java.lang.Object[] access$600(GroupByContext$GroupCounter)" map="B"/>
  <method class="GroupByContext$GroupCounter" name="void setGroupValues(java.lang.Object[])" map="A"/>
  <class name="GroupByContext$1" map="1"/>
  <field class="GroupByContext$1" name="this$0" map="A"/>
  <method class="GroupByContext$1" name="int compare(java.lang.Object[], java.lang.Object[])" map="A"/>
  <method class="GroupByContext$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="GroupByContext$FieldContext" map="_B"/>
  <field class="GroupByContext$FieldContext" name="comparator" map="A"/>
  <field class="GroupByContext$FieldContext" name="fieldOffset" map="B"/>
  <field class="GroupByContext$FieldContext" name="dataType" map="C"/>
  <field class="GroupByContext$FieldContext" name="tableSchema" map="D"/>
  <field class="GroupByContext$FieldContext" name="fieldName" map="E"/>
  <method class="GroupByContext$FieldContext" name="void setDataType(DataType$Type)" map="A"/>
  <method class="GroupByContext$FieldContext" name="java.util.Comparator access$502(GroupByContext$FieldContext, java.util.Comparator)" map="A"/>
  <method class="GroupByContext$FieldContext" name="java.lang.String access$200(GroupByContext$FieldContext)" map="A"/>
  <method class="GroupByContext$FieldContext" name="java.lang.String access$202(GroupByContext$FieldContext, java.lang.String)" map="A"/>
  <method class="GroupByContext$FieldContext" name="DataType$Type access$402(GroupByContext$FieldContext, DataType$Type)" map="A"/>
  <method class="GroupByContext$FieldContext" name="void setComparator(java.util.Comparator)" map="A"/>
  <method class="GroupByContext$FieldContext" name="int access$302(GroupByContext$FieldContext, int)" map="A"/>
  <method class="GroupByContext$FieldContext" name="java.lang.String getFieldName()" map="A"/>
  <method class="GroupByContext$FieldContext" name="int getFieldOffset()" map="B"/>
  <method class="GroupByContext$FieldContext" name="DataType$Type access$400(GroupByContext$FieldContext)" map="B"/>
  <method class="GroupByContext$FieldContext" name="DataType$Type getDataType()" map="C"/>
  <method class="GroupByContext$FieldContext" name="int access$300(GroupByContext$FieldContext)" map="C"/>
  <method class="GroupByContext$FieldContext" name="java.util.Comparator getComparator()" map="D"/>
  <method class="GroupByContext$FieldContext" name="void setFieldOffset(int)" map="A"/>
  <method class="GroupByContext$FieldContext" name="void setFieldName(java.lang.String)" map="A"/>
  <class name="GroupByContext" map="V"/>
  <field class="GroupByContext" name="fieldContexts" map="A"/>
  <field class="GroupByContext" name="counterTemplates" map="B"/>
  <field class="GroupByContext" name="groupCounters" map="C"/>
  <method class="GroupByContext" name="void deserialize(java.io.DataInputStream, DatabaseCommon, java.lang.String)" map="A"/>
  <method class="GroupByContext" name="void deserialize(byte[], DatabaseCommon, java.lang.String)" map="A"/>
  <method class="GroupByContext" name="java.util.List getFieldContexts()" map="A"/>
  <method class="GroupByContext" name="java.util.Map getCounterTemplates()" map="B"/>
  <method class="GroupByContext" name="void addGroupContext(java.lang.Object[])" map="A"/>
  <method class="GroupByContext" name="java.util.Map getGroupCounters()" map="C"/>
  <method class="GroupByContext" name="void addCounterTemplate(Counter)" map="A"/>
  <method class="GroupByContext" name="byte[] serialize(DatabaseCommon)" map="A"/>
  <method class="GroupByContext" name="java.util.List access$100(GroupByContext)" map="A"/>
  <method class="GroupByContext" name="java.util.Map getOrCreateInnerMap(GroupByContext$GroupCounter)" map="A"/>
  <class name="Counter$1" map="1"/>
  <field class="Counter$1" name="$SwitchMap$com$sonicbase$schema$DataType$Type" map="A"/>
  <class name="Counter" map="W"/>
  <field class="Counter" name="maxLong" map="A"/>
  <field class="Counter" name="columnName" map="B"/>
  <field class="Counter" name="column" map="C"/>
  <field class="Counter" name="minLong" map="D"/>
  <field class="Counter" name="doubleCount" map="E"/>
  <field class="Counter" name="longCount" map="F"/>
  <field class="Counter" name="count" map="G"/>
  <field class="Counter" name="dataType" map="H"/>
  <field class="Counter" name="maxDouble" map="I"/>
  <field class="Counter" name="tableName" map="J"/>
  <field class="Counter" name="minDouble" map="K"/>
  <method class="Counter" name="void setMaxLong(java.lang.Long)" map="A"/>
  <method class="Counter" name="void setDataType(DataType$Type)" map="A"/>
  <method class="Counter" name="java.lang.String getColumnName()" map="A"/>
  <method class="Counter" name="java.lang.Long getMaxLong()" map="B"/>
  <method class="Counter" name="int getColumnOffset()" map="C"/>
  <method class="Counter" name="java.lang.Double getAvgLong()" map="D"/>
  <method class="Counter" name="void setTableName(java.lang.String)" map="A"/>
  <method class="Counter" name="void setMinDouble(double)" map="A"/>
  <method class="Counter" name="void setCount(java.lang.Long)" map="B"/>
  <method class="Counter" name="java.lang.Long getLongCount()" map="E"/>
  <method class="Counter" name="void deserialize(byte[])" map="A"/>
  <method class="Counter" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="Counter" name="java.lang.Double getMinDouble()" map="F"/>
  <method class="Counter" name="void addLong(java.lang.Long)" map="C"/>
  <method class="Counter" name="void add(java.lang.Object[])" map="A"/>
  <method class="Counter" name="byte[] serialize()" map="G"/>
  <method class="Counter" name="void setMaxDouble(java.lang.Double)" map="A"/>
  <method class="Counter" name="java.lang.String getTableName()" map="H"/>
  <method class="Counter" name="DataType$Type getDataType()" map="I"/>
  <method class="Counter" name="void setDestTypeToDouble()" map="J"/>
  <method class="Counter" name="boolean isDestTypeDouble()" map="K"/>
  <method class="Counter" name="java.lang.Object getDoubleCount()" map="L"/>
  <method class="Counter" name="java.lang.Double getMaxDouble()" map="M"/>
  <method class="Counter" name="boolean isDestTypeLong()" map="N"/>
  <method class="Counter" name="void setColumnName(java.lang.String)" map="B"/>
  <method class="Counter" name="void setMinLong(java.lang.Long)" map="D"/>
  <method class="Counter" name="java.lang.Long getMinLong()" map="O"/>
  <method class="Counter" name="long getCount()" map="P"/>
  <method class="Counter" name="void setDestTypeToLong()" map="Q"/>
  <method class="Counter" name="void addDouble(java.lang.Double)" map="B"/>
  <method class="Counter" name="void setColumn(int)" map="A"/>
  <method class="Counter" name="java.lang.Double getAvgDouble()" map="R"/>
  <class name="ConstantImpl" map="X"/>
  <field class="ConstantImpl" name="sqlType" map="t"/>
  <field class="ConstantImpl" name="value" map="u"/>
  <method class="ConstantImpl" name="void queryRewrite()" map="L"/>
  <method class="ConstantImpl" name="boolean canUseIndex()" map="I"/>
  <method class="ConstantImpl" name="ExpressionImpl$NextReturn next(SelectStatementImpl$Explain)" map="A"/>
  <method class="ConstantImpl" name="int getSqlType()" map="n"/>
  <method class="ConstantImpl" name="ExpressionImpl$Type getType()" map="K"/>
  <method class="ConstantImpl" name="void getColumns(java.util.Set)" map="A"/>
  <method class="ConstantImpl" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="ConstantImpl" name="ExpressionImpl$NextReturn next(int, SelectStatementImpl$Explain)" map="A"/>
  <method class="ConstantImpl" name="void setValue(java.lang.Object)" map="A"/>
  <method class="ConstantImpl" name="void setSqlType(int)" map="C"/>
  <method class="ConstantImpl" name="ColumnImpl getPrimaryColumn()" map="V"/>
  <method class="ConstantImpl" name="boolean canSortWithIndex()" map="R"/>
  <method class="ConstantImpl" name="java.lang.Object evaluateSingleRecord(TableSchema[], Record[], ParameterHandler)" map="A"/>
  <method class="ConstantImpl" name="void deserialize(java.io.DataInputStream)" map="B"/>
  <method class="ConstantImpl" name="java.lang.String toString()" map="toString"/>
  <method class="ConstantImpl" name="java.lang.Object getValue()" map="o"/>
  <class name="DeleteStatement" map="A"/>
  <method class="DeleteStatement" name="void setWhereClause(Expression)" map="A"/>
  <method class="DeleteStatement" name="void setTableName(java.lang.String)" map="A"/>
  <method class="DeleteStatement" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <class name="UpdateStatement" map="B"/>
  <method class="UpdateStatement" name="void setWhereClause(Expression)" map="B"/>
  <method class="UpdateStatement" name="void setTableName(java.lang.String)" map="C"/>
  <method class="UpdateStatement" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <method class="UpdateStatement" name="void addSetExpression(Expression)" map="C"/>
  <class name="SelectStatement$JoinType" map="_A"/>
  <field class="SelectStatement$JoinType" name="inner" map="A"/>
  <field class="SelectStatement$JoinType" name="$VALUES" map="B"/>
  <field class="SelectStatement$JoinType" name="full" map="C"/>
  <field class="SelectStatement$JoinType" name="leftOuter" map="D"/>
  <field class="SelectStatement$JoinType" name="rightOuter" map="E"/>
  <method class="SelectStatement$JoinType" name="SelectStatement$JoinType[] values()" map="values"/>
  <method class="SelectStatement$JoinType" name="SelectStatement$JoinType valueOf(java.lang.String)" map="valueOf"/>
  <class name="SelectStatement" map="C"/>
  <method class="SelectStatement" name="void addJoinExpression(SelectStatement$JoinType, java.lang.String, Expression)" map="A"/>
  <method class="SelectStatement" name="void setWhereClause(Expression)" map="D"/>
  <method class="SelectStatement" name="void addSelectColumn(java.lang.String, net.sf.jsqlparser.expression.operators.relational.ExpressionList, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="SelectStatement" name="void setFromTable(java.lang.String)" map="D"/>
  <method class="SelectStatement" name="void addOrderByExpression(java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="SelectStatement" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <class name="InsertStatement" map="D"/>
  <method class="InsertStatement" name="void setTableName(java.lang.String)" map="B"/>
  <method class="InsertStatement" name="void addValue(java.lang.String, java.lang.Object)" map="A"/>
  <method class="InsertStatement" name="java.lang.Object execute(java.lang.String, SelectStatementImpl$Explain)" map="A"/>
  <class name="InExpression" map="E"/>
  <method class="InExpression" name="void addValue(java.lang.String)" map="A"/>
  <method class="InExpression" name="void addValue(long)" map="A"/>
  <method class="InExpression" name="void setColumn(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <class name="Expression" map="F"/>
  <class name="Statement" map="G"/>
  <method class="Statement" name="InExpression createInExpression()" map="A"/>
  <method class="Statement" name="BinaryExpression createBinaryExpression(Expression, BinaryExpression$Operator, Expression)" map="A"/>
  <method class="Statement" name="BinaryExpression createBinaryExpression(java.lang.String, BinaryExpression$Operator, java.lang.String)" map="A"/>
  <method class="Statement" name="BinaryExpression createBinaryExpression(java.lang.String, BinaryExpression$Operator, long)" map="A"/>
  <class name="CreateTableStatement" map="H"/>
  <method class="CreateTableStatement" name="void addField(java.lang.String, int)" map="A"/>
  <method class="CreateTableStatement" name="void setTableName(java.lang.String)" map="A"/>
  <method class="CreateTableStatement" name="void setPrimaryKey(java.util.List)" map="A"/>
  <method class="CreateTableStatement" name="int execute(java.lang.String)" map="B"/>
  <class name="BinaryExpression$Operator" map="_A"/>
  <field class="BinaryExpression$Operator" name="like" map="A"/>
  <field class="BinaryExpression$Operator" name="id" map="B"/>
  <field class="BinaryExpression$Operator" name="symbol" map="C"/>
  <field class="BinaryExpression$Operator" name="greaterEqual" map="D"/>
  <field class="BinaryExpression$Operator" name="$VALUES" map="E"/>
  <field class="BinaryExpression$Operator" name="or" map="F"/>
  <field class="BinaryExpression$Operator" name="and" map="G"/>
  <field class="BinaryExpression$Operator" name="notEqual" map="H"/>
  <field class="BinaryExpression$Operator" name="equal" map="I"/>
  <field class="BinaryExpression$Operator" name="less" map="J"/>
  <field class="BinaryExpression$Operator" name="lessEqual" map="K"/>
  <field class="BinaryExpression$Operator" name="greater" map="L"/>
  <method class="BinaryExpression$Operator" name="BinaryExpression$Operator valueOf(java.lang.String)" map="valueOf"/>
  <method class="BinaryExpression$Operator" name="BinaryExpression$Operator getOperator(int)" map="A"/>
  <method class="BinaryExpression$Operator" name="BinaryExpression$Operator[] values()" map="values"/>
  <method class="BinaryExpression$Operator" name="int getId()" map="A"/>
  <method class="BinaryExpression$Operator" name="boolean isRelationalOp()" map="B"/>
  <method class="BinaryExpression$Operator" name="java.lang.String getSymbol()" map="C"/>
  <class name="BinaryExpression" map="I"/>
  <field class="BinaryExpression" name="idToOperator" map="b"/>
  <method class="BinaryExpression" name="Expression getLeftExpression()" map="a"/>
  <method class="BinaryExpression" name="void setLeftExpression(Expression)" map="B"/>
  <method class="BinaryExpression" name="Expression getRightExpression()" map="b"/>
  <method class="BinaryExpression" name="void setRightExpression(Expression)" map="C"/>
  <class name="CreateIndexStatement" map="J"/>
  <method class="CreateIndexStatement" name="void setColumns(java.util.List)" map="A"/>
  <method class="CreateIndexStatement" name="void setTableName(java.lang.String)" map="A"/>
  <method class="CreateIndexStatement" name="void setName(java.lang.String)" map="B"/>
  <method class="CreateIndexStatement" name="int execute(java.lang.String)" map="C"/>
  <class name="ResultSet" map="K"/>
  <class name="Connection" map="L"/>
  <field class="Connection" name="client" map="A"/>
  <method class="Connection" name="SelectStatement createSelectStatement()" map="A"/>
  <method class="Connection" name="CreateTableStatement createCreateTableStatement()" map="B"/>
  <method class="Connection" name="UpdateStatement createUpdateStatement()" map="C"/>
  <method class="Connection" name="CreateIndexStatement createCreateIndexStatement()" map="D"/>
  <method class="Connection" name="InsertStatement createInsertStatement()" map="E"/>
  <class name="NotImplementedException" map="A"/>
  <class name="QueryType" map="B"/>
  <field class="QueryType" name="$VALUES" map="A"/>
  <field class="QueryType" name="execute4" map="B"/>
  <field class="QueryType" name="execute3" map="C"/>
  <field class="QueryType" name="update4" map="D"/>
  <field class="QueryType" name="execute2" map="E"/>
  <field class="QueryType" name="update3" map="F"/>
  <field class="QueryType" name="batch0" map="G"/>
  <field class="QueryType" name="update2" map="H"/>
  <field class="QueryType" name="execute1" map="I"/>
  <field class="QueryType" name="query1" map="J"/>
  <field class="QueryType" name="update1" map="K"/>
  <field class="QueryType" name="execute0" map="L"/>
  <field class="QueryType" name="query0" map="M"/>
  <field class="QueryType" name="update0" map="N"/>
  <method class="QueryType" name="QueryType valueOf(java.lang.String)" map="valueOf"/>
  <method class="QueryType" name="QueryType[] values()" map="values"/>
  <class name="ResultSetProxy$FieldType" map="_A"/>
  <field class="ResultSetProxy$FieldType" name="CHAR" map="A"/>
  <field class="ResultSetProxy$FieldType" name="JAVA_OBJECT" map="B"/>
  <field class="ResultSetProxy$FieldType" name="OTHER" map="C"/>
  <field class="ResultSetProxy$FieldType" name="DOUBLE" map="D"/>
  <field class="ResultSetProxy$FieldType" name="INTEGER" map="E"/>
  <field class="ResultSetProxy$FieldType" name="TIME" map="F"/>
  <field class="ResultSetProxy$FieldType" name="ARRAY" map="G"/>
  <field class="ResultSetProxy$FieldType" name="CLOB" map="H"/>
  <field class="ResultSetProxy$FieldType" name="REF" map="I"/>
  <field class="ResultSetProxy$FieldType" name="DATE" map="J"/>
  <field class="ResultSetProxy$FieldType" name="TINYINT" map="K"/>
  <field class="ResultSetProxy$FieldType" name="name" map="L"/>
  <field class="ResultSetProxy$FieldType" name="NUMERIC" map="M"/>
  <field class="ResultSetProxy$FieldType" name="OID" map="N"/>
  <field class="ResultSetProxy$FieldType" name="ROWID" map="O"/>
  <field class="ResultSetProxy$FieldType" name="VARCHAR" map="P"/>
  <field class="ResultSetProxy$FieldType" name="LONGNVARCHAR" map="Q"/>
  <field class="ResultSetProxy$FieldType" name="BIGINT" map="R"/>
  <field class="ResultSetProxy$FieldType" name="LONGVARBINARY" map="S"/>
  <field class="ResultSetProxy$FieldType" name="BOOLEAN" map="T"/>
  <field class="ResultSetProxy$FieldType" name="DECIMAL" map="U"/>
  <field class="ResultSetProxy$FieldType" name="NVARCHAR" map="V"/>
  <field class="ResultSetProxy$FieldType" name="DISTINCT" map="W"/>
  <field class="ResultSetProxy$FieldType" name="BYTEA" map="X"/>
  <field class="ResultSetProxy$FieldType" name="DATALINK" map="Y"/>
  <field class="ResultSetProxy$FieldType" name="NULL" map="Z"/>
  <field class="ResultSetProxy$FieldType" name="TIMESTAMP" map="_"/>
  <field class="ResultSetProxy$FieldType" name="BIT" map="a"/>
  <field class="ResultSetProxy$FieldType" name="$VALUES" map="b"/>
  <field class="ResultSetProxy$FieldType" name="REAL" map="c"/>
  <field class="ResultSetProxy$FieldType" name="NCHAR" map="d"/>
  <field class="ResultSetProxy$FieldType" name="SQLXML" map="e"/>
  <field class="ResultSetProxy$FieldType" name="LONGVARCHAR" map="f"/>
  <field class="ResultSetProxy$FieldType" name="FLOAT" map="g"/>
  <field class="ResultSetProxy$FieldType" name="VARBINARY" map="h"/>
  <field class="ResultSetProxy$FieldType" name="BLOB" map="i"/>
  <field class="ResultSetProxy$FieldType" name="SMALLINT" map="j"/>
  <field class="ResultSetProxy$FieldType" name="BINARY" map="k"/>
  <field class="ResultSetProxy$FieldType" name="NCLOB" map="l"/>
  <field class="ResultSetProxy$FieldType" name="STRUCT" map="m"/>
  <field class="ResultSetProxy$FieldType" name="type" map="n"/>
  <method class="ResultSetProxy$FieldType" name="java.lang.String access$000(ResultSetProxy$FieldType)" map="A"/>
  <method class="ResultSetProxy$FieldType" name="ResultSetProxy$FieldType[] values()" map="values"/>
  <method class="ResultSetProxy$FieldType" name="int access$100(ResultSetProxy$FieldType)" map="B"/>
  <method class="ResultSetProxy$FieldType" name="ResultSetProxy$FieldType valueOf(java.lang.String)" map="valueOf"/>
  <class name="ResultSetProxy$Table" map="_B"/>
  <field class="ResultSetProxy$Table" name="name" map="A"/>
  <method class="ResultSetProxy$Table" name="java.lang.String getName()" map="A"/>
  <class name="ResultSetProxy$ResultSetInfo" map="_C"/>
  <field class="ResultSetProxy$ResultSetInfo" name="highestIndex" map="A"/>
  <field class="ResultSetProxy$ResultSetInfo" name="resultSet" map="B"/>
  <field class="ResultSetProxy$ResultSetInfo" name="currRow" map="C"/>
  <method class="ResultSetProxy$ResultSetInfo" name="int access$402(ResultSetProxy$ResultSetInfo, int)" map="A"/>
  <method class="ResultSetProxy$ResultSetInfo" name="int access$400(ResultSetProxy$ResultSetInfo)" map="A"/>
  <method class="ResultSetProxy$ResultSetInfo" name="int access$308(ResultSetProxy$ResultSetInfo)" map="B"/>
  <method class="ResultSetProxy$ResultSetInfo" name="int access$300(ResultSetProxy$ResultSetInfo)" map="C"/>
  <method class="ResultSetProxy$ResultSetInfo" name="ResultSetImpl access$200(ResultSetProxy$ResultSetInfo)" map="D"/>
  <field class="ResultSetProxy" name="loadedBlobs" map="A"/>
  <field class="ResultSetProxy" name="currResultSetOffset" map="B"/>
  <field class="ResultSetProxy" name="resultSets" map="C"/>
  <field class="ResultSetProxy" name="LOGGER" map="D"/>
  <field class="ResultSetProxy" name="lookupTypeByName" map="E"/>
  <field class="ResultSetProxy" name="resultSet" map="F"/>
  <field class="ResultSetProxy" name="wasNull" map="G"/>
  <field class="ResultSetProxy" name="currRow" map="H"/>
  <class name="NotSupportedException" map="C"/>
  <class name="ParameterHandler" map="D"/>
  <field class="ParameterHandler" name="currParmsByIndex" map="A"/>
  <field class="ParameterHandler" name="currParmsByName" map="B"/>
  <field class="ParameterHandler" name="boundParms" map="C"/>
  <field class="ParameterHandler" name="currentBatchOffset" map="D"/>
  <method class="ParameterHandler" name="void setBinaryStream(int, java.io.InputStream)" map="setBinaryStream"/>
  <method class="ParameterHandler" name="java.sql.ResultSetMetaData getMetaData()" map="getMetaData"/>
  <method class="ParameterHandler" name="void setNCharacterStream(int, java.io.Reader)" map="setNCharacterStream"/>
  <method class="ParameterHandler" name="void setClob(int, java.io.Reader)" map="setClob"/>
  <method class="ParameterHandler" name="void deserialize(byte[])" map="A"/>
  <method class="ParameterHandler" name="java.util.Map getCurrParmsByIndex()" map="A"/>
  <method class="ParameterHandler" name="void clearParameters()" map="clearParameters"/>
  <method class="ParameterHandler" name="void setBinaryStream(int, java.io.InputStream, long)" map="setBinaryStream"/>
  <method class="ParameterHandler" name="void setShort(int, short)" map="setShort"/>
  <method class="ParameterHandler" name="java.lang.Object getValue(java.lang.String)" map="A"/>
  <method class="ParameterHandler" name="void setArray(int, java.sql.Array)" map="setArray"/>
  <method class="ParameterHandler" name="void serialize(java.io.DataOutputStream)" map="A"/>
  <method class="ParameterHandler" name="void setByte(int, byte)" map="setByte"/>
  <method class="ParameterHandler" name="byte[] serialize()" map="B"/>
  <method class="ParameterHandler" name="void setNClob(int, java.io.Reader, long)" map="setNClob"/>
  <method class="ParameterHandler" name="void setBinaryStream(int, java.io.InputStream, int)" map="setBinaryStream"/>
  <method class="ParameterHandler" name="void setURL(int, java.net.URL)" map="setURL"/>
  <method class="ParameterHandler" name="void setTime(int, java.sql.Time)" map="setTime"/>
  <method class="ParameterHandler" name="java.lang.Object getValue(int)" map="A"/>
  <method class="ParameterHandler" name="void setRowId(int, java.sql.RowId)" map="setRowId"/>
  <method class="ParameterHandler" name="void clearBatch()" map="clearBatch"/>
  <method class="ParameterHandler" name="void setTimestamp(int, java.sql.Timestamp, java.util.Calendar)" map="setTimestamp"/>
  <method class="ParameterHandler" name="void setClob(int, java.io.Reader, long)" map="setClob"/>
  <method class="ParameterHandler" name="java.sql.ParameterMetaData getParameterMetaData()" map="getParameterMetaData"/>
  <method class="ParameterHandler" name="void setDate(int, java.sql.Date)" map="setDate"/>
  <method class="ParameterHandler" name="void setDate(int, java.sql.Date, java.util.Calendar)" map="setDate"/>
  <method class="ParameterHandler" name="void setCharacterStream(int, java.io.Reader)" map="setCharacterStream"/>
  <method class="ParameterHandler" name="java.util.HashMap getCurrParmsByName()" map="C"/>
  <method class="ParameterHandler" name="void setObject(int, java.lang.Object, int)" map="setObject"/>
  <method class="ParameterHandler" name="void setAsciiStream(int, java.io.InputStream)" map="setAsciiStream"/>
  <method class="ParameterHandler" name="void setCharacterStream(int, java.io.Reader, long)" map="setCharacterStream"/>
  <method class="ParameterHandler" name="void setBlob(int, java.sql.Blob)" map="setBlob"/>
  <method class="ParameterHandler" name="void setNString(int, java.lang.String)" map="setNString"/>
  <method class="ParameterHandler" name="void setClob(int, java.sql.Clob)" map="setClob"/>
  <method class="ParameterHandler" name="void setAsciiStream(int, java.io.InputStream, long)" map="setAsciiStream"/>
  <method class="ParameterHandler" name="void setUnicodeStream(int, java.io.InputStream, int)" map="setUnicodeStream"/>
  <method class="ParameterHandler" name="void setBoolean(int, boolean)" map="setBoolean"/>
  <method class="ParameterHandler" name="void setCharacterStream(int, java.io.Reader, int)" map="setCharacterStream"/>
  <method class="ParameterHandler" name="void setFloat(int, float)" map="setFloat"/>
  <method class="ParameterHandler" name="void setString(int, java.lang.String)" map="setString"/>
  <method class="ParameterHandler" name="void setDouble(int, double)" map="setDouble"/>
  <method class="ParameterHandler" name="void deserialize(java.io.DataInputStream)" map="A"/>
  <method class="ParameterHandler" name="void setObject(int, java.lang.Object, int, int)" map="setObject"/>
  <method class="ParameterHandler" name="void setAsciiStream(int, java.io.InputStream, int)" map="setAsciiStream"/>
  <method class="ParameterHandler" name="void setObject(int, java.lang.Object)" map="setObject"/>
  <method class="ParameterHandler" name="void setInt(int, int)" map="setInt"/>
  <method class="ParameterHandler" name="void setSQLXML(int, java.sql.SQLXML)" map="setSQLXML"/>
  <method class="ParameterHandler" name="void setNClob(int, java.sql.NClob)" map="setNClob"/>
  <method class="ParameterHandler" name="void setBlob(int, java.io.InputStream)" map="setBlob"/>
  <method class="ParameterHandler" name="void setBigDecimal(int, java.math.BigDecimal)" map="setBigDecimal"/>
  <method class="ParameterHandler" name="void setLong(int, long)" map="setLong"/>
  <method class="ParameterHandler" name="void setNClob(int, java.io.Reader)" map="setNClob"/>
  <method class="ParameterHandler" name="void setNull(int, int, java.lang.String)" map="setNull"/>
  <method class="ParameterHandler" name="void setBytes(int, byte[])" map="setBytes"/>
  <method class="ParameterHandler" name="void setNull(int, int)" map="setNull"/>
  <method class="ParameterHandler" name="void setNCharacterStream(int, java.io.Reader, long)" map="setNCharacterStream"/>
  <method class="ParameterHandler" name="void setTimestamp(int, java.sql.Timestamp)" map="setTimestamp"/>
  <method class="ParameterHandler" name="void setTime(int, java.sql.Time, java.util.Calendar)" map="setTime"/>
  <method class="ParameterHandler" name="void setBlob(int, java.io.InputStream, long)" map="setBlob"/>
  <method class="ParameterHandler" name="void setRef(int, java.sql.Ref)" map="setRef"/>
  <field class="ConnectionProxy$Replica" name="$VALUES" map="A"/>
  <field class="ConnectionProxy$Replica" name="cliReplica" map="B"/>
  <method class="ConnectionProxy$Replica" name="DatabaseClient$Replica access$000(ConnectionProxy$Replica)" map="A"/>
  <field class="ConnectionProxy" name="typemap" map="A"/>
  <field class="ConnectionProxy" name="databaseClient" map="B"/>
  <field class="ConnectionProxy" name="rsHoldability" map="C"/>
  <field class="ConnectionProxy" name="autoCommit" map="D"/>
  <field class="ConnectionProxy" name="closed" map="E"/>
  <field class="ConnectionProxy" name="clientMutex" map="F"/>
  <field class="ConnectionProxy" name="dbName" map="G"/>
  <field class="ConnectionProxy" name="properties" map="H"/>
  <field class="ConnectionProxy" name="globalContextRefCount" map="I"/>
  <field class="ConnectionProxy" name="_clientInfo" map="J"/>
  <field class="ConnectionProxy" name="shard" map="K"/>
  <method class="ConnectionProxy" name="void initGlobalContext()" map="A"/>
  <method class="ConnectionProxy" name="void checkClosed()" map="B"/>
  <class name="StatementProxy" map="E"/>
  <field class="StatementProxy" name="databaseClient" map="E"/>
  <field class="StatementProxy" name="maxFieldSize" map="F"/>
  <field class="StatementProxy" name="connectionProxy" map="G"/>
  <field class="StatementProxy" name="dbName" map="H"/>
  <field class="StatementProxy" name="fetchSize" map="I"/>
  <field class="StatementProxy" name="fetchDirection" map="J"/>
  <field class="StatementProxy" name="parms" map="K"/>
  <field class="StatementProxy" name="maxRows" map="L"/>
  <field class="StatementProxy" name="sql" map="M"/>
  <method class="StatementProxy" name="void setObject(int, java.lang.Object)" map="setObject"/>
  <method class="StatementProxy" name="void setRowId(int, java.sql.RowId)" map="setRowId"/>
  <method class="StatementProxy" name="void setCharacterStream(int, java.io.Reader, long)" map="setCharacterStream"/>
  <method class="StatementProxy" name="boolean isCloseOnCompletion()" map="isCloseOnCompletion"/>
  <method class="StatementProxy" name="void setArray(int, java.sql.Array)" map="setArray"/>
  <method class="StatementProxy" name="void setBinaryStream(int, java.io.InputStream)" map="setBinaryStream"/>
  <method class="StatementProxy" name="void setCharacterStream(int, java.io.Reader, int)" map="setCharacterStream"/>
  <method class="StatementProxy" name="void setBlob(int, java.sql.Blob)" map="setBlob"/>
  <method class="StatementProxy" name="void setMaxRows(int)" map="setMaxRows"/>
  <method class="StatementProxy" name="java.sql.SQLWarning getWarnings()" map="getWarnings"/>
  <method class="StatementProxy" name="void setTime(int, java.sql.Time)" map="setTime"/>
  <method class="StatementProxy" name="int getUpdateCount()" map="getUpdateCount"/>
  <method class="StatementProxy" name="void addBatch(java.lang.String)" map="addBatch"/>
  <method class="StatementProxy" name="void setBoolean(int, boolean)" map="setBoolean"/>
  <method class="StatementProxy" name="void setNClob(int, java.sql.NClob)" map="setNClob"/>
  <method class="StatementProxy" name="void setQueryTimeout(int)" map="setQueryTimeout"/>
  <method class="StatementProxy" name="int getMaxFieldSize()" map="getMaxFieldSize"/>
  <method class="StatementProxy" name="void setBinaryStream(int, java.io.InputStream, long)" map="setBinaryStream"/>
  <method class="StatementProxy" name="void setTimestamp(int, java.sql.Timestamp, java.util.Calendar)" map="setTimestamp"/>
  <method class="StatementProxy" name="void setTime(int, java.sql.Time, java.util.Calendar)" map="setTime"/>
  <method class="StatementProxy" name="void clearWarnings()" map="clearWarnings"/>
  <method class="StatementProxy" name="void setBinaryStream(int, java.io.InputStream, int)" map="setBinaryStream"/>
  <method class="StatementProxy" name="int getResultSetConcurrency()" map="getResultSetConcurrency"/>
  <method class="StatementProxy" name="java.sql.ResultSetMetaData getMetaData()" map="getMetaData"/>
  <method class="StatementProxy" name="void setClob(int, java.sql.Clob)" map="setClob"/>
  <method class="StatementProxy" name="void addBatch()" map="addBatch"/>
  <method class="StatementProxy" name="boolean isClosed()" map="isClosed"/>
  <method class="StatementProxy" name="void setNull(int, int)" map="setNull"/>
  <method class="StatementProxy" name="void setByte(int, byte)" map="setByte"/>
  <method class="StatementProxy" name="int executeUpdate(java.lang.String, java.lang.String[])" map="executeUpdate"/>
  <method class="StatementProxy" name="void setShort(int, short)" map="setShort"/>
  <method class="StatementProxy" name="boolean isWrapperFor(java.lang.Class)" map="isWrapperFor"/>
  <method class="StatementProxy" name="int executeUpdate(java.lang.String)" map="executeUpdate"/>
  <method class="StatementProxy" name="java.sql.ResultSet getResultSet()" map="getResultSet"/>
  <method class="StatementProxy" name="int executeUpdate(java.lang.String, int)" map="executeUpdate"/>
  <method class="StatementProxy" name="boolean execute(java.lang.String, int)" map="execute"/>
  <method class="StatementProxy" name="boolean isPoolable()" map="isPoolable"/>
  <method class="StatementProxy" name="ParameterHandler getParms()" map="D"/>
  <method class="StatementProxy" name="void setBlob(int, java.io.InputStream)" map="setBlob"/>
  <method class="StatementProxy" name="void setNClob(int, java.io.Reader, long)" map="setNClob"/>
  <method class="StatementProxy" name="void setNCharacterStream(int, java.io.Reader)" map="setNCharacterStream"/>
  <method class="StatementProxy" name="boolean execute(java.lang.String, java.lang.String[])" map="execute"/>
  <method class="StatementProxy" name="int getFetchDirection()" map="getFetchDirection"/>
  <method class="StatementProxy" name="int getFetchSize()" map="getFetchSize"/>
  <method class="StatementProxy" name="void setLong(int, long)" map="setLong"/>
  <method class="StatementProxy" name="void setFetchSize(int)" map="setFetchSize"/>
  <method class="StatementProxy" name="int getQueryTimeout()" map="getQueryTimeout"/>
  <method class="StatementProxy" name="void setNCharacterStream(int, java.io.Reader, long)" map="setNCharacterStream"/>
  <method class="StatementProxy" name="void setCursorName(java.lang.String)" map="setCursorName"/>
  <method class="StatementProxy" name="void setBigDecimal(int, java.math.BigDecimal)" map="setBigDecimal"/>
  <method class="StatementProxy" name="java.sql.Connection getConnection()" map="getConnection"/>
  <method class="StatementProxy" name="void setMaxFieldSize(int)" map="setMaxFieldSize"/>
  <method class="StatementProxy" name="void setObject(int, java.lang.Object, int, int)" map="setObject"/>
  <method class="StatementProxy" name="void setNull(int, int, java.lang.String)" map="setNull"/>
  <method class="StatementProxy" name="void setDate(int, java.sql.Date, java.util.Calendar)" map="setDate"/>
  <method class="StatementProxy" name="void setNClob(int, java.io.Reader)" map="setNClob"/>
  <method class="StatementProxy" name="void setClob(int, java.io.Reader)" map="setClob"/>
  <method class="StatementProxy" name="void setEscapeProcessing(boolean)" map="setEscapeProcessing"/>
  <method class="StatementProxy" name="void setInt(int, int)" map="setInt"/>
  <method class="StatementProxy" name="int executeUpdate()" map="executeUpdate"/>
  <method class="StatementProxy" name="int getMaxRows()" map="getMaxRows"/>
  <method class="StatementProxy" name="java.sql.ResultSet getGeneratedKeys()" map="getGeneratedKeys"/>
  <method class="StatementProxy" name="int[] executeBatch()" map="executeBatch"/>
  <method class="StatementProxy" name="boolean getMoreResults(int)" map="getMoreResults"/>
  <method class="StatementProxy" name="void setFetchDirection(int)" map="setFetchDirection"/>
  <method class="StatementProxy" name="void setCharacterStream(int, java.io.Reader)" map="setCharacterStream"/>
  <method class="StatementProxy" name="void clearBatch()" map="clearBatch"/>
  <method class="StatementProxy" name="void setNString(int, java.lang.String)" map="setNString"/>
  <method class="StatementProxy" name="boolean execute()" map="execute"/>
  <method class="StatementProxy" name="boolean execute(java.lang.String, int[])" map="execute"/>
  <method class="StatementProxy" name="void setTimestamp(int, java.sql.Timestamp)" map="setTimestamp"/>
  <method class="StatementProxy" name="void setString(int, java.lang.String)" map="setString"/>
  <method class="StatementProxy" name="void setBlob(int, java.io.InputStream, long)" map="setBlob"/>
  <method class="StatementProxy" name="void setURL(int, java.net.URL)" map="setURL"/>
  <method class="StatementProxy" name="java.sql.ResultSet executeQuery()" map="executeQuery"/>
  <method class="StatementProxy" name="boolean execute(java.lang.String)" map="execute"/>
  <method class="StatementProxy" name="void setSQLXML(int, java.sql.SQLXML)" map="setSQLXML"/>
  <method class="StatementProxy" name="void setAsciiStream(int, java.io.InputStream, long)" map="setAsciiStream"/>
  <method class="StatementProxy" name="int getResultSetType()" map="getResultSetType"/>
  <method class="StatementProxy" name="void closeOnCompletion()" map="closeOnCompletion"/>
  <method class="StatementProxy" name="void setDate(int, java.sql.Date)" map="setDate"/>
  <method class="StatementProxy" name="void setAsciiStream(int, java.io.InputStream, int)" map="setAsciiStream"/>
  <method class="StatementProxy" name="boolean getMoreResults()" map="getMoreResults"/>
  <method class="StatementProxy" name="java.sql.ParameterMetaData getParameterMetaData()" map="getParameterMetaData"/>
  <method class="StatementProxy" name="int executeUpdate(java.lang.String, int[])" map="executeUpdate"/>
  <method class="StatementProxy" name="void setAsciiStream(int, java.io.InputStream)" map="setAsciiStream"/>
  <method class="StatementProxy" name="void setFloat(int, float)" map="setFloat"/>
  <method class="StatementProxy" name="void setPoolable(boolean)" map="setPoolable"/>
  <method class="StatementProxy" name="void setUnicodeStream(int, java.io.InputStream, int)" map="setUnicodeStream"/>
  <method class="StatementProxy" name="java.sql.ResultSet executeQuery(java.lang.String)" map="executeQuery"/>
  <method class="StatementProxy" name="void setDouble(int, double)" map="setDouble"/>
  <method class="StatementProxy" name="java.lang.Object unwrap(java.lang.Class)" map="unwrap"/>
  <method class="StatementProxy" name="void close()" map="close"/>
  <method class="StatementProxy" name="void setBytes(int, byte[])" map="setBytes"/>
  <method class="StatementProxy" name="void setRef(int, java.sql.Ref)" map="setRef"/>
  <method class="StatementProxy" name="void cancel()" map="cancel"/>
  <method class="StatementProxy" name="void setClob(int, java.io.Reader, long)" map="setClob"/>
  <method class="StatementProxy" name="void setObject(int, java.lang.Object, int)" map="setObject"/>
  <method class="StatementProxy" name="int getResultSetHoldability()" map="getResultSetHoldability"/>
  <field class="Driver" name="driver" map="A"/>
  <class name="Parameter$Byte" map="_A"/>
  <method class="Parameter$Byte" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="Q"/>
  <method class="Parameter$Byte" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Byte" name="int getSqlType()" map="B"/>
  <class name="Parameter$Date" map="_B"/>
  <field class="Parameter$Date" name="cal" map="B"/>
  <method class="Parameter$Date" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="A"/>
  <method class="Parameter$Date" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Date" name="int getSqlType()" map="B"/>
  <class name="Parameter$BigDecimal" map="_C"/>
  <method class="Parameter$BigDecimal" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="B"/>
  <method class="Parameter$BigDecimal" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$BigDecimal" name="int getSqlType()" map="B"/>
  <class name="Parameter$NClobReader" map="_D"/>
  <field class="Parameter$NClobReader" name="length" map="C"/>
  <method class="Parameter$NClobReader" name="int getSqlType()" map="B"/>
  <class name="Parameter$Float" map="_E"/>
  <method class="Parameter$Float" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="C"/>
  <method class="Parameter$Float" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Float" name="int getSqlType()" map="B"/>
  <class name="Parameter$Blob" map="_F"/>
  <method class="Parameter$Blob" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="D"/>
  <method class="Parameter$Blob" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Blob" name="int getSqlType()" map="B"/>
  <class name="Parameter$Int" map="_G"/>
  <method class="Parameter$Int" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="E"/>
  <method class="Parameter$Int" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Int" name="int getSqlType()" map="B"/>
  <class name="Parameter$NCharacterStream" map="_H"/>
  <field class="Parameter$NCharacterStream" name="length" map="D"/>
  <method class="Parameter$NCharacterStream" name="int getSqlType()" map="B"/>
  <class name="Parameter$Double" map="_I"/>
  <method class="Parameter$Double" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="F"/>
  <method class="Parameter$Double" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Double" name="int getSqlType()" map="B"/>
  <class name="Parameter$Clob" map="_J"/>
  <method class="Parameter$Clob" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="G"/>
  <method class="Parameter$Clob" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Clob" name="int getSqlType()" map="B"/>
  <class name="Parameter$ClobReader" map="_K"/>
  <field class="Parameter$ClobReader" name="length" map="E"/>
  <method class="Parameter$ClobReader" name="int getSqlType()" map="B"/>
  <class name="Parameter$Short" map="_L"/>
  <method class="Parameter$Short" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="H"/>
  <method class="Parameter$Short" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Short" name="int getSqlType()" map="B"/>
  <class name="Parameter$Time" map="_M"/>
  <field class="Parameter$Time" name="cal" map="F"/>
  <method class="Parameter$Time" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="I"/>
  <method class="Parameter$Time" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Time" name="int getSqlType()" map="B"/>
  <class name="Parameter$NClob" map="_N"/>
  <method class="Parameter$NClob" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="J"/>
  <method class="Parameter$NClob" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$NClob" name="int getSqlType()" map="B"/>
  <class name="Parameter$Array" map="_O"/>
  <method class="Parameter$Array" name="int getSqlType()" map="B"/>
  <class name="Parameter$CharacterStream" map="_P"/>
  <field class="Parameter$CharacterStream" name="length" map="G"/>
  <method class="Parameter$CharacterStream" name="int getSqlType()" map="B"/>
  <class name="Parameter$BinaryStream" map="_Q"/>
  <field class="Parameter$BinaryStream" name="length" map="H"/>
  <method class="Parameter$BinaryStream" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="K"/>
  <method class="Parameter$BinaryStream" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$BinaryStream" name="int getSqlType()" map="B"/>
  <class name="Parameter$UnicodeStream" map="_R"/>
  <field class="Parameter$UnicodeStream" name="length" map="I"/>
  <method class="Parameter$UnicodeStream" name="int getSqlType()" map="B"/>
  <class name="Parameter$RowId" map="_S"/>
  <method class="Parameter$RowId" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$RowId" name="int getSqlType()" map="B"/>
  <class name="Parameter$Timestamp" map="_T"/>
  <field class="Parameter$Timestamp" name="cal" map="J"/>
  <method class="Parameter$Timestamp" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="L"/>
  <method class="Parameter$Timestamp" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Timestamp" name="int getSqlType()" map="B"/>
  <class name="Parameter$Null" map="_U"/>
  <field class="Parameter$Null" name="typeName" map="K"/>
  <field class="Parameter$Null" name="sqlType" map="L"/>
  <method class="Parameter$Null" name="int getSqlTypeWrapping()" map="C"/>
  <method class="Parameter$Null" name="int getSqlType()" map="B"/>
  <class name="Parameter$Bytes" map="_V"/>
  <method class="Parameter$Bytes" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="M"/>
  <method class="Parameter$Bytes" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Bytes" name="int getSqlType()" map="B"/>
  <class name="Parameter$AsciiStream" map="_W"/>
  <field class="Parameter$AsciiStream" name="length" map="M"/>
  <method class="Parameter$AsciiStream" name="int getSqlType()" map="B"/>
  <class name="Parameter$NString" map="_X"/>
  <method class="Parameter$NString" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$NString" name="int getSqlType()" map="B"/>
  <class name="Parameter$String" map="_Y"/>
  <method class="Parameter$String" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="N"/>
  <method class="Parameter$String" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$String" name="int getSqlType()" map="B"/>
  <class name="Parameter$ParameterBase" map="_Z"/>
  <field class="Parameter$ParameterBase" name="value" map="A"/>
  <method class="Parameter$ParameterBase" name="java.lang.Object getValue()" map="A"/>
  <method class="Parameter$ParameterBase" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$ParameterBase" name="int getSqlType()" map="B"/>
  <class name="Parameter$Long" map="__"/>
  <method class="Parameter$Long" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="O"/>
  <method class="Parameter$Long" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Long" name="int getSqlType()" map="B"/>
  <class name="Parameter$Boolean" map="_a"/>
  <method class="Parameter$Boolean" name="Parameter$ParameterBase deserialize(java.io.DataInputStream)" map="P"/>
  <method class="Parameter$Boolean" name="void serialize(java.io.DataOutputStream, boolean)" map="A"/>
  <method class="Parameter$Boolean" name="int getSqlType()" map="B"/>
  <class name="Parameter" map="F"/>
  <package name="com.sonicbase.socket" map="D"/>
  <class name="DeadServerException" map="A"/>
  <class name="DatabaseSocketClient$NioClient$1" map="1"/>
  <field class="DatabaseSocketClient$NioClient$1" name="this$0" map="this$0"/>
  <method class="DatabaseSocketClient$NioClient$1" name="void initChannel(io.netty.channel.Channel)" map="initChannel"/>
  <method class="DatabaseSocketClient$NioClient$1" name="void initChannel(io.netty.channel.socket.SocketChannel)" map="initChannel"/>
  <class name="DatabaseSocketClient$NioClient" map="_A"/>
  <field class="DatabaseSocketClient$NioClient" name="clientHandler" map="A"/>
  <method class="DatabaseSocketClient$NioClient" name="DatabaseSocketClient$ClientNioHandler access$000(DatabaseSocketClient$NioClient)" map="A"/>
  <class name="DatabaseSocketClient$Request" map="_B"/>
  <field class="DatabaseSocketClient$Request" name="hostPort" map="A"/>
  <field class="DatabaseSocketClient$Request" name="exception" map="B"/>
  <field class="DatabaseSocketClient$Request" name="command" map="C"/>
  <field class="DatabaseSocketClient$Request" name="response" map="D"/>
  <field class="DatabaseSocketClient$Request" name="body" map="E"/>
  <field class="DatabaseSocketClient$Request" name="latch" map="F"/>
  <field class="DatabaseSocketClient$Request" name="socketClient" map="G"/>
  <field class="DatabaseSocketClient$Request" name="batchKey" map="H"/>
  <field class="DatabaseSocketClient$Request" name="success" map="I"/>
  <method class="DatabaseSocketClient$Request" name="byte[] access$1100(DatabaseSocketClient$Request)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="java.lang.String access$1000(DatabaseSocketClient$Request)" map="B"/>
  <method class="DatabaseSocketClient$Request" name="boolean access$1300(DatabaseSocketClient$Request)" map="C"/>
  <method class="DatabaseSocketClient$Request" name="void setException(java.lang.Exception)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="java.lang.String access$300(DatabaseSocketClient$Request)" map="D"/>
  <method class="DatabaseSocketClient$Request" name="byte[] access$1102(DatabaseSocketClient$Request, byte[])" map="A"/>
  <method class="DatabaseSocketClient$Request" name="void setBatchKey(java.lang.String)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="byte[] access$1400(DatabaseSocketClient$Request)" map="E"/>
  <method class="DatabaseSocketClient$Request" name="java.lang.Exception access$500(DatabaseSocketClient$Request)" map="F"/>
  <method class="DatabaseSocketClient$Request" name="void setHostPort(java.lang.String)" map="B"/>
  <method class="DatabaseSocketClient$Request" name="java.lang.String access$1002(DatabaseSocketClient$Request, java.lang.String)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="void setSuccess(boolean)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="java.lang.Exception access$502(DatabaseSocketClient$Request, java.lang.Exception)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="void setSocketClient(DatabaseSocketClient)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="void setBody(byte[])" map="A"/>
  <method class="DatabaseSocketClient$Request" name="void setResponse(byte[])" map="B"/>
  <method class="DatabaseSocketClient$Request" name="void setCommand(java.lang.String)" map="C"/>
  <method class="DatabaseSocketClient$Request" name="void setLatch(java.util.concurrent.CountDownLatch)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="java.lang.String access$302(DatabaseSocketClient$Request, java.lang.String)" map="B"/>
  <method class="DatabaseSocketClient$Request" name="java.util.concurrent.CountDownLatch access$600(DatabaseSocketClient$Request)" map="G"/>
  <method class="DatabaseSocketClient$Request" name="boolean access$1302(DatabaseSocketClient$Request, boolean)" map="A"/>
  <method class="DatabaseSocketClient$Request" name="byte[] access$1402(DatabaseSocketClient$Request, byte[])" map="B"/>
  <class name="DatabaseSocketClient$BatchSender" map="_C"/>
  <field class="DatabaseSocketClient$BatchSender" name="queue" map="A"/>
  <field class="DatabaseSocketClient$BatchSender" name="port" map="B"/>
  <field class="DatabaseSocketClient$BatchSender" name="host" map="C"/>
  <method class="DatabaseSocketClient$BatchSender" name="void run()" map="run"/>
  <class name="DatabaseSocketClient$Connection" map="_D"/>
  <field class="DatabaseSocketClient$Connection" name="sock" map="A"/>
  <field class="DatabaseSocketClient$Connection" name="count_called" map="B"/>
  <method class="DatabaseSocketClient$Connection" name="java.nio.channels.SocketChannel access$1200(DatabaseSocketClient$Connection)" map="A"/>
  <class name="DatabaseSocketClient$ClientNioHandler" map="_E"/>
  <field class="DatabaseSocketClient$ClientNioHandler" name="lenPos" map="A"/>
  <field class="DatabaseSocketClient$ClientNioHandler" name="lenBytes" map="B"/>
  <field class="DatabaseSocketClient$ClientNioHandler" name="body" map="C"/>
  <field class="DatabaseSocketClient$ClientNioHandler" name="bodyPos" map="D"/>
  <field class="DatabaseSocketClient$ClientNioHandler" name="channel" map="E"/>
  <field class="DatabaseSocketClient$ClientNioHandler" name="latch" map="F"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="void channelRegistered(io.netty.channel.ChannelHandlerContext)" map="channelRegistered"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="void await()" map="await"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="void write(byte[])" map="write"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="io.netty.channel.socket.SocketChannel access$200(DatabaseSocketClient$ClientNioHandler)" map="access$200"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="void exceptionCaught(io.netty.channel.ChannelHandlerContext, java.lang.Throwable)" map="exceptionCaught"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="void handlerRemoved(io.netty.channel.ChannelHandlerContext)" map="handlerRemoved"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="void handlerAdded(io.netty.channel.ChannelHandlerContext)" map="handlerAdded"/>
  <method class="DatabaseSocketClient$ClientNioHandler" name="void channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object)" map="channelRead"/>
  <class name="DatabaseSocketClient" map="B"/>
  <field class="DatabaseSocketClient" name="batchCount" map="A"/>
  <field class="DatabaseSocketClient" name="BATCH_SIZE" map="B"/>
  <field class="DatabaseSocketClient" name="connectionCount" map="C"/>
  <field class="DatabaseSocketClient" name="BATCH_THREAD_COUNT" map="D"/>
  <field class="DatabaseSocketClient" name="clientGroup" map="E"/>
  <field class="DatabaseSocketClient" name="LZO_COMPRESSION" map="F"/>
  <field class="DatabaseSocketClient" name="COMPRESS" map="G"/>
  <field class="DatabaseSocketClient" name="batchThreads" map="H"/>
  <field class="DatabaseSocketClient" name="CONNECTION_COUNT" map="I"/>
  <field class="DatabaseSocketClient" name="batchTotalEntryCount" map="J"/>
  <field class="DatabaseSocketClient" name="pools" map="K"/>
  <field class="DatabaseSocketClient" name="ENABLE_BATCH" map="L"/>
  <field class="DatabaseSocketClient" name="requestQueues" map="M"/>
  <field class="DatabaseSocketClient" name="logger" map="N"/>
  <method class="DatabaseSocketClient" name="byte[] do_send(java.util.List)" map="A"/>
  <method class="DatabaseSocketClient" name="void shutdown()" map="A"/>
  <method class="DatabaseSocketClient" name="java.util.concurrent.atomic.AtomicLong access$700()" map="B"/>
  <method class="DatabaseSocketClient" name="DatabaseSocketClient$Connection borrow_connection(java.lang.String, int)" map="A"/>
  <method class="DatabaseSocketClient" name="void processResponse(java.io.InputStream, DatabaseSocketClient$Request)" map="A"/>
  <method class="DatabaseSocketClient" name="void access$400(java.lang.String, int, java.util.List)" map="A"/>
  <method class="DatabaseSocketClient" name="org.apache.log4j.Logger access$900()" map="C"/>
  <method class="DatabaseSocketClient" name="void serializeSingleRequest(java.io.ByteArrayOutputStream, java.lang.String, byte[])" map="A"/>
  <method class="DatabaseSocketClient" name="byte[] do_send(java.lang.String, java.lang.String, byte[], java.lang.String)" map="A"/>
  <method class="DatabaseSocketClient" name="void return_connection(DatabaseSocketClient$Connection, java.lang.String, int)" map="A"/>
  <method class="DatabaseSocketClient" name="io.netty.channel.EventLoopGroup access$100()" map="D"/>
  <method class="DatabaseSocketClient" name="java.util.List getBatchThreads()" map="E"/>
  <method class="DatabaseSocketClient" name="void sendBatch(java.lang.String, int, java.util.List)" map="B"/>
  <method class="DatabaseSocketClient" name="java.util.concurrent.atomic.AtomicInteger access$800()" map="F"/>
  <method class="DatabaseSocketClient" name="void initBatchSender(java.lang.String, int, DatabaseSocketClient)" map="A"/>
  <class name="Util" map="C"/>
  <method class="Util" name="int readRawLittleEndian32(byte[], int)" map="A"/>
  <method class="Util" name="long readRawLittleEndian64(byte[])" map="A"/>
  <method class="Util" name="long readRawLittleEndian64(byte[], int)" map="B"/>
  <method class="Util" name="void writeRawLittleEndian64(long, byte[])" map="A"/>
  <method class="Util" name="int readRawLittleEndian32(byte[])" map="B"/>
  <method class="Util" name="void writeRawLittleEndian32(int, byte[])" map="A"/>
</map>
</yguard>
